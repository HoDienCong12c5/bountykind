/* Pixi3D v1.6.2 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@pixi/loaders'), require('@pixi/core'), require('@pixi/math'), require('@pixi/display'), require('@pixi/settings'), require('@pixi/constants'), require('@pixi/utils'), require('@pixi/ticker'), require('@pixi/sprite')) :
    typeof define === 'function' && define.amd ? define(['exports', '@pixi/loaders', '@pixi/core', '@pixi/math', '@pixi/display', '@pixi/settings', '@pixi/constants', '@pixi/utils', '@pixi/ticker', '@pixi/sprite'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.PIXI3D = {}, global.PIXI, global.PIXI, global.PIXI, global.PIXI, global.PIXI, global.PIXI, global.PIXI.utils, global.PIXI, global.PIXI));
})(this, (function (exports, loaders, PixiCore, math, display, settings, constants, utils, ticker, sprite) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var PixiCore__namespace = /*#__PURE__*/_interopNamespace(PixiCore);

    var Version530 = /** @class */ (function () {
        function Version530() {
        }
        Version530.prototype.installRendererPlugin = function (name, plugin) {
            PixiCore.Renderer.registerPlugin(name, plugin);
        };
        Version530.prototype.installLoaderPlugin = function (name, plugin) {
            loaders.Loader.registerPlugin(plugin);
        };
        Version530.prototype.render = function (renderer, object, renderTexture) {
            renderer.render(object, renderTexture);
        };
        return Version530;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || from);
    }

    var Version600 = /** @class */ (function (_super) {
        __extends(Version600, _super);
        function Version600() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Version600.prototype.render = function (renderer, object, renderTexture) {
            renderer.render(object, { renderTexture: renderTexture });
        };
        return Version600;
    }(Version530));

    /**
     * Used for not getting bundlers like webpack and rollup to report
     * warnings/errors about missing exports from PixiJS.
     */
    var CompatibilityAccess;
    (function (CompatibilityAccess) {
        function get(obj, key) {
            return obj[key];
        }
        CompatibilityAccess.get = get;
    })(CompatibilityAccess || (CompatibilityAccess = {}));

    var Version650 = /** @class */ (function (_super) {
        __extends(Version650, _super);
        function Version650() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Version650.prototype.installRendererPlugin = function (name, plugin) {
            plugin.extension = {
                type: CompatibilityAccess.get(PixiCore__namespace, "ExtensionType").RendererPlugin,
                name: name
            };
            CompatibilityAccess.get(PixiCore__namespace, "extensions").add(plugin);
        };
        Version650.prototype.installLoaderPlugin = function (name, plugin) {
            plugin.extension = {
                type: CompatibilityAccess.get(PixiCore__namespace, "ExtensionType").Loader,
                name: name
            };
            CompatibilityAccess.get(PixiCore__namespace, "extensions").add(plugin);
        };
        return Version650;
    }(Version600));

    var Compatibility = "extensions" in PixiCore__namespace ? new Version650() : "ArrayResource" in PixiCore__namespace ? new Version600() : new Version530();

    /**
     * glTF assets are JSON files plus supporting external data.
     */
    var glTFAsset = /** @class */ (function () {
        /**
         * Creates a new glTF asset using the specified JSON descriptor.
         * @param descriptor The JSON descriptor to create the asset from.
         * @param buffers The buffers used by this asset.
         * @param images The images used by this asset.
         */
        function glTFAsset(descriptor, buffers, images) {
            if (buffers === void 0) { buffers = []; }
            if (images === void 0) { images = []; }
            this.descriptor = descriptor;
            this.buffers = buffers;
            this.images = images;
        }
        /**
         * Loads a new glTF asset (including resources) using the specified JSON
         * descriptor.
         * @param descriptor The JSON descriptor to create the asset from.
         * @param loader The resource loader to use for external resources. The
         * loader can be empty when all resources in the descriptor is embedded.
         * @param cb Callback when all resources have been loaded.
         */
        glTFAsset.load = function (descriptor, loader, cb) {
            var asset = new glTFAsset(descriptor);
            loadBuffers(descriptor, function (buffers) {
                buffers.forEach(function (buffer) { return asset.buffers.push(buffer); });
                loadImages(descriptor, buffers, function (images) {
                    images.forEach(function (image) { return asset.images.push(image); });
                    cb && cb(asset);
                }, loader);
            }, loader);
            return asset;
        };
        /**
         * Returns a value indicating if the specified data buffer is a valid glTF.
         * @param buffer The buffer data to validate.
         */
        glTFAsset.isValidBuffer = function (buffer) {
            var header = new Uint32Array(buffer, 0, 3);
            if (header[0] === 0x46546C67 && header[1] === 2) {
                return true;
            }
            return false;
        };
        /**
         * Returns a value indicating if the specified uri is embedded.
         * @param uri The uri to check.
         */
        glTFAsset.isEmbeddedResource = function (uri) {
            return uri && uri.startsWith("data:");
        };
        /**
         * Creates a new glTF asset from binary (glb) buffer data.
         * @param data The binary buffer data to read from.
         * @param cb The function which gets called when the asset has been
         * created.
         */
        glTFAsset.fromBuffer = function (data, cb) {
            var chunks = [];
            var offset = 3 * 4;
            while (offset < data.byteLength) {
                var header = new Uint32Array(data, offset, 3);
                chunks.push({
                    length: header[0], type: header[1], offset: offset + 2 * 4
                });
                offset += header[0] + 2 * 4;
            }
            var json = new Uint8Array(data, chunks[0].offset, chunks[0].length);
            var descriptor = JSON.parse(new TextDecoder("utf-8").decode(json));
            var buffers = [];
            for (var i = 1; i < chunks.length; i++) {
                buffers.push(data.slice(chunks[i].offset, chunks[i].offset + chunks[i].length));
            }
            loadImages(descriptor, buffers, function (images) {
                cb(new glTFAsset(descriptor, buffers, images));
            });
        };
        return glTFAsset;
    }());
    function loadImages(descriptor, buffers, cb, loader) {
        var images = [];
        if (!descriptor.images || descriptor.images.length === 0) {
            return cb(images);
        }
        var embeddedImages = descriptor.images
            .filter(function (img) { return typeof img.bufferView !== "number" && glTFAsset.isEmbeddedResource(img.uri); })
            .map(function (img, index) { return index; });
        var externalImages = descriptor.images
            .filter(function (img) { return typeof img.bufferView !== "number" && !glTFAsset.isEmbeddedResource(img.uri); })
            .map(function (img, index) { return index; });
        var bufferImages = descriptor.images
            .filter(function (img) { return typeof img.bufferView === "number"; })
            .map(function (img, index) { return index; });
        for (var i = 0; i < embeddedImages.length; i++) {
            var index = embeddedImages[i];
            var image = descriptor.images[index];
            images[index] = PixiCore.Texture.from(image.uri);
        }
        if (bufferImages.length === 0 && externalImages.length === 0) {
            return cb(images);
        }
        if (externalImages.length > 0 && !loader) {
            throw new Error("PIXI3D: A resource loader is required when image is external.");
        }
        var loadExternalImage = function (image, index, cb) {
            loader === null || loader === void 0 ? void 0 : loader.load(image.uri, function (resource) {
                if (resource.texture) {
                    images[index] = resource.texture;
                    cb();
                }
            });
        };
        var loadBufferImage = function (image, index, cb) {
            loadImageFromBuffer(image, descriptor, buffers, function (image) {
                images[index] = image;
                cb();
            });
        };
        var externalImagesCount = externalImages.length;
        var bufferImagesCount = bufferImages.length;
        for (var i = 0; i < externalImages.length; i++) {
            var index = externalImages[i];
            var image = descriptor.images[index];
            loadExternalImage(image, index, function () {
                if (--externalImagesCount === 0 && bufferImagesCount === 0) {
                    cb(images);
                }
            });
        }
        for (var i = 0; i < bufferImages.length; i++) {
            var index = bufferImages[i];
            var image = descriptor.images[index];
            loadBufferImage(image, index, function () {
                if (--bufferImagesCount === 0 && externalImagesCount === 0) {
                    cb(images);
                }
            });
        }
    }
    function loadBuffers(descriptor, cb, loader) {
        var buffers = [];
        var embeddedBuffers = descriptor.buffers
            .filter(function (buffer) { return glTFAsset.isEmbeddedResource(buffer.uri); })
            .map(function (buffer, index) { return index; });
        for (var i = 0; i < embeddedBuffers.length; i++) {
            var index = embeddedBuffers[i];
            var buffer = descriptor.buffers[index];
            buffers[index] = createBufferFromBase64(buffer.uri);
        }
        var externalBuffers = descriptor.buffers
            .filter(function (buffer) { return !glTFAsset.isEmbeddedResource(buffer.uri); })
            .map(function (buffer, index) { return index; });
        if (externalBuffers.length === 0) {
            return cb(buffers);
        }
        if (!loader) {
            throw new Error("PIXI3D: A resource loader is required when buffer is not embedded.");
        }
        var loadExternalBuffer = function (uri, index, cb) {
            loader.load(uri, function (resource) {
                buffers[index] = resource.data;
                cb();
            });
        };
        var externalBuffersCount = externalBuffers.length;
        for (var i = 0; i < externalBuffers.length; i++) {
            var index = externalBuffers[i];
            var buffer = descriptor.buffers[index];
            loadExternalBuffer(buffer.uri, index, function () {
                if (--externalBuffersCount === 0) {
                    cb(buffers);
                }
            });
        }
    }
    function loadImageFromBuffer(image, descriptor, buffers, cb) {
        var view = descriptor.bufferViews[image.bufferView];
        var array = new Uint8Array(buffers[view.buffer], view.byteOffset, view.byteLength);
        var blob = new Blob([array], { "type": image.mimeType });
        var reader = new FileReader();
        reader.onload = function () {
            cb(PixiCore.Texture.from(reader.result));
        };
        reader.readAsDataURL(blob);
    }
    function createBufferFromBase64(value) {
        return Uint8Array.from(atob(value.split(",")[1]), function (c) { return c.charCodeAt(0); }).buffer;
    }

    var glTFLoader = {
        use: function (resource, next) {
            if (resource.extension !== "gltf") {
                return next();
            }
            var loader = this;
            glTFAsset.load(resource.data, new glTFExternalResourceLoader(loader, resource), function (gltf) {
                Object.assign(resource, { gltf: gltf });
                next();
            });
        },
        add: function () {
            loaders.LoaderResource.setExtensionXhrType("bin", loaders.LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
            loaders.LoaderResource.setExtensionXhrType("gltf", loaders.LoaderResource.XHR_RESPONSE_TYPE.JSON);
        }
    };
    Compatibility.installLoaderPlugin("gltf", glTFLoader);
    var glTFExternalResourceLoader = /** @class */ (function () {
        function glTFExternalResourceLoader(_loader, _resource) {
            this._loader = _loader;
            this._resource = _resource;
        }
        glTFExternalResourceLoader.prototype.load = function (uri, onComplete) {
            var url = this._resource.url.substring(0, this._resource.url.lastIndexOf("/") + 1) + uri;
            if (!this._loader.resources[url]) {
                // The resource does not exists and needs to be loaded.
                // @ts-ignore
                this._loader.add({ parentResource: this._resource, url: url, onComplete: onComplete });
            }
            else if (this._loader.resources[url].data) {
                // The resource already exists, just use that one.
                onComplete(this._loader.resources[url]);
            }
            else {
                // The resource is in queue to be loaded, wait for it.
                var binding_1 = this._loader.onProgress.add(function (_, resource) {
                    if (resource.url === url) {
                        onComplete(resource);
                        binding_1.detach();
                    }
                });
            }
        };
        return glTFExternalResourceLoader;
    }());

    var glTFBinaryLoader = {
        use: function (resource, next) {
            if (resource.extension !== "glb") {
                return next();
            }
            if (glTFAsset.isValidBuffer(resource.data)) {
                glTFAsset.fromBuffer(resource.data, function (gltf) {
                    Object.assign(resource, { gltf: gltf });
                    next();
                });
            }
            else {
                return next();
            }
        },
        add: function () {
            loaders.LoaderResource.setExtensionXhrType("glb", loaders.LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
        }
    };
    Compatibility.installLoaderPlugin("cubemap", glTFBinaryLoader);

    /**
     * Represents a point in 3D space.
     */
    var ObservablePoint3D = /** @class */ (function (_super) {
        __extends(ObservablePoint3D, _super);
        /**
         * Creates a new observable point.
         * @param cb The callback when changed.
         * @param scope The owner of callback.
         * @param x The position on the x axis.
         * @param y The position on the y axis.
         * @param z The position on the z axis.
         */
        function ObservablePoint3D(cb, scope, x, y, z) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            var _this = _super.call(this, cb, scope) || this;
            _this._array = new Float32Array(3);
            _this._array.set([x, y, z]);
            return _this;
        }
        Object.defineProperty(ObservablePoint3D.prototype, "array", {
            /** Array containing the x, y, z values. */
            get: function () {
                return this._array;
            },
            set: function (value) {
                this.setFrom(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ObservablePoint3D.prototype, "x", {
            /**
             * Position on the x axis relative to the local coordinates of the parent.
             */
            get: function () {
                return this._array[0];
            },
            set: function (value) {
                if (this._array[0] !== value) {
                    this._array[0] = value;
                    this.cb.call(this.scope);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ObservablePoint3D.prototype, "y", {
            /**
             * Position on the y axis relative to the local coordinates of the parent.
             */
            get: function () {
                return this._array[1];
            },
            set: function (value) {
                if (this._array[1] !== value) {
                    this._array[1] = value;
                    this.cb.call(this.scope);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ObservablePoint3D.prototype, "z", {
            /**
             * Position on the z axis relative to the local coordinates of the parent.
             */
            get: function () {
                return this._array[2];
            },
            set: function (value) {
                if (this._array[2] !== value) {
                    this._array[2] = value;
                    this.cb.call(this.scope);
                }
            },
            enumerable: false,
            configurable: true
        });
        ObservablePoint3D.prototype.clone = function (cb, scope) {
            if (cb === void 0) { cb = this.cb; }
            if (scope === void 0) { scope = this.scope; }
            return new ObservablePoint3D(cb, scope, this.x, this.y, this.z);
        };
        ObservablePoint3D.prototype.copyFrom = function (p) {
            if (this._array[0] !== p.x || this._array[1] !== p.y || this._array[2] !== p.z) {
                this._array[0] = p.x;
                this._array[1] = p.y;
                this._array[2] = p.z;
                this.cb.call(this.scope);
            }
            return this;
        };
        ObservablePoint3D.prototype.copyTo = function (p) {
            if (p instanceof ObservablePoint3D) {
                p.set(this.x, this.y, this.z);
            }
            return p;
        };
        ObservablePoint3D.prototype.equals = function (p) {
            return p.x === this.x && p.y === this.y && p.z === this.z;
        };
        /**
         * Sets the point to a new x, y and z position.
         * @param x The position on the x axis.
         * @param y The position on the y axis.
         * @param z The position on the z axis.
         */
        ObservablePoint3D.prototype.set = function (x, y, z) {
            if (y === void 0) { y = x; }
            if (z === void 0) { z = x; }
            if (this._array[0] !== x || this._array[1] !== y || this._array[2] !== z) {
                this._array[0] = x;
                this._array[1] = y;
                this._array[2] = z;
                this.cb.call(this.scope);
            }
            return this;
        };
        /**
         * Sets the point to a new x, y and z position.
         * @param array The array containing x, y and z, expected length is 3.
         */
        ObservablePoint3D.prototype.setFrom = function (array) {
            this.set(array[0], array[1], array[2]);
            return this;
        };
        return ObservablePoint3D;
    }(math.ObservablePoint));

    /**
     * Common utilities
     * @module glMatrix
     */
    // Configuration Constants
    var EPSILON$1 = 0.000001;
    var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
    if (!Math.hypot) Math.hypot = function () {
      var y = 0,
          i = arguments.length;

      while (i--) {
        y += arguments[i] * arguments[i];
      }

      return Math.sqrt(y);
    };

    /**
     * 3x3 Matrix
     * @module mat3
     */

    /**
     * Creates a new identity mat3
     *
     * @returns {mat3} a new 3x3 matrix
     */

    function create$4() {
      var out = new ARRAY_TYPE(9);

      if (ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
      }

      out[0] = 1;
      out[4] = 1;
      out[8] = 1;
      return out;
    }
    /**
     * Multiplies two mat3's
     *
     * @param {mat3} out the receiving matrix
     * @param {ReadonlyMat3} a the first operand
     * @param {ReadonlyMat3} b the second operand
     * @returns {mat3} out
     */

    function multiply$2(out, a, b) {
      var a00 = a[0],
          a01 = a[1],
          a02 = a[2];
      var a10 = a[3],
          a11 = a[4],
          a12 = a[5];
      var a20 = a[6],
          a21 = a[7],
          a22 = a[8];
      var b00 = b[0],
          b01 = b[1],
          b02 = b[2];
      var b10 = b[3],
          b11 = b[4],
          b12 = b[5];
      var b20 = b[6],
          b21 = b[7],
          b22 = b[8];
      out[0] = b00 * a00 + b01 * a10 + b02 * a20;
      out[1] = b00 * a01 + b01 * a11 + b02 * a21;
      out[2] = b00 * a02 + b01 * a12 + b02 * a22;
      out[3] = b10 * a00 + b11 * a10 + b12 * a20;
      out[4] = b10 * a01 + b11 * a11 + b12 * a21;
      out[5] = b10 * a02 + b11 * a12 + b12 * a22;
      out[6] = b20 * a00 + b21 * a10 + b22 * a20;
      out[7] = b20 * a01 + b21 * a11 + b22 * a21;
      out[8] = b20 * a02 + b21 * a12 + b22 * a22;
      return out;
    }

    /**
     * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
     * @module mat4
     */

    /**
     * Creates a new identity mat4
     *
     * @returns {mat4} a new 4x4 matrix
     */

    function create$3() {
      var out = new ARRAY_TYPE(16);

      if (ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
      }

      out[0] = 1;
      out[5] = 1;
      out[10] = 1;
      out[15] = 1;
      return out;
    }
    /**
     * Copy the values from one mat4 to another
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the source matrix
     * @returns {mat4} out
     */

    function copy$1(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
      return out;
    }
    /**
     * Set a mat4 to the identity matrix
     *
     * @param {mat4} out the receiving matrix
     * @returns {mat4} out
     */

    function identity(out) {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = 1;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    }
    /**
     * Transpose the values of a mat4
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the source matrix
     * @returns {mat4} out
     */

    function transpose(out, a) {
      // If we are transposing ourselves we can skip a few steps but have to cache some values
      if (out === a) {
        var a01 = a[1],
            a02 = a[2],
            a03 = a[3];
        var a12 = a[6],
            a13 = a[7];
        var a23 = a[11];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
      } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
      }

      return out;
    }
    /**
     * Inverts a mat4
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the source matrix
     * @returns {mat4} out
     */

    function invert(out, a) {
      var a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7];
      var a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11];
      var a30 = a[12],
          a31 = a[13],
          a32 = a[14],
          a33 = a[15];
      var b00 = a00 * a11 - a01 * a10;
      var b01 = a00 * a12 - a02 * a10;
      var b02 = a00 * a13 - a03 * a10;
      var b03 = a01 * a12 - a02 * a11;
      var b04 = a01 * a13 - a03 * a11;
      var b05 = a02 * a13 - a03 * a12;
      var b06 = a20 * a31 - a21 * a30;
      var b07 = a20 * a32 - a22 * a30;
      var b08 = a20 * a33 - a23 * a30;
      var b09 = a21 * a32 - a22 * a31;
      var b10 = a21 * a33 - a23 * a31;
      var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

      var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

      if (!det) {
        return null;
      }

      det = 1.0 / det;
      out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
      out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
      out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
      out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
      out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
      out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
      out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
      out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
      out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
    }
    /**
     * Multiplies two mat4s
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the first operand
     * @param {ReadonlyMat4} b the second operand
     * @returns {mat4} out
     */

    function multiply$1(out, a, b) {
      var a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7];
      var a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11];
      var a30 = a[12],
          a31 = a[13],
          a32 = a[14],
          a33 = a[15]; // Cache only the current line of the second matrix

      var b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return out;
    }
    /**
     * Translate a mat4 by the given vector
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the matrix to translate
     * @param {ReadonlyVec3} v vector to translate by
     * @returns {mat4} out
     */

    function translate(out, a, v) {
      var x = v[0],
          y = v[1],
          z = v[2];
      var a00, a01, a02, a03;
      var a10, a11, a12, a13;
      var a20, a21, a22, a23;

      if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
      } else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
      }

      return out;
    }
    /**
     * Scales the mat4 by the dimensions in the given vec3 not using vectorization
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the matrix to scale
     * @param {ReadonlyVec3} v the vec3 to scale the matrix by
     * @returns {mat4} out
     **/

    function scale$1(out, a, v) {
      var x = v[0],
          y = v[1],
          z = v[2];
      out[0] = a[0] * x;
      out[1] = a[1] * x;
      out[2] = a[2] * x;
      out[3] = a[3] * x;
      out[4] = a[4] * y;
      out[5] = a[5] * y;
      out[6] = a[6] * y;
      out[7] = a[7] * y;
      out[8] = a[8] * z;
      out[9] = a[9] * z;
      out[10] = a[10] * z;
      out[11] = a[11] * z;
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
      return out;
    }
    /**
     * Rotates a mat4 by the given angle around the given axis
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @param {ReadonlyVec3} axis the axis to rotate around
     * @returns {mat4} out
     */

    function rotate(out, a, rad, axis) {
      var x = axis[0],
          y = axis[1],
          z = axis[2];
      var len = Math.hypot(x, y, z);
      var s, c, t;
      var a00, a01, a02, a03;
      var a10, a11, a12, a13;
      var a20, a21, a22, a23;
      var b00, b01, b02;
      var b10, b11, b12;
      var b20, b21, b22;

      if (len < EPSILON$1) {
        return null;
      }

      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(rad);
      c = Math.cos(rad);
      t = 1 - c;
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11]; // Construct the elements of the rotation matrix

      b00 = x * x * t + c;
      b01 = y * x * t + z * s;
      b02 = z * x * t - y * s;
      b10 = x * y * t - z * s;
      b11 = y * y * t + c;
      b12 = z * y * t + x * s;
      b20 = x * z * t + y * s;
      b21 = y * z * t - x * s;
      b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

      out[0] = a00 * b00 + a10 * b01 + a20 * b02;
      out[1] = a01 * b00 + a11 * b01 + a21 * b02;
      out[2] = a02 * b00 + a12 * b01 + a22 * b02;
      out[3] = a03 * b00 + a13 * b01 + a23 * b02;
      out[4] = a00 * b10 + a10 * b11 + a20 * b12;
      out[5] = a01 * b10 + a11 * b11 + a21 * b12;
      out[6] = a02 * b10 + a12 * b11 + a22 * b12;
      out[7] = a03 * b10 + a13 * b11 + a23 * b12;
      out[8] = a00 * b20 + a10 * b21 + a20 * b22;
      out[9] = a01 * b20 + a11 * b21 + a21 * b22;
      out[10] = a02 * b20 + a12 * b21 + a22 * b22;
      out[11] = a03 * b20 + a13 * b21 + a23 * b22;

      if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
      }

      return out;
    }
    /**
     * Rotates a matrix by the given angle around the X axis
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */

    function rotateX$1(out, a, rad) {
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      var a10 = a[4];
      var a11 = a[5];
      var a12 = a[6];
      var a13 = a[7];
      var a20 = a[8];
      var a21 = a[9];
      var a22 = a[10];
      var a23 = a[11];

      if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
      } // Perform axis-specific matrix multiplication


      out[4] = a10 * c + a20 * s;
      out[5] = a11 * c + a21 * s;
      out[6] = a12 * c + a22 * s;
      out[7] = a13 * c + a23 * s;
      out[8] = a20 * c - a10 * s;
      out[9] = a21 * c - a11 * s;
      out[10] = a22 * c - a12 * s;
      out[11] = a23 * c - a13 * s;
      return out;
    }
    /**
     * Rotates a matrix by the given angle around the Y axis
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */

    function rotateY$1(out, a, rad) {
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a03 = a[3];
      var a20 = a[8];
      var a21 = a[9];
      var a22 = a[10];
      var a23 = a[11];

      if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
      } // Perform axis-specific matrix multiplication


      out[0] = a00 * c - a20 * s;
      out[1] = a01 * c - a21 * s;
      out[2] = a02 * c - a22 * s;
      out[3] = a03 * c - a23 * s;
      out[8] = a00 * s + a20 * c;
      out[9] = a01 * s + a21 * c;
      out[10] = a02 * s + a22 * c;
      out[11] = a03 * s + a23 * c;
      return out;
    }
    /**
     * Rotates a matrix by the given angle around the Z axis
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */

    function rotateZ$1(out, a, rad) {
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a03 = a[3];
      var a10 = a[4];
      var a11 = a[5];
      var a12 = a[6];
      var a13 = a[7];

      if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
      } // Perform axis-specific matrix multiplication


      out[0] = a00 * c + a10 * s;
      out[1] = a01 * c + a11 * s;
      out[2] = a02 * c + a12 * s;
      out[3] = a03 * c + a13 * s;
      out[4] = a10 * c - a00 * s;
      out[5] = a11 * c - a01 * s;
      out[6] = a12 * c - a02 * s;
      out[7] = a13 * c - a03 * s;
      return out;
    }
    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, dest, vec);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {ReadonlyVec3} v Translation vector
     * @returns {mat4} out
     */

    function fromTranslation(out, v) {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = 1;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = v[0];
      out[13] = v[1];
      out[14] = v[2];
      out[15] = 1;
      return out;
    }
    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.scale(dest, dest, vec);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {ReadonlyVec3} v Scaling vector
     * @returns {mat4} out
     */

    function fromScaling(out, v) {
      out[0] = v[0];
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = v[1];
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = v[2];
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    }
    /**
     * Creates a matrix from a given angle around a given axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotate(dest, dest, rad, axis);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @param {ReadonlyVec3} axis the axis to rotate around
     * @returns {mat4} out
     */

    function fromRotation(out, rad, axis) {
      var x = axis[0],
          y = axis[1],
          z = axis[2];
      var len = Math.hypot(x, y, z);
      var s, c, t;

      if (len < EPSILON$1) {
        return null;
      }

      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(rad);
      c = Math.cos(rad);
      t = 1 - c; // Perform rotation-specific matrix multiplication

      out[0] = x * x * t + c;
      out[1] = y * x * t + z * s;
      out[2] = z * x * t - y * s;
      out[3] = 0;
      out[4] = x * y * t - z * s;
      out[5] = y * y * t + c;
      out[6] = z * y * t + x * s;
      out[7] = 0;
      out[8] = x * z * t + y * s;
      out[9] = y * z * t - x * s;
      out[10] = z * z * t + c;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    }
    /**
     * Returns the translation vector component of a transformation
     *  matrix. If a matrix is built with fromRotationTranslation,
     *  the returned vector will be the same as the translation vector
     *  originally supplied.
     * @param  {vec3} out Vector to receive translation component
     * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
     * @return {vec3} out
     */

    function getTranslation(out, mat) {
      out[0] = mat[12];
      out[1] = mat[13];
      out[2] = mat[14];
      return out;
    }
    /**
     * Returns the scaling factor component of a transformation
     *  matrix. If a matrix is built with fromRotationTranslationScale
     *  with a normalized Quaternion paramter, the returned vector will be
     *  the same as the scaling vector
     *  originally supplied.
     * @param  {vec3} out Vector to receive scaling factor component
     * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
     * @return {vec3} out
     */

    function getScaling(out, mat) {
      var m11 = mat[0];
      var m12 = mat[1];
      var m13 = mat[2];
      var m21 = mat[4];
      var m22 = mat[5];
      var m23 = mat[6];
      var m31 = mat[8];
      var m32 = mat[9];
      var m33 = mat[10];
      out[0] = Math.hypot(m11, m12, m13);
      out[1] = Math.hypot(m21, m22, m23);
      out[2] = Math.hypot(m31, m32, m33);
      return out;
    }
    /**
     * Returns a quaternion representing the rotational component
     *  of a transformation matrix. If a matrix is built with
     *  fromRotationTranslation, the returned quaternion will be the
     *  same as the quaternion originally supplied.
     * @param {quat} out Quaternion to receive the rotation component
     * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
     * @return {quat} out
     */

    function getRotation(out, mat) {
      var scaling = new ARRAY_TYPE(3);
      getScaling(scaling, mat);
      var is1 = 1 / scaling[0];
      var is2 = 1 / scaling[1];
      var is3 = 1 / scaling[2];
      var sm11 = mat[0] * is1;
      var sm12 = mat[1] * is2;
      var sm13 = mat[2] * is3;
      var sm21 = mat[4] * is1;
      var sm22 = mat[5] * is2;
      var sm23 = mat[6] * is3;
      var sm31 = mat[8] * is1;
      var sm32 = mat[9] * is2;
      var sm33 = mat[10] * is3;
      var trace = sm11 + sm22 + sm33;
      var S = 0;

      if (trace > 0) {
        S = Math.sqrt(trace + 1.0) * 2;
        out[3] = 0.25 * S;
        out[0] = (sm23 - sm32) / S;
        out[1] = (sm31 - sm13) / S;
        out[2] = (sm12 - sm21) / S;
      } else if (sm11 > sm22 && sm11 > sm33) {
        S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
        out[3] = (sm23 - sm32) / S;
        out[0] = 0.25 * S;
        out[1] = (sm12 + sm21) / S;
        out[2] = (sm31 + sm13) / S;
      } else if (sm22 > sm33) {
        S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
        out[3] = (sm31 - sm13) / S;
        out[0] = (sm12 + sm21) / S;
        out[1] = 0.25 * S;
        out[2] = (sm23 + sm32) / S;
      } else {
        S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
        out[3] = (sm12 - sm21) / S;
        out[0] = (sm31 + sm13) / S;
        out[1] = (sm23 + sm32) / S;
        out[2] = 0.25 * S;
      }

      return out;
    }
    /**
     * Creates a matrix from a quaternion rotation, vector translation and vector scale
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     let quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *     mat4.scale(dest, scale)
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {quat4} q Rotation quaternion
     * @param {ReadonlyVec3} v Translation vector
     * @param {ReadonlyVec3} s Scaling vector
     * @returns {mat4} out
     */

    function fromRotationTranslationScale(out, q, v, s) {
      // Quaternion math
      var x = q[0],
          y = q[1],
          z = q[2],
          w = q[3];
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var xy = x * y2;
      var xz = x * z2;
      var yy = y * y2;
      var yz = y * z2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      var sx = s[0];
      var sy = s[1];
      var sz = s[2];
      out[0] = (1 - (yy + zz)) * sx;
      out[1] = (xy + wz) * sx;
      out[2] = (xz - wy) * sx;
      out[3] = 0;
      out[4] = (xy - wz) * sy;
      out[5] = (1 - (xx + zz)) * sy;
      out[6] = (yz + wx) * sy;
      out[7] = 0;
      out[8] = (xz + wy) * sz;
      out[9] = (yz - wx) * sz;
      out[10] = (1 - (xx + yy)) * sz;
      out[11] = 0;
      out[12] = v[0];
      out[13] = v[1];
      out[14] = v[2];
      out[15] = 1;
      return out;
    }
    /**
     * Calculates a 4x4 matrix from the given quaternion
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {ReadonlyQuat} q Quaternion to create matrix from
     *
     * @returns {mat4} out
     */

    function fromQuat(out, q) {
      var x = q[0],
          y = q[1],
          z = q[2],
          w = q[3];
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var yx = y * x2;
      var yy = y * y2;
      var zx = z * x2;
      var zy = z * y2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      out[0] = 1 - yy - zz;
      out[1] = yx + wz;
      out[2] = zx - wy;
      out[3] = 0;
      out[4] = yx - wz;
      out[5] = 1 - xx - zz;
      out[6] = zy + wx;
      out[7] = 0;
      out[8] = zx + wy;
      out[9] = zy - wx;
      out[10] = 1 - xx - yy;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    }
    /**
     * Generates a perspective projection matrix with the given bounds.
     * Passing null/undefined/no value for far will generate infinite projection matrix.
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {number} fovy Vertical field of view in radians
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum, can be null or Infinity
     * @returns {mat4} out
     */

    function perspective(out, fovy, aspect, near, far) {
      var f = 1.0 / Math.tan(fovy / 2),
          nf;
      out[0] = f / aspect;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = f;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = -1;
      out[12] = 0;
      out[13] = 0;
      out[15] = 0;

      if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
      } else {
        out[10] = -1;
        out[14] = -2 * near;
      }

      return out;
    }
    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {mat4} out
     */

    function ortho(out, left, right, bottom, top, near, far) {
      var lr = 1 / (left - right);
      var bt = 1 / (bottom - top);
      var nf = 1 / (near - far);
      out[0] = -2 * lr;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = -2 * bt;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 2 * nf;
      out[11] = 0;
      out[12] = (left + right) * lr;
      out[13] = (top + bottom) * bt;
      out[14] = (far + near) * nf;
      out[15] = 1;
      return out;
    }
    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis.
     * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {ReadonlyVec3} eye Position of the viewer
     * @param {ReadonlyVec3} center Point the viewer is looking at
     * @param {ReadonlyVec3} up vec3 pointing up
     * @returns {mat4} out
     */

    function lookAt(out, eye, center, up) {
      var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
      var eyex = eye[0];
      var eyey = eye[1];
      var eyez = eye[2];
      var upx = up[0];
      var upy = up[1];
      var upz = up[2];
      var centerx = center[0];
      var centery = center[1];
      var centerz = center[2];

      if (Math.abs(eyex - centerx) < EPSILON$1 && Math.abs(eyey - centery) < EPSILON$1 && Math.abs(eyez - centerz) < EPSILON$1) {
        return identity(out);
      }

      z0 = eyex - centerx;
      z1 = eyey - centery;
      z2 = eyez - centerz;
      len = 1 / Math.hypot(z0, z1, z2);
      z0 *= len;
      z1 *= len;
      z2 *= len;
      x0 = upy * z2 - upz * z1;
      x1 = upz * z0 - upx * z2;
      x2 = upx * z1 - upy * z0;
      len = Math.hypot(x0, x1, x2);

      if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
      } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
      }

      y0 = z1 * x2 - z2 * x1;
      y1 = z2 * x0 - z0 * x2;
      y2 = z0 * x1 - z1 * x0;
      len = Math.hypot(y0, y1, y2);

      if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
      } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
      }

      out[0] = x0;
      out[1] = y0;
      out[2] = z0;
      out[3] = 0;
      out[4] = x1;
      out[5] = y1;
      out[6] = z1;
      out[7] = 0;
      out[8] = x2;
      out[9] = y2;
      out[10] = z2;
      out[11] = 0;
      out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
      out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
      out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
      out[15] = 1;
      return out;
    }
    /**
     * Generates a matrix that makes something look at something else.
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {ReadonlyVec3} eye Position of the viewer
     * @param {ReadonlyVec3} center Point the viewer is looking at
     * @param {ReadonlyVec3} up vec3 pointing up
     * @returns {mat4} out
     */

    function targetTo(out, eye, target, up) {
      var eyex = eye[0],
          eyey = eye[1],
          eyez = eye[2],
          upx = up[0],
          upy = up[1],
          upz = up[2];
      var z0 = eyex - target[0],
          z1 = eyey - target[1],
          z2 = eyez - target[2];
      var len = z0 * z0 + z1 * z1 + z2 * z2;

      if (len > 0) {
        len = 1 / Math.sqrt(len);
        z0 *= len;
        z1 *= len;
        z2 *= len;
      }

      var x0 = upy * z2 - upz * z1,
          x1 = upz * z0 - upx * z2,
          x2 = upx * z1 - upy * z0;
      len = x0 * x0 + x1 * x1 + x2 * x2;

      if (len > 0) {
        len = 1 / Math.sqrt(len);
        x0 *= len;
        x1 *= len;
        x2 *= len;
      }

      out[0] = x0;
      out[1] = x1;
      out[2] = x2;
      out[3] = 0;
      out[4] = z1 * x2 - z2 * x1;
      out[5] = z2 * x0 - z0 * x2;
      out[6] = z0 * x1 - z1 * x0;
      out[7] = 0;
      out[8] = z0;
      out[9] = z1;
      out[10] = z2;
      out[11] = 0;
      out[12] = eyex;
      out[13] = eyey;
      out[14] = eyez;
      out[15] = 1;
      return out;
    }

    /**
     * 3 Dimensional Vector
     * @module vec3
     */

    /**
     * Creates a new, empty vec3
     *
     * @returns {vec3} a new 3D vector
     */

    function create$2() {
      var out = new ARRAY_TYPE(3);

      if (ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
      }

      return out;
    }
    /**
     * Calculates the length of a vec3
     *
     * @param {ReadonlyVec3} a vector to calculate length of
     * @returns {Number} length of a
     */

    function length(a) {
      var x = a[0];
      var y = a[1];
      var z = a[2];
      return Math.hypot(x, y, z);
    }
    /**
     * Creates a new vec3 initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @returns {vec3} a new 3D vector
     */

    function fromValues$2(x, y, z) {
      var out = new ARRAY_TYPE(3);
      out[0] = x;
      out[1] = y;
      out[2] = z;
      return out;
    }
    /**
     * Copy the values from one vec3 to another
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec3} a the source vector
     * @returns {vec3} out
     */

    function copy(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      return out;
    }
    /**
     * Set the components of a vec3 to the given values
     *
     * @param {vec3} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @returns {vec3} out
     */

    function set$2(out, x, y, z) {
      out[0] = x;
      out[1] = y;
      out[2] = z;
      return out;
    }
    /**
     * Adds two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec3} a the first operand
     * @param {ReadonlyVec3} b the second operand
     * @returns {vec3} out
     */

    function add(out, a, b) {
      out[0] = a[0] + b[0];
      out[1] = a[1] + b[1];
      out[2] = a[2] + b[2];
      return out;
    }
    /**
     * Subtracts vector b from vector a
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec3} a the first operand
     * @param {ReadonlyVec3} b the second operand
     * @returns {vec3} out
     */

    function subtract(out, a, b) {
      out[0] = a[0] - b[0];
      out[1] = a[1] - b[1];
      out[2] = a[2] - b[2];
      return out;
    }
    /**
     * Multiplies two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec3} a the first operand
     * @param {ReadonlyVec3} b the second operand
     * @returns {vec3} out
     */

    function multiply(out, a, b) {
      out[0] = a[0] * b[0];
      out[1] = a[1] * b[1];
      out[2] = a[2] * b[2];
      return out;
    }
    /**
     * Scales a vec3 by a scalar number
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec3} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {vec3} out
     */

    function scale(out, a, b) {
      out[0] = a[0] * b;
      out[1] = a[1] * b;
      out[2] = a[2] * b;
      return out;
    }
    /**
     * Calculates the euclidian distance between two vec3's
     *
     * @param {ReadonlyVec3} a the first operand
     * @param {ReadonlyVec3} b the second operand
     * @returns {Number} distance between a and b
     */

    function distance(a, b) {
      var x = b[0] - a[0];
      var y = b[1] - a[1];
      var z = b[2] - a[2];
      return Math.hypot(x, y, z);
    }
    /**
     * Calculates the squared euclidian distance between two vec3's
     *
     * @param {ReadonlyVec3} a the first operand
     * @param {ReadonlyVec3} b the second operand
     * @returns {Number} squared distance between a and b
     */

    function squaredDistance(a, b) {
      var x = b[0] - a[0];
      var y = b[1] - a[1];
      var z = b[2] - a[2];
      return x * x + y * y + z * z;
    }
    /**
     * Calculates the squared length of a vec3
     *
     * @param {ReadonlyVec3} a vector to calculate squared length of
     * @returns {Number} squared length of a
     */

    function squaredLength(a) {
      var x = a[0];
      var y = a[1];
      var z = a[2];
      return x * x + y * y + z * z;
    }
    /**
     * Negates the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec3} a vector to negate
     * @returns {vec3} out
     */

    function negate(out, a) {
      out[0] = -a[0];
      out[1] = -a[1];
      out[2] = -a[2];
      return out;
    }
    /**
     * Returns the inverse of the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec3} a vector to invert
     * @returns {vec3} out
     */

    function inverse(out, a) {
      out[0] = 1.0 / a[0];
      out[1] = 1.0 / a[1];
      out[2] = 1.0 / a[2];
      return out;
    }
    /**
     * Normalize a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec3} a vector to normalize
     * @returns {vec3} out
     */

    function normalize$2(out, a) {
      var x = a[0];
      var y = a[1];
      var z = a[2];
      var len = x * x + y * y + z * z;

      if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
      }

      out[0] = a[0] * len;
      out[1] = a[1] * len;
      out[2] = a[2] * len;
      return out;
    }
    /**
     * Calculates the dot product of two vec3's
     *
     * @param {ReadonlyVec3} a the first operand
     * @param {ReadonlyVec3} b the second operand
     * @returns {Number} dot product of a and b
     */

    function dot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    /**
     * Computes the cross product of two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec3} a the first operand
     * @param {ReadonlyVec3} b the second operand
     * @returns {vec3} out
     */

    function cross(out, a, b) {
      var ax = a[0],
          ay = a[1],
          az = a[2];
      var bx = b[0],
          by = b[1],
          bz = b[2];
      out[0] = ay * bz - az * by;
      out[1] = az * bx - ax * bz;
      out[2] = ax * by - ay * bx;
      return out;
    }
    /**
     * Performs a linear interpolation between two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec3} a the first operand
     * @param {ReadonlyVec3} b the second operand
     * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
     * @returns {vec3} out
     */

    function lerp(out, a, b, t) {
      var ax = a[0];
      var ay = a[1];
      var az = a[2];
      out[0] = ax + t * (b[0] - ax);
      out[1] = ay + t * (b[1] - ay);
      out[2] = az + t * (b[2] - az);
      return out;
    }
    /**
     * Transforms the vec3 with a mat4.
     * 4th vector component is implicitly '1'
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec3} a the vector to transform
     * @param {ReadonlyMat4} m matrix to transform with
     * @returns {vec3} out
     */

    function transformMat4$1(out, a, m) {
      var x = a[0],
          y = a[1],
          z = a[2];
      var w = m[3] * x + m[7] * y + m[11] * z + m[15];
      w = w || 1.0;
      out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
      out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
      out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
      return out;
    }
    /**
     * Transforms the vec3 with a quat
     * Can also be used for dual quaternions. (Multiply it with the real part)
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec3} a the vector to transform
     * @param {ReadonlyQuat} q quaternion to transform with
     * @returns {vec3} out
     */

    function transformQuat(out, a, q) {
      // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
      var qx = q[0],
          qy = q[1],
          qz = q[2],
          qw = q[3];
      var x = a[0],
          y = a[1],
          z = a[2]; // var qvec = [qx, qy, qz];
      // var uv = vec3.cross([], qvec, a);

      var uvx = qy * z - qz * y,
          uvy = qz * x - qx * z,
          uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

      var uuvx = qy * uvz - qz * uvy,
          uuvy = qz * uvx - qx * uvz,
          uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

      var w2 = qw * 2;
      uvx *= w2;
      uvy *= w2;
      uvz *= w2; // vec3.scale(uuv, uuv, 2);

      uuvx *= 2;
      uuvy *= 2;
      uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

      out[0] = x + uvx + uuvx;
      out[1] = y + uvy + uuvy;
      out[2] = z + uvz + uuvz;
      return out;
    }
    /**
     * Alias for {@link vec3.length}
     * @function
     */

    var len = length;
    /**
     * Perform some operation over an array of vec3s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */

    (function () {
      var vec = create$2();
      return function (a, stride, offset, count, fn, arg) {
        var i, l;

        if (!stride) {
          stride = 3;
        }

        if (!offset) {
          offset = 0;
        }

        if (count) {
          l = Math.min(count * stride + offset, a.length);
        } else {
          l = a.length;
        }

        for (i = offset; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          vec[2] = a[i + 2];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
          a[i + 2] = vec[2];
        }

        return a;
      };
    })();

    /**
     * 4 Dimensional Vector
     * @module vec4
     */

    /**
     * Creates a new, empty vec4
     *
     * @returns {vec4} a new 4D vector
     */

    function create$1() {
      var out = new ARRAY_TYPE(4);

      if (ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
      }

      return out;
    }
    /**
     * Creates a new vec4 initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {vec4} a new 4D vector
     */

    function fromValues$1(x, y, z, w) {
      var out = new ARRAY_TYPE(4);
      out[0] = x;
      out[1] = y;
      out[2] = z;
      out[3] = w;
      return out;
    }
    /**
     * Set the components of a vec4 to the given values
     *
     * @param {vec4} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {vec4} out
     */

    function set$1(out, x, y, z, w) {
      out[0] = x;
      out[1] = y;
      out[2] = z;
      out[3] = w;
      return out;
    }
    /**
     * Normalize a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {ReadonlyVec4} a vector to normalize
     * @returns {vec4} out
     */

    function normalize$1(out, a) {
      var x = a[0];
      var y = a[1];
      var z = a[2];
      var w = a[3];
      var len = x * x + y * y + z * z + w * w;

      if (len > 0) {
        len = 1 / Math.sqrt(len);
      }

      out[0] = x * len;
      out[1] = y * len;
      out[2] = z * len;
      out[3] = w * len;
      return out;
    }
    /**
     * Transforms the vec4 with a mat4.
     *
     * @param {vec4} out the receiving vector
     * @param {ReadonlyVec4} a the vector to transform
     * @param {ReadonlyMat4} m matrix to transform with
     * @returns {vec4} out
     */

    function transformMat4(out, a, m) {
      var x = a[0],
          y = a[1],
          z = a[2],
          w = a[3];
      out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
      out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
      out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
      out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
      return out;
    }
    /**
     * Perform some operation over an array of vec4s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */

    (function () {
      var vec = create$1();
      return function (a, stride, offset, count, fn, arg) {
        var i, l;

        if (!stride) {
          stride = 4;
        }

        if (!offset) {
          offset = 0;
        }

        if (count) {
          l = Math.min(count * stride + offset, a.length);
        } else {
          l = a.length;
        }

        for (i = offset; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          vec[2] = a[i + 2];
          vec[3] = a[i + 3];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
          a[i + 2] = vec[2];
          a[i + 3] = vec[3];
        }

        return a;
      };
    })();

    /**
     * Quaternion
     * @module quat
     */

    /**
     * Creates a new identity quat
     *
     * @returns {quat} a new quaternion
     */

    function create() {
      var out = new ARRAY_TYPE(4);

      if (ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
      }

      out[3] = 1;
      return out;
    }
    /**
     * Sets a quat from the given angle and rotation axis,
     * then returns it.
     *
     * @param {quat} out the receiving quaternion
     * @param {ReadonlyVec3} axis the axis around which to rotate
     * @param {Number} rad the angle in radians
     * @returns {quat} out
     **/

    function setAxisAngle(out, axis, rad) {
      rad = rad * 0.5;
      var s = Math.sin(rad);
      out[0] = s * axis[0];
      out[1] = s * axis[1];
      out[2] = s * axis[2];
      out[3] = Math.cos(rad);
      return out;
    }
    /**
     * Rotates a quaternion by the given angle about the X axis
     *
     * @param {quat} out quat receiving operation result
     * @param {ReadonlyQuat} a quat to rotate
     * @param {number} rad angle (in radians) to rotate
     * @returns {quat} out
     */

    function rotateX(out, a, rad) {
      rad *= 0.5;
      var ax = a[0],
          ay = a[1],
          az = a[2],
          aw = a[3];
      var bx = Math.sin(rad),
          bw = Math.cos(rad);
      out[0] = ax * bw + aw * bx;
      out[1] = ay * bw + az * bx;
      out[2] = az * bw - ay * bx;
      out[3] = aw * bw - ax * bx;
      return out;
    }
    /**
     * Rotates a quaternion by the given angle about the Y axis
     *
     * @param {quat} out quat receiving operation result
     * @param {ReadonlyQuat} a quat to rotate
     * @param {number} rad angle (in radians) to rotate
     * @returns {quat} out
     */

    function rotateY(out, a, rad) {
      rad *= 0.5;
      var ax = a[0],
          ay = a[1],
          az = a[2],
          aw = a[3];
      var by = Math.sin(rad),
          bw = Math.cos(rad);
      out[0] = ax * bw - az * by;
      out[1] = ay * bw + aw * by;
      out[2] = az * bw + ax * by;
      out[3] = aw * bw - ay * by;
      return out;
    }
    /**
     * Rotates a quaternion by the given angle about the Z axis
     *
     * @param {quat} out quat receiving operation result
     * @param {ReadonlyQuat} a quat to rotate
     * @param {number} rad angle (in radians) to rotate
     * @returns {quat} out
     */

    function rotateZ(out, a, rad) {
      rad *= 0.5;
      var ax = a[0],
          ay = a[1],
          az = a[2],
          aw = a[3];
      var bz = Math.sin(rad),
          bw = Math.cos(rad);
      out[0] = ax * bw + ay * bz;
      out[1] = ay * bw - ax * bz;
      out[2] = az * bw + aw * bz;
      out[3] = aw * bw - az * bz;
      return out;
    }
    /**
     * Performs a spherical linear interpolation between two quat
     *
     * @param {quat} out the receiving quaternion
     * @param {ReadonlyQuat} a the first operand
     * @param {ReadonlyQuat} b the second operand
     * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
     * @returns {quat} out
     */

    function slerp(out, a, b, t) {
      // benchmarks:
      //    http://jsperf.com/quaternion-slerp-implementations
      var ax = a[0],
          ay = a[1],
          az = a[2],
          aw = a[3];
      var bx = b[0],
          by = b[1],
          bz = b[2],
          bw = b[3];
      var omega, cosom, sinom, scale0, scale1; // calc cosine

      cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

      if (cosom < 0.0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
      } // calculate coefficients


      if (1.0 - cosom > EPSILON$1) {
        // standard case (slerp)
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
      } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
      } // calculate final values


      out[0] = scale0 * ax + scale1 * bx;
      out[1] = scale0 * ay + scale1 * by;
      out[2] = scale0 * az + scale1 * bz;
      out[3] = scale0 * aw + scale1 * bw;
      return out;
    }
    /**
     * Calculates the conjugate of a quat
     * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
     *
     * @param {quat} out the receiving quaternion
     * @param {ReadonlyQuat} a quat to calculate conjugate of
     * @returns {quat} out
     */

    function conjugate(out, a) {
      out[0] = -a[0];
      out[1] = -a[1];
      out[2] = -a[2];
      out[3] = a[3];
      return out;
    }
    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     *
     * NOTE: The resultant quaternion is not normalized, so you should be sure
     * to renormalize the quaternion yourself where necessary.
     *
     * @param {quat} out the receiving quaternion
     * @param {ReadonlyMat3} m rotation matrix
     * @returns {quat} out
     * @function
     */

    function fromMat3(out, m) {
      // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
      // article "Quaternion Calculus and Fast Animation".
      var fTrace = m[0] + m[4] + m[8];
      var fRoot;

      if (fTrace > 0.0) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0); // 2w

        out[3] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot; // 1/(4w)

        out[0] = (m[5] - m[7]) * fRoot;
        out[1] = (m[6] - m[2]) * fRoot;
        out[2] = (m[1] - m[3]) * fRoot;
      } else {
        // |w| <= 1/2
        var i = 0;
        if (m[4] > m[0]) i = 1;
        if (m[8] > m[i * 3 + i]) i = 2;
        var j = (i + 1) % 3;
        var k = (i + 2) % 3;
        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
      }

      return out;
    }
    /**
     * Creates a quaternion from the given euler angle x, y, z.
     *
     * @param {quat} out the receiving quaternion
     * @param {x} Angle to rotate around X axis in degrees.
     * @param {y} Angle to rotate around Y axis in degrees.
     * @param {z} Angle to rotate around Z axis in degrees.
     * @returns {quat} out
     * @function
     */

    function fromEuler(out, x, y, z) {
      var halfToRad = 0.5 * Math.PI / 180.0;
      x *= halfToRad;
      y *= halfToRad;
      z *= halfToRad;
      var sx = Math.sin(x);
      var cx = Math.cos(x);
      var sy = Math.sin(y);
      var cy = Math.cos(y);
      var sz = Math.sin(z);
      var cz = Math.cos(z);
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      return out;
    }
    /**
     * Creates a new quat initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {quat} a new quaternion
     * @function
     */

    var fromValues = fromValues$1;
    /**
     * Set the components of a quat to the given values
     *
     * @param {quat} out the receiving quaternion
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {quat} out
     * @function
     */

    var set = set$1;
    /**
     * Normalize a quat
     *
     * @param {quat} out the receiving quaternion
     * @param {ReadonlyQuat} a quaternion to normalize
     * @returns {quat} out
     * @function
     */

    var normalize = normalize$1;
    /**
     * Sets a quaternion to represent the shortest rotation from one
     * vector to another.
     *
     * Both vectors are assumed to be unit length.
     *
     * @param {quat} out the receiving quaternion.
     * @param {ReadonlyVec3} a the initial vector
     * @param {ReadonlyVec3} b the destination vector
     * @returns {quat} out
     */

    (function () {
      var tmpvec3 = create$2();
      var xUnitVec3 = fromValues$2(1, 0, 0);
      var yUnitVec3 = fromValues$2(0, 1, 0);
      return function (out, a, b) {
        var dot$1 = dot(a, b);

        if (dot$1 < -0.999999) {
          cross(tmpvec3, xUnitVec3, a);
          if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
          normalize$2(tmpvec3, tmpvec3);
          setAxisAngle(out, tmpvec3, Math.PI);
          return out;
        } else if (dot$1 > 0.999999) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        } else {
          cross(tmpvec3, a, b);
          out[0] = tmpvec3[0];
          out[1] = tmpvec3[1];
          out[2] = tmpvec3[2];
          out[3] = 1 + dot$1;
          return normalize(out, out);
        }
      };
    })();
    /**
     * Performs a spherical linear interpolation with two control points
     *
     * @param {quat} out the receiving quaternion
     * @param {ReadonlyQuat} a the first operand
     * @param {ReadonlyQuat} b the second operand
     * @param {ReadonlyQuat} c the third operand
     * @param {ReadonlyQuat} d the fourth operand
     * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
     * @returns {quat} out
     */

    (function () {
      var temp1 = create();
      var temp2 = create();
      return function (out, a, b, c, d, t) {
        slerp(temp1, a, d, t);
        slerp(temp2, b, c, t);
        slerp(out, temp1, temp2, 2 * t * (1 - t));
        return out;
      };
    })();
    /**
     * Sets the specified quaternion with values corresponding to the given
     * axes. Each axis is a vec3 and is expected to be unit length and
     * perpendicular to all other specified axes.
     *
     * @param {ReadonlyVec3} view  the vector representing the viewing direction
     * @param {ReadonlyVec3} right the vector representing the local "right" direction
     * @param {ReadonlyVec3} up    the vector representing the local "up" direction
     * @returns {quat} out
     */

    (function () {
      var matr = create$4();
      return function (out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];
        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];
        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];
        return normalize(out, fromMat3(out, matr));
      };
    })();

    var Quat = /** @class */ (function () {
        function Quat() {
        }
        Quat.set = function (x, y, z, w, out) {
            if (out === void 0) { out = new Float32Array(4); }
            return set(out, x, y, z, w);
        };
        Quat.fromValues = function (x, y, z, w) {
            return fromValues(x, y, z, w);
        };
        Quat.create = function () {
            return create();
        };
        Quat.normalize = function (a, out) {
            if (out === void 0) { out = new Float32Array(4); }
            return normalize(out, a);
        };
        Quat.slerp = function (a, b, t, out) {
            if (out === void 0) { out = new Float32Array(4); }
            return slerp(out, a, b, t);
        };
        Quat.fromEuler = function (x, y, z, out) {
            if (out === void 0) { out = new Float32Array(4); }
            return fromEuler(out, x, y, z);
        };
        Quat.conjugate = function (a, out) {
            if (out === void 0) { out = new Float32Array(4); }
            return conjugate(out, a);
        };
        Quat.rotateX = function (a, rad, out) {
            if (out === void 0) { out = new Float32Array(4); }
            return rotateX(out, a, rad);
        };
        Quat.rotateY = function (a, rad, out) {
            if (out === void 0) { out = new Float32Array(4); }
            return rotateY(out, a, rad);
        };
        Quat.rotateZ = function (a, rad, out) {
            if (out === void 0) { out = new Float32Array(4); }
            return rotateZ(out, a, rad);
        };
        return Quat;
    }());

    /**
     * Represents a rotation quaternion in 3D space.
     */
    var ObservableQuaternion = /** @class */ (function (_super) {
        __extends(ObservableQuaternion, _super);
        /**
         * Creates a new observable quaternion.
         * @param cb The callback when changed.
         * @param scope The owner of callback.
         * @param x The x component.
         * @param y The y component.
         * @param z The z component.
         * @param w The w component.
         */
        function ObservableQuaternion(cb, scope, x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 1; }
            var _this = _super.call(this, cb, scope) || this;
            _this._array = new Float32Array(4);
            _this._array.set([x, y, z, w]);
            return _this;
        }
        Object.defineProperty(ObservableQuaternion.prototype, "array", {
            /** Array containing the x, y, z, w values. */
            get: function () {
                return this._array;
            },
            set: function (value) {
                this.setFrom(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ObservableQuaternion.prototype, "x", {
            /** The x component of the quaternion. */
            get: function () {
                return this._array[0];
            },
            set: function (value) {
                if (this._array[0] !== value) {
                    this._array[0] = value;
                    this.cb.call(this.scope);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ObservableQuaternion.prototype, "y", {
            /** The y component of the quaternion. */
            get: function () {
                return this._array[1];
            },
            set: function (value) {
                if (this._array[1] !== value) {
                    this._array[1] = value;
                    this.cb.call(this.scope);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ObservableQuaternion.prototype, "z", {
            /** The z component of the quaternion. */
            get: function () {
                return this._array[2];
            },
            set: function (value) {
                if (this._array[2] !== value) {
                    this._array[2] = value;
                    this.cb.call(this.scope);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ObservableQuaternion.prototype, "w", {
            /** The w component of the quaternion. */
            get: function () {
                return this._array[3];
            },
            set: function (value) {
                if (this._array[3] !== value) {
                    this._array[3] = value;
                    this.cb.call(this.scope);
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Sets the euler angles in degrees.
         * @param x The x angle.
         * @param y The y angle.
         * @param z The z angle.
         */
        ObservableQuaternion.prototype.setEulerAngles = function (x, y, z) {
            Quat.fromEuler(x, y, z, this._array);
            this.cb.call(this.scope);
        };
        /**
         * Creates a clone of this quaternion.
         * @param cb Callback when changed.
         * @param scope Owner of callback.
         */
        ObservableQuaternion.prototype.clone = function (cb, scope) {
            if (cb === void 0) { cb = this.cb; }
            if (scope === void 0) { scope = this.scope; }
            return new ObservableQuaternion(cb, scope, this.x, this.y, this.z, this.w);
        };
        /**
         * Copies x, y, z, and w from the given quaternion.
         * @param p The quaternion to copy from.
         */
        ObservableQuaternion.prototype.copyFrom = function (p) {
            if (this._array[0] !== p.x || this._array[1] !== p.y || this._array[2] !== p.z || this._array[3] !== p.w) {
                this._array[0] = p.x;
                this._array[1] = p.y;
                this._array[2] = p.z;
                this._array[3] = p.w;
                this.cb.call(this.scope);
            }
            return this;
        };
        /**
         * Copies x, y, z and w into the given quaternion.
         * @param p The quaternion to copy to.
         */
        ObservableQuaternion.prototype.copyTo = function (p) {
            if (p instanceof ObservableQuaternion) {
                p.set(this.x, this.y, this.z, this.w);
            }
            return p;
        };
        /**
         * Returns true if the given quaternion is equal to this quaternion.
         * @param p The quaternion to check.
         */
        ObservableQuaternion.prototype.equals = function (p) {
            return p.x === this.x && p.y === this.y && p.z === this.z && p.w === this.w;
        };
        /**
         * Sets the quaternion to new x, y, z and w components.
         * @param x X component to set.
         * @param y Y component to set.
         * @param z Z component to set.
         * @param w W component to set.
         */
        ObservableQuaternion.prototype.set = function (x, y, z, w) {
            if (y === void 0) { y = x; }
            if (z === void 0) { z = x; }
            if (w === void 0) { w = x; }
            if (this._array[0] !== x || this._array[1] !== y || this._array[2] !== z || this._array[3] !== w) {
                this._array[0] = x;
                this._array[1] = y;
                this._array[2] = z;
                this._array[3] = w;
                this.cb.call(this.scope);
            }
            return this;
        };
        /**
         * Sets the quaternion to a new x, y, z and w components.
         * @param array The array containing x, y, z and w, expected length is 4.
         */
        ObservableQuaternion.prototype.setFrom = function (array) {
            this.set(array[0], array[1], array[2], array[3]);
            return this;
        };
        return ObservableQuaternion;
    }(math.ObservablePoint));

    var Mat4 = /** @class */ (function () {
        function Mat4() {
        }
        Mat4.getTranslation = function (mat, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return getTranslation(out, mat);
        };
        Mat4.create = function () {
            return create$3();
        };
        Mat4.translate = function (mat, v, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return translate(out, mat, v);
        };
        Mat4.getScaling = function (mat, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return getScaling(out, mat);
        };
        Mat4.getRotation = function (mat, out) {
            if (out === void 0) { out = new Float32Array(4); }
            return getRotation(out, mat);
        };
        Mat4.copy = function (a, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return copy$1(out, a);
        };
        Mat4.fromQuat = function (q, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return fromQuat(out, q);
        };
        Mat4.fromRotationTranslationScale = function (q, v, s, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return fromRotationTranslationScale(out, q, v, s);
        };
        Mat4.fromRotation = function (rad, axis, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return fromRotation(out, rad, axis);
        };
        Mat4.fromScaling = function (v, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return fromScaling(out, v);
        };
        Mat4.fromTranslation = function (v, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return fromTranslation(out, v);
        };
        Mat4.multiply = function (a, b, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return multiply$1(out, a, b);
        };
        Mat4.lookAt = function (eye, center, up, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return lookAt(out, eye, center, up);
        };
        Mat4.identity = function (out) {
            if (out === void 0) { out = new Float32Array(16); }
            return identity(out);
        };
        Mat4.perspective = function (fovy, aspect, near, far, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return perspective(out, fovy, aspect, near, far);
        };
        Mat4.ortho = function (left, right, bottom, top, near, far, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return ortho(out, left, right, bottom, top, near, far);
        };
        Mat4.invert = function (a, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return invert(out, a);
        };
        Mat4.transpose = function (a, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return transpose(out, a);
        };
        Mat4.targetTo = function (eye, target, up, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return targetTo(out, eye, target, up);
        };
        Mat4.rotateX = function (a, rad, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return rotateX$1(out, a, rad);
        };
        Mat4.rotateY = function (a, rad, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return rotateY$1(out, a, rad);
        };
        Mat4.rotateZ = function (a, rad, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return rotateZ$1(out, a, rad);
        };
        Mat4.rotate = function (a, rad, axis, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return rotate(out, a, rad, axis);
        };
        Mat4.scale = function (a, v, out) {
            if (out === void 0) { out = new Float32Array(16); }
            return scale$1(out, a, v);
        };
        return Mat4;
    }());

    var Vec3 = /** @class */ (function () {
        function Vec3() {
        }
        Vec3.set = function (x, y, z, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return set$2(out, x, y, z);
        };
        Vec3.fromValues = function (x, y, z) {
            return fromValues$2(x, y, z);
        };
        Vec3.create = function () {
            return create$2();
        };
        Vec3.add = function (a, b, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return add(out, a, b);
        };
        Vec3.transformQuat = function (a, q, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return transformQuat(out, a, q);
        };
        Vec3.subtract = function (a, b, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return subtract(out, a, b);
        };
        Vec3.scale = function (a, b, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return scale(out, a, b);
        };
        Vec3.dot = function (a, b) {
            return dot(a, b);
        };
        Vec3.normalize = function (a, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return normalize$2(out, a);
        };
        Vec3.cross = function (a, b, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return cross(out, a, b);
        };
        Vec3.transformMat4 = function (a, m, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return transformMat4$1(out, a, m);
        };
        Vec3.copy = function (a, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return copy(out, a);
        };
        Vec3.magnitude = function (a) {
            return length(a);
        };
        Vec3.squaredMagnitude = function (a) {
            return squaredLength(a);
        };
        Vec3.inverse = function (a, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return inverse(out, a);
        };
        Vec3.negate = function (a, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return negate(out, a);
        };
        Vec3.multiply = function (a, b, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return multiply(out, a, b);
        };
        Vec3.distance = function (a, b) {
            return distance(a, b);
        };
        Vec3.squaredDistance = function (a, b) {
            return squaredDistance(a, b);
        };
        Vec3.lerp = function (a, b, t, out) {
            if (out === void 0) { out = new Float32Array(3); }
            return lerp(out, a, b, t);
        };
        return Vec3;
    }());

    var Vec4 = /** @class */ (function () {
        function Vec4() {
        }
        Vec4.set = function (x, y, z, w, out) {
            if (out === void 0) { out = new Float32Array(4); }
            return set$1(out, x, y, z, w);
        };
        Vec4.transformMat4 = function (a, m, out) {
            if (out === void 0) { out = new Float32Array(4); }
            return transformMat4(out, a, m);
        };
        Vec4.fromValues = function (x, y, z, w) {
            return fromValues$1(x, y, z, w);
        };
        return Vec4;
    }());

    var MatrixComponent = /** @class */ (function () {
        function MatrixComponent(_parent, size, _update) {
            this._parent = _parent;
            this._update = _update;
            this._array = new Float32Array(size);
        }
        Object.defineProperty(MatrixComponent.prototype, "array", {
            get: function () {
                if (this._id !== this._parent.transformId) {
                    this._update(this._array);
                    this._id = this._parent.transformId;
                }
                return this._array;
            },
            enumerable: false,
            configurable: true
        });
        return MatrixComponent;
    }());

    /**
     * Represents a 4x4 matrix.
     */
    var Matrix4 = /** @class */ (function (_super) {
        __extends(Matrix4, _super);
        /**
         * Creates a new transform matrix using the specified matrix array.
         * @param array The matrix array, expected length is 16. If empty, an identity
         * matrix is used by default.
         */
        function Matrix4(array) {
            var _this = _super.call(this) || this;
            _this._transformId = 0;
            if (array) {
                _this.array = new Float32Array(array);
            }
            else {
                _this.array = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
            }
            return _this;
        }
        Object.defineProperty(Matrix4.prototype, "transformId", {
            get: function () {
                return this._transformId;
            },
            enumerable: false,
            configurable: true
        });
        Matrix4.prototype.toArray = function (transpose, out) {
            if (transpose) {
                return Mat4.transpose(this.array, out);
            }
            return out ? Mat4.copy(this.array, out) : this.array;
        };
        Object.defineProperty(Matrix4.prototype, "position", {
            /** Returns the position component of the matrix. */
            get: function () {
                var _this = this;
                if (!this._position) {
                    this._position = new MatrixComponent(this, 3, function (data) {
                        Mat4.getTranslation(_this.array, data);
                    });
                }
                return this._position.array;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Matrix4.prototype, "scaling", {
            /** Returns the scaling component of the matrix. */
            get: function () {
                var _this = this;
                if (!this._scaling) {
                    this._scaling = new MatrixComponent(this, 3, function (data) {
                        Mat4.getScaling(_this.array, data);
                    });
                }
                return this._scaling.array;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Matrix4.prototype, "rotation", {
            /** Returns the rotation quaternion of the matrix. */
            get: function () {
                var _this = this;
                if (!this._rotation) {
                    var matrix_1 = new Float32Array(16);
                    this._rotation = new MatrixComponent(this, 4, function (data) {
                        var e_1, _a;
                        try {
                            // To extract a correct rotation, the scaling component must be eliminated.
                            for (var _b = __values([0, 1, 2]), _c = _b.next(); !_c.done; _c = _b.next()) {
                                var col = _c.value;
                                matrix_1[col + 0] = _this.array[col + 0] / _this.scaling[0];
                                matrix_1[col + 4] = _this.array[col + 4] / _this.scaling[1];
                                matrix_1[col + 8] = _this.array[col + 8] / _this.scaling[2];
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        Quat.normalize(Mat4.getRotation(matrix_1, data), data);
                    });
                }
                return this._rotation.array;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Matrix4.prototype, "up", {
            /** Returns the up vector of the matrix. */
            get: function () {
                var _this = this;
                if (!this._up) {
                    this._up = new MatrixComponent(this, 3, function (data) {
                        Vec3.normalize(Vec3.set(_this.array[4], _this.array[5], _this.array[6], data), data);
                    });
                }
                return this._up.array;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Matrix4.prototype, "down", {
            /** Returns the down vector of the matrix. */
            get: function () {
                var _this = this;
                if (!this._down) {
                    this._down = new MatrixComponent(this, 3, function (data) {
                        Vec3.negate(_this.up, data);
                    });
                }
                return this._down.array;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Matrix4.prototype, "right", {
            /** Returns the left vector of the matrix. */
            get: function () {
                var _this = this;
                if (!this._right) {
                    this._right = new MatrixComponent(this, 3, function (data) {
                        Vec3.negate(_this.left, data);
                    });
                }
                return this._right.array;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Matrix4.prototype, "left", {
            /** Returns the right vector of the matrix. */
            get: function () {
                var _this = this;
                if (!this._left) {
                    this._left = new MatrixComponent(this, 3, function (data) {
                        Vec3.normalize(Vec3.cross(_this.up, _this.forward, data), data);
                    });
                }
                return this._left.array;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Matrix4.prototype, "forward", {
            /** Returns the forward vector of the matrix. */
            get: function () {
                var _this = this;
                if (!this._forward) {
                    this._forward = new MatrixComponent(this, 3, function (data) {
                        Vec3.normalize(Vec3.set(_this.array[8], _this.array[9], _this.array[10], data), data);
                    });
                }
                return this._forward.array;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Matrix4.prototype, "backward", {
            /** Returns the backward vector of the matrix. */
            get: function () {
                var _this = this;
                if (!this._backward) {
                    this._backward = new MatrixComponent(this, 3, function (data) {
                        Vec3.negate(_this.forward, data);
                    });
                }
                return this._backward.array;
            },
            enumerable: false,
            configurable: true
        });
        Matrix4.prototype.copyFrom = function (matrix) {
            if (matrix instanceof Matrix4) {
                Mat4.copy(matrix.array, this.array);
                this._transformId++;
            }
            return this;
        };
        /**
         * Sets the rotation, position and scale components.
         * @param rotation The rotation to set.
         * @param position The position to set.
         * @param scaling The scale to set.
         */
        Matrix4.prototype.setFromRotationPositionScale = function (rotation, position, scaling) {
            Vec4.set(rotation.x, rotation.y, rotation.z, rotation.w, this.rotation);
            Vec3.set(scaling.x, scaling.y, scaling.z, this.scaling);
            Vec3.set(position.x, position.y, position.z, this.position);
            Mat4.fromRotationTranslationScale(this.rotation, this.position, this.scaling, this.array);
            this._transformId++;
        };
        /**
         * Multiplies this matrix with another matrix.
         * @param matrix The matrix to multiply with.
         */
        Matrix4.prototype.multiply = function (matrix) {
            Mat4.multiply(matrix.array, this.array, this.array);
            this._transformId++;
        };
        return Matrix4;
    }(math.Matrix));

    /**
     * Handles position, scaling and rotation in 3D.
     */
    var Transform3D = /** @class */ (function (_super) {
        __extends(Transform3D, _super);
        function Transform3D() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /** The position in local space. */
            _this.position = new ObservablePoint3D(_this.onChange, _this, 0, 0, 0);
            /** The scale in local space. */
            _this.scale = new ObservablePoint3D(_this.onChange, _this, 1, 1, 1);
            /** The rotation in local space. */
            _this.rotationQuaternion = new ObservableQuaternion(_this.onChange, _this, 0, 0, 0, 1);
            /** The transformation matrix in world space. */
            _this.worldTransform = new Matrix4();
            /** The transformation matrix in local space. */
            _this.localTransform = new Matrix4();
            /** The inverse transformation matrix in world space. */
            _this.inverseWorldTransform = new Matrix4();
            /** The normal transformation matrix. */
            _this.normalTransform = new Matrix4();
            return _this;
        }
        /**
         * Updates the local transformation matrix.
         */
        Transform3D.prototype.updateLocalTransform = function () {
            if (this._localID === this._currentLocalID) {
                return;
            }
            this.localTransform.setFromRotationPositionScale(this.rotationQuaternion, this.position, this.scale);
            this._parentID = -1;
            this._currentLocalID = this._localID;
        };
        /**
         * Sets position, rotation and scale from a matrix array.
         * @param matrix The matrix to set.
         */
        Transform3D.prototype.setFromMatrix = function (matrix) {
            this.localTransform.copyFrom(matrix);
            this.position.set(this.localTransform.position[0], this.localTransform.position[1], this.localTransform.position[2]);
            this.scale.set(this.localTransform.scaling[0], this.localTransform.scaling[1], this.localTransform.scaling[2]);
            this.rotationQuaternion.set(this.localTransform.rotation[0], this.localTransform.rotation[1], this.localTransform.rotation[2], this.localTransform.rotation[3]);
        };
        /**
         * Updates the world transformation matrix.
         * @param parentTransform The parent transform.
         */
        Transform3D.prototype.updateTransform = function (parentTransform) {
            this.updateLocalTransform();
            if (parentTransform && this._parentID === parentTransform._worldID) {
                return;
            }
            this.worldTransform.copyFrom(this.localTransform);
            if (parentTransform instanceof Transform3D) {
                this.worldTransform.multiply(parentTransform.worldTransform);
            }
            Mat4.invert(this.worldTransform.array, this.inverseWorldTransform.array);
            Mat4.transpose(this.inverseWorldTransform.array, this.normalTransform.array);
            this._worldID++;
            if (parentTransform) {
                this._parentID = parentTransform._worldID;
            }
        };
        /**
         * Rotates the transform so the forward vector points at specified point.
         * @param point The point to look at.
         * @param up The upward direction.
         */
        Transform3D.prototype.lookAt = function (point, up) {
            if (up === void 0) { up = new Float32Array([0, 1, 0]); }
            var rot = Mat4.getRotation(Mat4.targetTo(point.array, this.worldTransform.position, up));
            this.rotationQuaternion.set(rot[0], rot[1], rot[2], rot[3]);
        };
        return Transform3D;
    }(math.Transform));

    /**
     * A container represents a collection of 3D objects.
     */
    var Container3D = /** @class */ (function (_super) {
        __extends(Container3D, _super);
        function Container3D() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.transform = new Transform3D();
            return _this;
        }
        Object.defineProperty(Container3D.prototype, "position", {
            get: function () {
                return this.transform.position;
            },
            set: function (value) {
                this.transform.position.copyFrom(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "scale", {
            get: function () {
                return this.transform.scale;
            },
            set: function (value) {
                this.transform.scale.copyFrom(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "rotationQuaternion", {
            /** The quaternion rotation of the object. */
            get: function () {
                return this.transform.rotationQuaternion;
            },
            set: function (value) {
                this.transform.rotationQuaternion.copyFrom(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "z", {
            /** The position of the object on the z axis relative to the local
             * coordinates of the parent. */
            get: function () {
                return this.transform.position.z;
            },
            set: function (value) {
                this.transform.position.z = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "localTransform", {
            get: function () {
                return this.transform.localTransform;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "worldTransform", {
            get: function () {
                return this.transform.worldTransform;
            },
            enumerable: false,
            configurable: true
        });
        return Container3D;
    }(display.Container));

    var Ray = /** @class */ (function () {
        function Ray(origin, direction) {
            this._direction = new Float32Array(3);
            this._origin = new Float32Array(3);
            Vec3.copy(origin, this._origin);
            Vec3.normalize(direction, this._direction);
        }
        Object.defineProperty(Ray.prototype, "origin", {
            get: function () {
                return this._origin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Ray.prototype, "direction", {
            get: function () {
                return this._direction;
            },
            enumerable: false,
            configurable: true
        });
        Ray.prototype.getPoint = function (distance, point) {
            if (point === void 0) { point = new Float32Array(3); }
            return Vec3.add(this._origin, Vec3.scale(this._direction, distance, point), point);
        };
        return Ray;
    }());

    var vec3$1 = new Float32Array(3);
    var mat4 = new Float32Array(16);
    var vec4 = new Float32Array(4);
    /**
     * Camera is a device from which the world is viewed.
     */
    var Camera = /** @class */ (function (_super) {
        __extends(Camera, _super);
        /**
         * Creates a new camera using the specified renderer. By default the camera
         * looks towards negative z and is positioned at z = 5.
         * @param renderer Renderer to use.
         */
        function Camera(renderer) {
            var _this = _super.call(this) || this;
            _this.renderer = renderer;
            _this._transformId = 0;
            _this._orthographic = false;
            _this._orthographicSize = 10;
            _this._obliqueness = new math.ObservablePoint(function () {
                _this._transformId++;
            }, undefined);
            _this._fieldOfView = 60;
            _this._near = 0.1;
            _this._far = 1000;
            var aspect = renderer.width / renderer.height;
            var localID = -1;
            _this.renderer.on("prerender", function () {
                if (!_this._aspect) {
                    // When there is no specific aspect set, this is used for the 
                    // projection matrix to always update each frame (in case when the 
                    // renderer aspect ratio has changed).
                    if (renderer.width / renderer.height !== aspect) {
                        _this._transformId++;
                        aspect = renderer.width / renderer.height;
                    }
                }
                // @ts-ignore: _localID do exist, but be careful if this changes.
                if (!_this.parent && localID !== _this.transform._localID) {
                    // When the camera is not attached to the scene hierarchy the transform 
                    // needs to be updated manually.
                    _this.transform.updateTransform();
                    // @ts-ignore: _localID do exist, but be careful if this changes.
                    localID = _this.transform._localID;
                }
            });
            if (!Camera.main) {
                Camera.main = _this;
            }
            _this.transform.position.z = 5;
            _this.transform.rotationQuaternion.setEulerAngles(0, 180, 0);
            return _this;
        }
        Object.defineProperty(Camera.prototype, "transformId", {
            get: function () {
                return this.transform._worldID + this._transformId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "obliqueness", {
            /**
             * Used for making the frustum oblique, which means that one side is at a
             * smaller angle to the centre line than the opposite side. Only works with
             * perspective projection.
             */
            get: function () {
                return this._obliqueness;
            },
            set: function (value) {
                this._obliqueness.copyFrom(value);
            },
            enumerable: false,
            configurable: true
        });
        Camera.prototype.destroy = function (options) {
            _super.prototype.destroy.call(this, options);
            if (this === Camera.main) {
                // @ts-ignore It's ok, main camera was destroyed.
                Camera.main = undefined;
            }
        };
        Object.defineProperty(Camera.prototype, "orthographicSize", {
            /**
             * The camera's half-size when in orthographic mode. The visible area from
             * center of the screen to the top.
             */
            get: function () {
                return this._orthographicSize;
            },
            set: function (value) {
                if (this._orthographicSize !== value) {
                    this._orthographicSize = value;
                    this._transformId++;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "orthographic", {
            /**
             * Camera will render objects uniformly, with no sense of perspective.
             */
            get: function () {
                return this._orthographic;
            },
            set: function (value) {
                if (this._orthographic !== value) {
                    this._orthographic = value;
                    this._transformId++;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Converts screen coordinates to a ray.
         * @param x Screen x coordinate.
         * @param y Screen y coordinate.
         * @param viewSize The size of the view when not rendering to the entire screen.
         */
        Camera.prototype.screenToRay = function (x, y, viewSize) {
            if (viewSize === void 0) { viewSize = this.renderer.screen; }
            var screen = this.screenToWorld(x, y, 1, undefined, viewSize);
            if (screen) {
                if (this.orthographic) {
                    return new Ray(screen.array, this.worldTransform.forward);
                }
                return new Ray(this.worldTransform.position, Vec3.subtract(screen.array, this.worldTransform.position, vec3$1));
            }
        };
        /**
         * Converts screen coordinates to world coordinates.
         * @param x Screen x coordinate.
         * @param y Screen y coordinate.
         * @param distance Distance from the camera.
         * @param point Point to set.
         * @param viewSize The size of the view when not rendering to the entire screen.
         */
        Camera.prototype.screenToWorld = function (x, y, distance, point, viewSize) {
            var _a;
            if (point === void 0) { point = new ObservablePoint3D(function () { }, undefined); }
            if (viewSize === void 0) { viewSize = this.renderer.screen; }
            // Make sure the transform is updated in case something has been changed, 
            // otherwise it may be using wrong values.
            this.transform.updateTransform((_a = this.parent) === null || _a === void 0 ? void 0 : _a.transform);
            var far = this.far;
            // Before doing the calculations, the far clip plane is changed to the same 
            // value as distance from the camera. By doing this we can just set z value 
            // for the clip space to 1 and the desired z position will be correct.
            this.far = distance;
            var invertedViewProjection = Mat4.invert(this.viewProjection, mat4);
            if (invertedViewProjection === null) {
                return;
            }
            var clipSpace = Vec4.set((x / viewSize.width) * 2 - 1, ((y / viewSize.height) * 2 - 1) * -1, 1, 1, vec4);
            this.far = far;
            var worldSpace = Vec4.transformMat4(clipSpace, invertedViewProjection, vec4);
            worldSpace[3] = 1.0 / worldSpace[3];
            for (var i = 0; i < 3; i++) {
                worldSpace[i] *= worldSpace[3];
            }
            return point.set(worldSpace[0], worldSpace[1], worldSpace[2]);
        };
        /**
         * Converts world coordinates to screen coordinates.
         * @param x World x coordinate.
         * @param y World y coordinate.
         * @param z World z coordinate.
         * @param point Point to set.
         * @param viewSize The size of the view when not rendering to the entire screen.
         */
        Camera.prototype.worldToScreen = function (x, y, z, point, viewSize) {
            var _a;
            if (point === void 0) { point = new math.Point(); }
            if (viewSize === void 0) { viewSize = this.renderer.screen; }
            // Make sure the transform is updated in case something has been changed, 
            // otherwise it may be using wrong values.
            this.transform.updateTransform((_a = this.parent) === null || _a === void 0 ? void 0 : _a.transform);
            var worldSpace = Vec4.set(x, y, z, 1, vec4);
            var clipSpace = Vec4.transformMat4(Vec4.transformMat4(worldSpace, this.view, vec4), this.projection, vec4);
            if (clipSpace[3] !== 0) {
                for (var i = 0; i < 3; i++) {
                    clipSpace[i] /= clipSpace[3];
                }
            }
            return point.set((clipSpace[0] + 1) / 2 * viewSize.width, viewSize.height - (clipSpace[1] + 1) / 2 * viewSize.height);
        };
        Object.defineProperty(Camera.prototype, "aspect", {
            /**
             * The aspect ratio (width divided by height). If not set, the aspect ratio of
             * the renderer will be used by default.
             */
            get: function () {
                return this._aspect;
            },
            set: function (value) {
                if (this._aspect !== value) {
                    this._aspect = value;
                    this._transformId++;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "fieldOfView", {
            /** The vertical field of view in degrees, 60 is the default value. */
            get: function () {
                return this._fieldOfView;
            },
            set: function (value) {
                if (this._fieldOfView !== value) {
                    this._fieldOfView = value;
                    this._transformId++;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "near", {
            /** The near clipping plane distance, 0.1 is the default value. */
            get: function () {
                return this._near;
            },
            set: function (value) {
                if (this._near !== value) {
                    this._near = value;
                    this._transformId++;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "far", {
            /** The far clipping plane distance, 1000 is the default value. */
            get: function () {
                return this._far;
            },
            set: function (value) {
                if (this._far !== value) {
                    this._far = value;
                    this._transformId++;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "projection", {
            /** Returns the projection matrix. */
            get: function () {
                var _this = this;
                if (!this._projection) {
                    this._projection = new MatrixComponent(this, 16, function (data) {
                        var aspect = _this._aspect || _this.renderer.width / _this.renderer.height;
                        if (_this._orthographic) {
                            Mat4.ortho(-_this._orthographicSize * aspect, _this._orthographicSize * aspect, -_this._orthographicSize, _this._orthographicSize, _this._near, _this._far, data);
                        }
                        else {
                            Mat4.perspective(_this._fieldOfView * math.DEG_TO_RAD, aspect, _this._near, _this._far, data);
                            data[8] = _this._obliqueness.x;
                            data[9] = _this._obliqueness.y;
                        }
                    });
                }
                return this._projection.array;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "view", {
            /** Returns the view matrix. */
            get: function () {
                var _this = this;
                if (!this._view) {
                    this._view = new MatrixComponent(this, 16, function (data) {
                        var target = Vec3.add(_this.worldTransform.position, _this.worldTransform.forward, vec3$1);
                        Mat4.lookAt(_this.worldTransform.position, target, _this.worldTransform.up, data);
                    });
                }
                return this._view.array;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "viewProjection", {
            /** Returns the view projection matrix. */
            get: function () {
                var _this = this;
                if (!this._viewProjection) {
                    this._viewProjection = new MatrixComponent(this, 16, function (data) {
                        Mat4.multiply(_this.projection, _this.view, data);
                    });
                }
                return this._viewProjection.array;
            },
            enumerable: false,
            configurable: true
        });
        return Camera;
    }(Container3D));
    Compatibility.installRendererPlugin("camera", Camera);

    /**
     * Allows the user to control the camera by orbiting the target.
     */
    var CameraOrbitControl = /** @class */ (function () {
        /**
         * Creates a new camera orbit control.
         * @param element The element for listening to user events.
         * @param camera The camera to control. If not set, the main camera will be used
         * by default.
         */
        function CameraOrbitControl(element, camera) {
            var _this = this;
            if (camera === void 0) { camera = Camera.main; }
            this.camera = camera;
            this._distance = 5;
            this._grabbed = false;
            this._angles = new math.ObservablePoint(function () {
                _this._angles.x = Math.min(Math.max(-85, _this._angles.x), 85);
            }, undefined, 0, 180);
            /** Target position (x, y, z) to orbit. */
            this.target = { x: 0, y: 0, z: 0 };
            /** Allows the camera to be controlled by user. */
            this.allowControl = true;
            this.camera.renderer.on("prerender", function () {
                _this.updateCamera();
            });
            this.camera.renderer.plugins.interaction.on("mousedown", function (e) {
                if (!e.stopped) {
                    _this._grabbed = true;
                }
            });
            element.addEventListener("mouseup", function () {
                _this._grabbed = false;
            });
            element.addEventListener("mousemove", function (event) {
                if (_this.allowControl && event.buttons === 1 && _this._grabbed) {
                    _this._angles.x += event.movementY * 0.5;
                    _this._angles.y -= event.movementX * 0.5;
                }
            });
            element.addEventListener("wheel", function (event) {
                if (_this.allowControl) {
                    _this.distance += event.deltaY * 0.01;
                    event.preventDefault();
                }
            });
        }
        Object.defineProperty(CameraOrbitControl.prototype, "angles", {
            /**
             * Orientation euler angles (x-axis and y-axis). The angle for the x-axis
             * will be clamped between -85 and 85 degrees.
             */
            get: function () {
                return this._angles;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Updates the position and rotation of the camera.
         */
        CameraOrbitControl.prototype.updateCamera = function () {
            var rot = Quat.fromEuler(this._angles.x, this._angles.y, 0, new Float32Array(4));
            var dir = Vec3.transformQuat(Vec3.set(0, 0, 1, new Float32Array(3)), rot, new Float32Array(3));
            var pos = Vec3.subtract(Vec3.set(this.target.x, this.target.y, this.target.z, new Float32Array(3)), Vec3.scale(dir, this.distance, new Float32Array(3)), new Float32Array(3));
            this.camera.position.set(pos[0], pos[1], pos[2]);
            this.camera.rotationQuaternion.set(rot[0], rot[1], rot[2], rot[3]);
        };
        Object.defineProperty(CameraOrbitControl.prototype, "distance", {
            /**
             * Distance between camera and the target. Default value is 5.
             */
            get: function () {
                return this._distance;
            },
            set: function (value) {
                this._distance = Math.min(Math.max(value, 0.01), Number.MAX_SAFE_INTEGER);
            },
            enumerable: false,
            configurable: true
        });
        return CameraOrbitControl;
    }());

    /**
     * Geometry with mesh data (i.e. positions, normals, uvs).
     */
    var MeshGeometry3D = /** @class */ (function () {
        function MeshGeometry3D() {
            this._shaderGeometry = {};
        }
        /**
         * Returns geometry with attributes required by the specified shader.
         * @param shader The shader to use.
         */
        MeshGeometry3D.prototype.getShaderGeometry = function (shader) {
            return this._shaderGeometry[shader.name];
        };
        /**
         * Creates geometry with attributes required by the specified shader.
         * @param shader The shader to use.
         * @param instanced Value indicating if the geometry will be instanced.
         */
        MeshGeometry3D.prototype.addShaderGeometry = function (shader, instanced) {
            this._shaderGeometry[shader.name] = shader.createShaderGeometry(this, instanced);
        };
        /**
         * Returns a value indicating if geometry with required attributes has been
         * created by the specified shader.
         * @param shader The shader to test.
         * @param instanced Value indicating if the geometry is instanced.
         */
        MeshGeometry3D.prototype.hasShaderGeometry = function (shader, instanced) {
            if (this._shaderGeometry[shader.name]) {
                return !instanced || (instanced && this._shaderGeometry[shader.name].instanced);
            }
            return false;
        };
        /**
         * Destroys the geometry and it's used resources.
         */
        MeshGeometry3D.prototype.destroy = function () {
            for (var name_1 in this._shaderGeometry) {
                this._shaderGeometry[name_1].destroy();
            }
            this._shaderGeometry = {};
        };
        return MeshGeometry3D;
    }());

    var PlaneGeometry;
    (function (PlaneGeometry) {
        function create() {
            return Object.assign(new MeshGeometry3D(), {
                positions: {
                    buffer: new Float32Array([-1, 0, 1, 1, 0, -1, -1, 0, -1, 1, 0, 1])
                },
                indices: {
                    buffer: new Uint8Array([0, 1, 2, 0, 3, 1])
                },
                normals: {
                    buffer: new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0])
                },
                uvs: [{
                        buffer: new Float32Array([0, 1, 1, 0, 0, 0, 1, 1])
                    }]
            });
        }
        PlaneGeometry.create = create;
    })(PlaneGeometry || (PlaneGeometry = {}));

    var CubeGeometry;
    (function (CubeGeometry) {
        function create() {
            return Object.assign(new MeshGeometry3D(), {
                positions: {
                    buffer: new Float32Array([-1, 1, 1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1])
                },
                indices: {
                    buffer: new Uint8Array([0, 1, 2, 0, 3, 1, 4, 5, 6, 4, 7, 5, 8, 9, 10, 8, 11, 9, 12, 13, 14, 12, 15, 13, 16, 17, 18, 16, 19, 17, 20, 21, 22, 20, 23, 21])
                },
                normals: {
                    buffer: new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0])
                },
                uvs: [{
                        buffer: new Float32Array([0.625, 1, 0.375, 0.75, 0.375, 1, 0.625, 0.75, 0.625, 0.75, 0.375, 0.5, 0.375, 0.75, 0.625, 0.5, 0.625, 0.5, 0.375, 0.25, 0.375, 0.5, 0.625, 0.25, 0.625, 0.25, 0.375, 0, 0.375, 0.25, 0.625, 0, 0.375, 0.25, 0.125, 0.5, 0.375, 0.5, 0.125, 0.25, 0.875, 0.25, 0.625, 0.5, 0.875, 0.5, 0.625, 0.25])
                    }],
                tangents: {
                    buffer: new Float32Array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, -1, 0, 0, 1, -1, 0, 0, 1, -1, 0, 0, 1, -1, 0, 0, 1])
                }
            });
        }
        CubeGeometry.create = create;
    })(CubeGeometry || (CubeGeometry = {}));

    var QuadGeometry;
    (function (QuadGeometry) {
        function create() {
            return Object.assign(new MeshGeometry3D(), {
                positions: {
                    buffer: new Float32Array([-1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 1, 0])
                },
                indices: {
                    buffer: new Uint8Array([0, 2, 1, 0, 1, 3])
                },
                normals: {
                    buffer: new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1])
                },
                uvs: [{
                        buffer: new Float32Array([0, 0, 1, 1, 0, 1, 1, 0])
                    }]
            });
        }
        QuadGeometry.create = create;
    })(QuadGeometry || (QuadGeometry = {}));

    var InstancedMesh3D = /** @class */ (function (_super) {
        __extends(InstancedMesh3D, _super);
        function InstancedMesh3D(mesh, material) {
            var _this = _super.call(this) || this;
            _this.mesh = mesh;
            _this.material = material;
            return _this;
        }
        InstancedMesh3D.prototype.destroy = function (options) {
            _super.prototype.destroy.call(this, options);
            this.mesh.removeInstance(this);
        };
        return InstancedMesh3D;
    }(Container3D));

    exports.LightType = void 0;
    (function (LightType) {
        /**
         * A light that is located at a point and emits light in a cone shape.
         */
        LightType["spot"] = "spot";
        /**
         * A light that is located infinitely far away, and emits light in one
         * direction only.
         */
        LightType["directional"] = "directional";
        /**
         * A light that is located at a point and emits light in all directions
         * equally.
         */
        LightType["point"] = "point";
    })(exports.LightType || (exports.LightType = {}));

    exports.StandardMaterialAlphaMode = void 0;
    (function (StandardMaterialAlphaMode) {
        /**
         * The rendered output is fully opaque and any alpha value is ignored.
         */
        StandardMaterialAlphaMode["opaque"] = "opaque";
        /**
         * The rendered output is either fully opaque or fully transparent depending
         * on the alpha value and the specified alpha cutoff value. This mode is used
         * to simulate geometry such as tree leaves or wire fences.
         */
        StandardMaterialAlphaMode["mask"] = "mask";
        /**
         * The rendered output is combined with the background using the normal
         * painting operation (i.e. the Porter and Duff over operator). This mode is
         * used to simulate geometry such as guaze cloth or animal fur.
         */
        StandardMaterialAlphaMode["blend"] = "blend";
    })(exports.StandardMaterialAlphaMode || (exports.StandardMaterialAlphaMode = {}));

    exports.StandardMaterialDebugMode = void 0;
    (function (StandardMaterialDebugMode) {
        StandardMaterialDebugMode["alpha"] = "alpha";
        StandardMaterialDebugMode["emissive"] = "emissive";
        StandardMaterialDebugMode["f0"] = "f0";
        StandardMaterialDebugMode["metallic"] = "metallic";
        StandardMaterialDebugMode["normal"] = "normal";
        StandardMaterialDebugMode["occlusion"] = "occlusion";
        StandardMaterialDebugMode["roughness"] = "roughness";
    })(exports.StandardMaterialDebugMode || (exports.StandardMaterialDebugMode = {}));

    var Capabilities;
    (function (Capabilities) {
        var _maxVertexUniformVectors;
        function getMaxVertexUniformVectors(renderer) {
            if (_maxVertexUniformVectors !== undefined) {
                return _maxVertexUniformVectors;
            }
            var gl = renderer.gl;
            _maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            return _maxVertexUniformVectors;
        }
        Capabilities.getMaxVertexUniformVectors = getMaxVertexUniformVectors;
        var _isFloatTextureSupported;
        function isFloatingPointTextureSupported(renderer) {
            if (renderer.context.webGLVersion === 2) {
                return true;
            }
            if (_isFloatTextureSupported !== undefined) {
                return _isFloatTextureSupported;
            }
            var gl = renderer.gl;
            _isFloatTextureSupported = !!gl.getExtension("OES_texture_float");
            return _isFloatTextureSupported;
        }
        Capabilities.isFloatingPointTextureSupported = isFloatingPointTextureSupported;
        var _isHalfFloatFramebufferSupported;
        function isHalfFloatFramebufferSupported(renderer) {
            if (renderer.context.webGLVersion === 2) {
                return true;
            }
            if (_isHalfFloatFramebufferSupported !== undefined) {
                return _isHalfFloatFramebufferSupported;
            }
            var gl = renderer.gl;
            var ext = gl.getExtension("OES_texture_half_float");
            if (!ext) {
                return false;
            }
            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 8, 8, 0, gl.RGBA, ext.HALF_FLOAT_OES, null);
            var fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            var attachmentPoint = gl.COLOR_ATTACHMENT0;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, texture, 0);
            _isHalfFloatFramebufferSupported = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
            return _isHalfFloatFramebufferSupported;
        }
        Capabilities.isHalfFloatFramebufferSupported = isHalfFloatFramebufferSupported;
        var _isFloatFramebufferSupported;
        function isFloatFramebufferSupported(renderer) {
            if (renderer.context.webGLVersion === 2) {
                return true;
            }
            if (_isFloatFramebufferSupported !== undefined) {
                return _isFloatFramebufferSupported;
            }
            var gl = renderer.gl;
            var ext = gl.getExtension("OES_texture_float");
            if (!ext) {
                return false;
            }
            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 8, 8, 0, gl.RGBA, gl.FLOAT, null);
            var fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            var attachmentPoint = gl.COLOR_ATTACHMENT0;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, texture, 0);
            _isFloatFramebufferSupported = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
            return _isFloatFramebufferSupported;
        }
        Capabilities.isFloatFramebufferSupported = isFloatFramebufferSupported;
        var _isFloatLinearSupported;
        function supportsFloatLinear(renderer) {
            if (_isFloatLinearSupported !== undefined) {
                return _isFloatLinearSupported;
            }
            var gl = renderer.gl;
            _isFloatLinearSupported = gl.getExtension("OES_texture_float_linear") !== null;
            return _isFloatLinearSupported;
        }
        Capabilities.supportsFloatLinear = supportsFloatLinear;
        function isShaderTextureLodSupported(renderer) {
            if (renderer.context.webGLVersion === 2) {
                return true;
            }
            return renderer.gl.getExtension("EXT_shader_texture_lod") !== null;
        }
        Capabilities.isShaderTextureLodSupported = isShaderTextureLodSupported;
        var _isInstancingSupported;
        function isInstancingSupported(renderer) {
            if (_isInstancingSupported !== undefined) {
                return _isInstancingSupported;
            }
            var gl = renderer.gl;
            _isInstancingSupported = gl.getExtension("ANGLE_instanced_arrays") !== undefined;
            return _isInstancingSupported;
        }
        Capabilities.isInstancingSupported = isInstancingSupported;
    })(Capabilities || (Capabilities = {}));

    var BufferResource = CompatibilityAccess.get(PixiCore__namespace, "BufferResource") ||
        //@ts-ignore 
        CompatibilityAccess.get(PixiCore__namespace, "resources").BufferResource;

    var StandardMaterialMatrixTexture = /** @class */ (function (_super) {
        __extends(StandardMaterialMatrixTexture, _super);
        function StandardMaterialMatrixTexture(matrixCount) {
            var _this = this;
            var buffer = new Float32Array(matrixCount * 16);
            var resource = new BufferResource(buffer, { width: 4, height: matrixCount });
            _this = _super.call(this, new PixiCore.BaseTexture(resource, {
                mipmap: constants.MIPMAP_MODES.OFF,
                wrapMode: constants.WRAP_MODES.CLAMP,
                scaleMode: constants.SCALE_MODES.NEAREST,
                format: constants.FORMATS.RGBA,
                type: constants.TYPES.FLOAT,
                alphaMode: constants.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
                resolution: 1
            })) || this;
            _this._buffer = buffer;
            return _this;
        }
        StandardMaterialMatrixTexture.isSupported = function (renderer) {
            return Capabilities.isFloatingPointTextureSupported(renderer);
        };
        StandardMaterialMatrixTexture.prototype.updateBuffer = function (buffer) {
            this._buffer.set(buffer);
            this.baseTexture.resource.update();
        };
        return StandardMaterialMatrixTexture;
    }(PixiCore.Texture));

    exports.Debug = void 0;
    (function (Debug) {
        var messages = [];
        var eventEmitter = new utils.EventEmitter();
        function on(event, fn, context) {
            eventEmitter.on(event, fn, context);
        }
        Debug.on = on;
        function warn(message, args) {
            if (!messages.includes(message)) {
                messages.push(message);
                var formatted = formatMessage(message, args);
                console.warn("PIXI3D: " + formatted);
                eventEmitter.emit("warn", formatted);
            }
        }
        Debug.warn = warn;
        function error(message, args) {
            if (!messages.includes(message)) {
                messages.push(message);
                var formatted = formatMessage(message, args);
                console.error("PIXI3D: " + formatted);
                eventEmitter.emit("error", formatted);
            }
        }
        Debug.error = error;
        function formatMessage(message, args) {
            var formatted = message;
            var match;
            while ((match = /{(\w*)}/g.exec(formatted)) !== null && args) {
                formatted = formatted.replace(match[0], args[match[1]]);
            }
            return formatted;
        }
    })(exports.Debug || (exports.Debug = {}));

    var Message;
    (function (Message) {
        Message["meshVertexSkinningFloatingPointTexturesNotSupported"] = "Mesh is using vertex skinning but floating point textures is not supported on this device/environment. In case of errors, try changing the environment in PixiJS settings. Set \"PIXI.settings.PREFER_ENV = PIXI.ENV.WEBGL2\" before creating a renderer/application.";
        Message["meshVertexSkinningNumberOfJointsNotSupported"] = "Mesh is using vertex skinning but the number of joints ({joints}) is not supported on this device/environment. Max number of supported joints is {maxJoints}, try reducing the number of joints.";
        Message["imageBasedLightingShaderTextureLodNotSupported"] = "Image based lighting is used but shader texture lod is not supported on this device/environment, the material may not be displayed correctly. Try changing the environment in PixiJS settings. Set \"PIXI.settings.PREFER_ENV = PIXI.ENV.WEBGL2\" before creating a renderer/application.";
    })(Message || (Message = {}));

    var StandardMaterialFeatureSet;
    (function (StandardMaterialFeatureSet) {
        function build(renderer, mesh, geometry, material, lightingEnvironment) {
            var features = [];
            if (mesh.instances.length > 0) {
                features.push("USE_INSTANCING 1");
            }
            if (renderer.context.webGLVersion === 1) {
                features.push("WEBGL1 1");
            }
            if (renderer.context.webGLVersion === 2) {
                features.push("WEBGL2 1");
            }
            if (geometry.colors) {
                // Need to figure out how to detect if vec3 or vec4 should be
                // used. For now disable vec4.
                features.push("HAS_VERTEX_COLOR_VEC3 1");
                // features.push("HAS_VERTEX_COLOR_VEC4 1") 
            }
            if (geometry.normals) {
                features.push("HAS_NORMALS 1");
            }
            if (geometry.uvs && geometry.uvs[0]) {
                features.push("HAS_UV_SET1 1");
            }
            if (geometry.uvs && geometry.uvs[1]) {
                features.push("HAS_UV_SET2 1");
            }
            if (geometry.tangents) {
                features.push("HAS_TANGENTS 1");
            }
            if (geometry.targets) {
                for (var i = 0; i < geometry.targets.length; i++) {
                    if (geometry.targets[i].positions) {
                        features.push("HAS_TARGET_POSITION" + i);
                    }
                    if (geometry.targets[i].normals) {
                        features.push("HAS_TARGET_NORMAL" + i);
                    }
                    if (geometry.targets[i].tangents) {
                        features.push("HAS_TARGET_TANGENT" + i);
                    }
                }
                if (mesh.targetWeights) {
                    features.push("WEIGHT_COUNT " + mesh.targetWeights.length);
                    features.push("USE_MORPHING 1");
                }
            }
            if (geometry.joints) {
                features.push("HAS_JOINT_SET1 1");
            }
            if (geometry.weights) {
                features.push("HAS_WEIGHT_SET1 1");
            }
            if (mesh.skin) {
                addSkinningFeatures(mesh, features, renderer);
            }
            if (material.unlit) {
                features.push("MATERIAL_UNLIT 1");
            }
            features.push("MATERIAL_METALLICROUGHNESS 1");
            if (lightingEnvironment.lights.length > 0) {
                features.push("LIGHT_COUNT " + lightingEnvironment.lights.length);
                features.push("USE_PUNCTUAL 1");
            }
            if (lightingEnvironment.imageBasedLighting) {
                if (!lightingEnvironment.imageBasedLighting.valid) {
                    return undefined;
                }
                if (Capabilities.isShaderTextureLodSupported(renderer)) {
                    features.push("USE_TEX_LOD 1");
                }
                else {
                    exports.Debug.warn(Message.imageBasedLightingShaderTextureLodNotSupported);
                }
                features.push("USE_IBL 1");
            }
            if (material.shadowCastingLight) {
                features.push("USE_SHADOW_MAPPING 1");
            }
            if (material.baseColorTexture) {
                if (!material.baseColorTexture.valid) {
                    return undefined;
                }
                if (material.baseColorTexture.transform) {
                    features.push("HAS_BASECOLOR_UV_TRANSFORM 1");
                }
                features.push("HAS_BASE_COLOR_MAP 1");
            }
            if (material.emissiveTexture) {
                if (!material.emissiveTexture.valid) {
                    return undefined;
                }
                if (material.emissiveTexture.transform) {
                    features.push("HAS_EMISSIVE_UV_TRANSFORM 1");
                }
                features.push("HAS_EMISSIVE_MAP 1");
            }
            if (material.normalTexture) {
                if (!material.normalTexture.valid) {
                    return undefined;
                }
                if (material.normalTexture.transform) {
                    features.push("HAS_NORMAL_UV_TRANSFORM 1");
                }
                features.push("HAS_NORMAL_MAP 1");
            }
            if (material.metallicRoughnessTexture) {
                if (!material.metallicRoughnessTexture.valid) {
                    return undefined;
                }
                if (material.metallicRoughnessTexture.transform) {
                    features.push("HAS_METALLICROUGHNESS_UV_TRANSFORM 1");
                }
                features.push("HAS_METALLIC_ROUGHNESS_MAP 1");
            }
            if (material.occlusionTexture) {
                if (!material.occlusionTexture.valid) {
                    return undefined;
                }
                if (material.occlusionTexture.transform) {
                    features.push("HAS_OCCLUSION_UV_TRANSFORM 1");
                }
                features.push("HAS_OCCLUSION_MAP 1");
            }
            switch (material.alphaMode) {
                case exports.StandardMaterialAlphaMode.opaque: {
                    features.push("ALPHAMODE_OPAQUE 1");
                    break;
                }
                case exports.StandardMaterialAlphaMode.mask: {
                    features.push("ALPHAMODE_MASK 1");
                    break;
                }
            }
            if (material.debugMode) {
                features.push("DEBUG_OUTPUT 1");
            }
            switch (material.debugMode) {
                case exports.StandardMaterialDebugMode.alpha: {
                    features.push("DEBUG_ALPHA 1");
                    break;
                }
                case exports.StandardMaterialDebugMode.emissive: {
                    features.push("DEBUG_EMISSIVE 1");
                    break;
                }
                case exports.StandardMaterialDebugMode.f0: {
                    features.push("DEBUG_F0 1");
                    break;
                }
                case exports.StandardMaterialDebugMode.metallic: {
                    features.push("DEBUG_METALLIC 1");
                    break;
                }
                case exports.StandardMaterialDebugMode.normal: {
                    features.push("DEBUG_NORMAL 1");
                    break;
                }
                case exports.StandardMaterialDebugMode.occlusion: {
                    features.push("DEBUG_OCCLUSION 1");
                    break;
                }
                case exports.StandardMaterialDebugMode.roughness: {
                    features.push("DEBUG_ROUGHNESS 1");
                    break;
                }
            }
            return features;
        }
        StandardMaterialFeatureSet.build = build;
        function addSkinningFeatures(mesh, features, renderer) {
            if (!mesh.skin) {
                return;
            }
            var uniformsRequiredForOtherFeatures = 20;
            var availableVertexUniforms = Capabilities.getMaxVertexUniformVectors(renderer) - uniformsRequiredForOtherFeatures;
            var uniformsRequiredPerJoint = 8; // 4 per matrix times 2 (matrices and normals)
            var maxJointCount = Math.floor(availableVertexUniforms / uniformsRequiredPerJoint);
            var uniformsSupported = mesh.skin.joints.length <= maxJointCount;
            var addFeatureSetForUniforms = function () {
                var _a;
                features.push("USE_SKINNING 1");
                features.push("JOINT_COUNT " + ((_a = mesh.skin) === null || _a === void 0 ? void 0 : _a.joints.length));
            };
            var addFeatureSetForTextures = function () {
                var _a;
                features.push("USE_SKINNING 1");
                features.push("JOINT_COUNT " + ((_a = mesh.skin) === null || _a === void 0 ? void 0 : _a.joints.length));
                features.push("USE_SKINNING_TEXTURE 1");
            };
            // @ts-ignore Use PixiJS's already existing settings object for now.
            if (settings.settings.PREFER_UNIFORMS_WHEN_UPLOADING_SKIN_JOINTS) {
                if (uniformsSupported) {
                    addFeatureSetForUniforms();
                    return;
                }
                if (StandardMaterialMatrixTexture.isSupported(renderer)) {
                    addFeatureSetForTextures();
                    return;
                }
                else {
                    exports.Debug.error(Message.meshVertexSkinningNumberOfJointsNotSupported, {
                        joints: mesh.skin.joints.length,
                        maxJoints: maxJointCount
                    });
                }
            }
            else {
                if (StandardMaterialMatrixTexture.isSupported(renderer)) {
                    addFeatureSetForTextures();
                    return;
                }
                exports.Debug.warn(Message.meshVertexSkinningFloatingPointTexturesNotSupported);
                if (uniformsSupported) {
                    addFeatureSetForUniforms();
                }
                else {
                    exports.Debug.error(Message.meshVertexSkinningNumberOfJointsNotSupported, {
                        joints: mesh.skin.joints.length,
                        maxJoints: maxJointCount
                    });
                }
            }
        }
        function hasSkinningTextureFeature(features) {
            return features.includes("USE_SKINNING_TEXTURE 1");
        }
        StandardMaterialFeatureSet.hasSkinningTextureFeature = hasSkinningTextureFeature;
    })(StandardMaterialFeatureSet || (StandardMaterialFeatureSet = {}));

    /**
     * Shader used specifically to render a mesh.
     */
    var MeshShader = /** @class */ (function (_super) {
        __extends(MeshShader, _super);
        function MeshShader() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._state = Object.assign(new PixiCore.State(), {
                culling: true, clockwiseFrontFace: false, depthTest: true
            });
            return _this;
        }
        Object.defineProperty(MeshShader.prototype, "name", {
            /** The name of the mesh shader. Used for figuring out if geometry attributes is compatible with the shader. This needs to be set to something different than default value when custom attributes is used. */
            get: function () {
                return "mesh-shader";
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Creates geometry with required attributes used by this shader. Override when using custom attributes.
         * @param geometry The geometry with mesh data.
         * @param instanced Value indicating if the geometry will be instanced.
         */
        MeshShader.prototype.createShaderGeometry = function (geometry, instanced) {
            var result = new PixiCore.Geometry();
            if (geometry.indices) {
                if (geometry.indices.buffer.BYTES_PER_ELEMENT === 1) {
                    // PixiJS seems to have problems with Uint8Array, let's convert to UNSIGNED_SHORT.
                    result.addIndex(new PixiCore.Buffer(new Uint16Array(geometry.indices.buffer)));
                }
                else {
                    result.addIndex(new PixiCore.Buffer(geometry.indices.buffer));
                }
            }
            if (geometry.positions) {
                result.addAttribute("a_Position", new PixiCore.Buffer(geometry.positions.buffer), 3, false, geometry.positions.componentType, geometry.positions.stride);
            }
            if (geometry.uvs && geometry.uvs[0]) {
                result.addAttribute("a_UV1", new PixiCore.Buffer(geometry.uvs[0].buffer), 2, false, geometry.uvs[0].componentType, geometry.uvs[0].stride);
            }
            if (geometry.normals) {
                result.addAttribute("a_Normal", new PixiCore.Buffer(geometry.normals.buffer), 3, false, geometry.normals.componentType, geometry.normals.stride);
            }
            if (geometry.tangents) {
                result.addAttribute("a_Tangent", new PixiCore.Buffer(geometry.tangents.buffer), 4, false, geometry.tangents.componentType, geometry.tangents.stride);
            }
            if (geometry.colors) {
                result.addAttribute("a_Color", new PixiCore.Buffer(geometry.colors.buffer), 4, true, geometry.colors.componentType, geometry.colors.stride);
            }
            return result;
        };
        /**
         * Renders the geometry of the specified mesh.
         * @param mesh Mesh to render.
         * @param renderer Renderer to use.
         * @param state Rendering state to use.
         * @param drawMode Draw mode to use.
         */
        MeshShader.prototype.render = function (mesh, renderer, state, drawMode) {
            if (state === void 0) { state = this._state; }
            if (drawMode === void 0) { drawMode = constants.DRAW_MODES.TRIANGLES; }
            var instanceCount = mesh.instances.filter(function (i) {
                return i.worldVisible && i.renderable;
            }).length;
            var instancing = mesh.instances.length > 0;
            if (!mesh.geometry.hasShaderGeometry(this, instancing)) {
                mesh.geometry.addShaderGeometry(this, instancing);
            }
            var geometry = mesh.geometry.getShaderGeometry(this);
            renderer.shader.bind(this, false);
            renderer.state.set(state);
            renderer.geometry.bind(geometry, this);
            renderer.geometry.draw(drawMode, undefined, undefined, instanceCount);
        };
        return MeshShader;
    }(PixiCore.Shader));

    var StandardShaderInstancing = /** @class */ (function () {
        function StandardShaderInstancing() {
            this._maxInstances = 200;
            this._modelMatrix = [
                new PixiCore.Buffer(), new PixiCore.Buffer(), new PixiCore.Buffer(), new PixiCore.Buffer()
            ];
            this._normalMatrix = [
                new PixiCore.Buffer(), new PixiCore.Buffer(), new PixiCore.Buffer(), new PixiCore.Buffer()
            ];
            this._baseColor = new PixiCore.Buffer();
            this.expandBuffers(this._maxInstances);
        }
        StandardShaderInstancing.prototype.expandBuffers = function (instanceCount) {
            while (instanceCount > this._maxInstances) {
                this._maxInstances += Math.floor(this._maxInstances * 0.5);
            }
            for (var i = 0; i < 4; i++) {
                this._modelMatrix[i].update(new Float32Array(4 * this._maxInstances));
                this._normalMatrix[i].update(new Float32Array(4 * this._maxInstances));
            }
            this._baseColor.update(new Float32Array(4 * this._maxInstances));
        };
        StandardShaderInstancing.prototype.updateBuffers = function (instances) {
            if (instances.length > this._maxInstances) {
                this.expandBuffers(instances.length);
            }
            var bufferIndex = 0;
            for (var i = 0; i < instances.length; i++) {
                var normal = instances[i].transform.normalTransform.array;
                for (var j = 0; j < 4; j++) {
                    this._normalMatrix[j].data
                        .set(normal.slice(j * 4, j * 4 + 4), bufferIndex * 4);
                }
                var model = instances[i].worldTransform.array;
                for (var j = 0; j < 4; j++) {
                    this._modelMatrix[j].data
                        .set(model.slice(j * 4, j * 4 + 4), bufferIndex * 4);
                }
                var material = instances[i].material;
                this._baseColor.data
                    .set(material.baseColor.rgba, bufferIndex * 4);
                bufferIndex++;
            }
            for (var i = 0; i < 4; i++) {
                this._modelMatrix[i].update();
                this._normalMatrix[i].update();
            }
            this._baseColor.update();
        };
        StandardShaderInstancing.prototype.addGeometryAttributes = function (geometry) {
            for (var i = 0; i < 4; i++) {
                geometry.addAttribute("a_ModelMatrix" + i, this._modelMatrix[i], 4, false, undefined, 0, undefined, true);
            }
            for (var i = 0; i < 4; i++) {
                geometry.addAttribute("a_NormalMatrix" + i, this._normalMatrix[i], 4, false, undefined, 0, undefined, true);
            }
            geometry.addAttribute("a_BaseColorFactor", this._baseColor, 4, false, undefined, 0, undefined, true);
        };
        return StandardShaderInstancing;
    }());

    var StandardShaderSource;
    (function (StandardShaderSource) {
        function build(source, features, renderer) {
            if (renderer.context.webGLVersion === 1) {
                source = source.replace(/VERSION/, "100")
                    .replace(/VERT_IN/g, "attribute")
                    .replace(/VERT_OUT/g, "varying")
                    .replace(/FRAG_COLOR/g, "gl_FragColor")
                    .replace(/FRAG_IN/g, "varying");
            }
            if (renderer.context.webGLVersion === 2) {
                source = source.replace(/VERSION/, "300 es")
                    .replace(/VERT_IN/g, "in")
                    .replace(/VERT_OUT/g, "out")
                    .replace(/FRAG_COLOR/g, "g_finalColor")
                    .replace(/FRAG_IN/g, "in");
            }
            return source.replace(/#define FEATURES/, features.map(function (value) { return "#define " + value; }).join("\n"));
        }
        StandardShaderSource.build = build;
    })(StandardShaderSource || (StandardShaderSource = {}));

    var Shader$b = {"source":"#version VERSION\n\n//\n// This fragment shader defines a reference implementation for Physically Based Shading of\n// a microfacet surface material defined by a glTF model.\n//\n// References:\n// [1] Real Shading in Unreal Engine 4\n//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// [2] Physically Based Shading at Disney\n//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// [3] README.md - Environment Maps\n//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps\n// [4] \"An Inexpensive BRDF Model for Physically based Rendering\" by Christophe Schlick\n//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n\n#define FEATURES\n\n#if defined(WEBGL1) //&& defined(USE_TEX_LOD)\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n\n#if defined(WEBGL1)\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n#if defined(WEBGL1) && defined(USE_HDR)\n#extension GL_OES_texture_float : enable\n#extension GL_OES_texture_float_linear : enable\n#endif\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvec4 _texture(sampler2D sampler, vec2 coord)\n{\n#ifdef WEBGL2\n    return texture(sampler, coord);\n#else\n    return texture2D(sampler, coord);\n#endif\n}\n\nvec4 _texture(samplerCube sampler, vec3 coord)\n{\n#ifdef WEBGL2\n    return texture(sampler, coord);\n#else\n    return textureCube(sampler, coord);\n#endif\n}\nvec4 _textureLod(sampler2D sampler, vec2 coord, float lod)\n{\n#ifdef WEBGL2\n    return textureLod(sampler, coord, lod);\n#endif\n#if defined(WEBGL1) && defined(GL_EXT_shader_texture_lod) \n    return texture2DLodEXT(sampler, coord, lod);\n#endif\n    return vec4(0.0);\n}\n\nvec4 _textureLod(samplerCube sampler, vec3 coord, float lod)\n{\n#ifdef WEBGL2\n    return textureLod(sampler, coord, lod);\n#endif\n#if defined(WEBGL1) && defined(GL_EXT_shader_texture_lod) \n    return textureCubeLodEXT(sampler, coord, lod);\n#endif\n    return vec4(0.0);\n}\nvec3 _dFdx(vec3 coord)\n{\n#if defined(WEBGL2) || defined(GL_OES_standard_derivatives)\n    return dFdx(coord);\n#endif\n    return vec3(0.0);\n}\n\nvec3 _dFdy(vec3 coord)\n{\n#if defined(WEBGL2) || defined(GL_OES_standard_derivatives)\n    return dFdy(coord);\n#endif\n    return vec3(0.0);\n}\nFRAG_IN vec2 v_UVCoord1;\nFRAG_IN vec2 v_UVCoord2;\n\n// General Material\n#ifdef HAS_NORMAL_MAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\nuniform int u_NormalUVSet;\nuniform mat3 u_NormalUVTransform;\n#endif\n\n#ifdef HAS_EMISSIVE_MAP\nuniform sampler2D u_EmissiveSampler;\nuniform int u_EmissiveUVSet;\nuniform vec3 u_EmissiveFactor;\nuniform mat3 u_EmissiveUVTransform;\n#endif\n\n#ifdef HAS_OCCLUSION_MAP\nuniform sampler2D u_OcclusionSampler;\nuniform int u_OcclusionUVSet;\nuniform float u_OcclusionStrength;\nuniform mat3 u_OcclusionUVTransform;\n#endif\n\n// Metallic Roughness Material\n#ifdef HAS_BASE_COLOR_MAP\nuniform sampler2D u_BaseColorSampler;\nuniform int u_BaseColorUVSet;\nuniform mat3 u_BaseColorUVTransform;\n#endif\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\nuniform sampler2D u_MetallicRoughnessSampler;\nuniform int u_MetallicRoughnessUVSet;\nuniform mat3 u_MetallicRoughnessUVTransform;\n#endif\n\n// Specular Glossiness Material\n#ifdef HAS_DIFFUSE_MAP\nuniform sampler2D u_DiffuseSampler;\nuniform int u_DiffuseUVSet;\nuniform mat3 u_DiffuseUVTransform;\n#endif\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\nuniform sampler2D u_SpecularGlossinessSampler;\nuniform int u_SpecularGlossinessUVSet;\nuniform mat3 u_SpecularGlossinessUVTransform;\n#endif\n\n// IBL\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\n#endif\n\n#ifdef USE_SHADOW_MAPPING\nuniform sampler2D u_ShadowSampler;\n#endif\n\nvec2 getNormalUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_NORMAL_MAP\n    uv.xy = u_NormalUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_NORMAL_UV_TRANSFORM\n    uv = u_NormalUVTransform * uv;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getEmissiveUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_EMISSIVE_MAP\n    uv.xy = u_EmissiveUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_EMISSIVE_UV_TRANSFORM\n    uv = u_EmissiveUVTransform * uv;\n    #endif\n#endif\n\n    return uv.xy;\n}\n\nvec2 getOcclusionUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_OCCLUSION_MAP\n    uv.xy = u_OcclusionUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_OCCLUSION_UV_TRANSFORM\n    uv = u_OcclusionUVTransform * uv;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getBaseColorUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_BASE_COLOR_MAP\n    uv.xy = u_BaseColorUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_BASECOLOR_UV_TRANSFORM\n    uv = u_BaseColorUVTransform * uv;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getMetallicRoughnessUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    uv.xy = u_MetallicRoughnessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_METALLICROUGHNESS_UV_TRANSFORM\n    uv = u_MetallicRoughnessUVTransform * uv;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getSpecularGlossinessUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    uv.xy = u_SpecularGlossinessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_SPECULARGLOSSINESS_UV_TRANSFORM\n    uv = u_SpecularGlossinessUVTransform * uv;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getDiffuseUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_DIFFUSE_MAP\n    uv.xy = u_DiffuseUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_DIFFUSE_UV_TRANSFORM\n    uv = u_DiffuseUVTransform * uv;\n    #endif\n#endif\n    return uv.xy;\n}\n\n// textures.glsl needs to be included\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinReflectance = 0.04;\n\nFRAG_IN vec3 v_Position;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nFRAG_IN mat3 v_TBN;\n#else\nFRAG_IN vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_VERTEX_COLOR_VEC3\nFRAG_IN vec3 v_Color;\n#endif\n#ifdef HAS_VERTEX_COLOR_VEC4\nFRAG_IN vec4 v_Color;\n#endif\n\nstruct AngularInfo\n{\n    float NdotL;                  // cos angle between normal and light direction\n    float NdotV;                  // cos angle between normal and view direction\n    float NdotH;                  // cos angle between normal and half vector\n    float LdotH;                  // cos angle between light direction and half vector\n\n    float VdotH;                  // cos angle between view direction and half vector\n\n    vec3 padding;\n};\n\nvec4 getVertexColor()\n{\n   vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n\n#ifdef HAS_VERTEX_COLOR_VEC3\n    color.rgb = v_Color;\n#endif\n#ifdef HAS_VERTEX_COLOR_VEC4\n    color = v_Color;\n#endif\n\n   return color;\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n    vec2 UV = getNormalUV();\n\n    // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n    vec3 pos_dx = _dFdx(v_Position);\n    vec3 pos_dy = _dFdy(v_Position);\n    vec3 tex_dx = _dFdx(vec3(UV, 0.0));\n    vec3 tex_dy = _dFdy(vec3(UV, 0.0));\n    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n    vec3 ng = normalize(v_Normal);\n#else\n    vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n    t = normalize(t - ng * dot(ng, t));\n    vec3 b = normalize(cross(ng, t));\n    mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n    mat3 tbn = v_TBN;\n#endif\n\n#ifdef HAS_NORMAL_MAP\n    vec3 n = _texture(u_NormalSampler, UV).rgb;\n    n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n    // The tbn matrix is linearly interpolated, so we need to re-normalize\n    vec3 n = normalize(tbn[2].xyz);\n#endif\n\n    return n;\n}\n\nfloat getPerceivedBrightness(vec3 vector)\n{\n    return sqrt(0.299 * vector.r * vector.r + 0.587 * vector.g * vector.g + 0.114 * vector.b * vector.b);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows/js/three.pbrUtilities.js#L34\nfloat solveMetallic(vec3 diffuse, vec3 specular, float oneMinusSpecularStrength) {\n    float specularBrightness = getPerceivedBrightness(specular);\n\n    if (specularBrightness < c_MinReflectance) {\n        return 0.0;\n    }\n\n    float diffuseBrightness = getPerceivedBrightness(diffuse);\n\n    float a = c_MinReflectance;\n    float b = diffuseBrightness * oneMinusSpecularStrength / (1.0 - c_MinReflectance) + specularBrightness - 2.0 * c_MinReflectance;\n    float c = c_MinReflectance - specularBrightness;\n    float D = b * b - 4.0 * a * c;\n\n    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);\n}\n\nAngularInfo getAngularInfo(vec3 pointToLight, vec3 normal, vec3 view)\n{\n    // Standard one-letter names\n    vec3 n = normalize(normal);           // Outward direction of surface point\n    vec3 v = normalize(view);             // Direction from surface point to view\n    vec3 l = normalize(pointToLight);     // Direction from surface point to light\n    vec3 h = normalize(l + v);            // Direction of the vector between l and v\n\n    float NdotL = clamp(dot(n, l), 0.0, 1.0);\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n    return AngularInfo(\n        NdotL,\n        NdotV,\n        NdotH,\n        LdotH,\n        VdotH,\n        vec3(0, 0, 0)\n    );\n}\n\n#ifdef USE_SHADOW_MAPPING\nFRAG_IN vec4 v_PositionLightSpace;\n#endif\n\nfloat linstep(float low, float high, float v)\n{\n    return clamp((v-low) / (high-low), 0.0, 1.0);\n}\n\n#ifdef USE_SHADOW_MAPPING\nfloat getShadowContribution()\n{\n    vec3 coords = v_PositionLightSpace.xyz / v_PositionLightSpace.w * 0.5 + 0.5;\n    if (coords.z < 0.01 || coords.z > 0.99 || coords.x < 0.01 || coords.x > 0.99 || coords.y < 0.01 || coords.y > 0.99) {\n        return 1.0;\n    }\n    vec2 moments = vec2(1.0) - _texture(u_ShadowSampler, coords.xy).xy;\n    float p = step(coords.z, moments.x);\n    float variance = max(moments.y - moments.x * moments.x, 0.00002);\n    float d = coords.z - moments.x;\n    float pMax = linstep(0.2, 1.0, variance / (variance + d*d));\n    return min(max(p, pMax), 1.0);\n}\n#endif\nuniform float u_Exposure;\n\nconst float GAMMA = 2.2;\nconst float INV_GAMMA = 1.0 / GAMMA;\n\n// linear to sRGB approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec3 LINEARtoSRGB(vec3 color)\n{\n    return pow(color, vec3(INV_GAMMA));\n}\n\n// sRGB to linear approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n    return vec4(pow(srgbIn.xyz, vec3(GAMMA)), srgbIn.w);\n}\n\n// Uncharted 2 tone map\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 toneMapUncharted2Impl(vec3 color)\n{\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    return ((color*(A*color+C*B)+D*E)/(color*(A*color+B)+D*F))-E/F;\n}\n\nvec3 toneMapUncharted(vec3 color)\n{\n    const float W = 11.2;\n    color = toneMapUncharted2Impl(color * 2.0);\n    vec3 whiteScale = 1.0 / toneMapUncharted2Impl(vec3(W));\n    return LINEARtoSRGB(color * whiteScale);\n}\n\n// Hejl Richard tone map\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 toneMapHejlRichard(vec3 color)\n{\n    color = max(vec3(0.0), color - vec3(0.004));\n    return (color*(6.2*color+.5))/(color*(6.2*color+1.7)+0.06);\n}\n\n// ACES tone map\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 toneMapACES(vec3 color)\n{\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return LINEARtoSRGB(clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0));\n}\n\nvec3 toneMap(vec3 color)\n{\n    color *= u_Exposure;\n\n#ifdef TONEMAP_UNCHARTED\n    return toneMapUncharted(color);\n#endif\n\n#ifdef TONEMAP_HEJLRICHARD\n    return toneMapHejlRichard(color);\n#endif\n\n#ifdef TONEMAP_ACES\n    return toneMapACES(color);\n#endif\n\n    return LINEARtoSRGB(color);\n}\n\n\n// KHR_lights_punctual extension.\n// see https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\nstruct Light\n{\n    vec3 direction;\n    float range;\n\n    vec3 color;\n    float intensity;\n\n    vec3 position;\n    float innerConeCos;\n\n    float outerConeCos;\n    int type;\n\n    vec2 padding;\n};\n\nconst int LightType_Directional = 0;\nconst int LightType_Point = 1;\nconst int LightType_Spot = 2;\n\n#ifdef USE_PUNCTUAL\nuniform Light u_Lights[LIGHT_COUNT];\n#endif\n\n#if defined(MATERIAL_SPECULARGLOSSINESS) || defined(MATERIAL_METALLICROUGHNESS)\nuniform float u_MetallicFactor;\nuniform float u_RoughnessFactor;\nuniform vec4 u_BaseColorFactor;\n#endif\n\n#ifdef USE_INSTANCING\nFRAG_IN vec4 v_BaseColorFactor;\n#endif\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\nuniform vec3 u_SpecularFactor;\nuniform vec4 u_DiffuseFactor;\nuniform float u_GlossinessFactor;\n#endif\n\n#ifdef ALPHAMODE_MASK\nuniform float u_AlphaCutoff;\n#endif\n\n#ifdef USE_SHADOW_MAPPING\nuniform int u_ShadowLightIndex;\n#endif\n\nuniform vec3 u_Camera;\n\nuniform int u_MipCount;\n\nstruct MaterialInfo\n{\n    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n    vec3 reflectance0;            // full reflectance color (normal incidence angle)\n\n    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n    vec3 diffuseColor;            // color contribution from diffuse lighting\n\n    vec3 reflectance90;           // reflectance color at grazing angle\n    vec3 specularColor;           // color contribution from specular lighting\n};\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(MaterialInfo materialInfo, vec3 n, vec3 v)\n{\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n\n    float lod = clamp(materialInfo.perceptualRoughness * float(u_MipCount), 0.0, float(u_MipCount));\n    vec3 reflection = normalize(reflect(-v, n));\n\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, materialInfo.perceptualRoughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    // retrieve a scale and bias to F0. See [1], Figure 3\n    vec2 brdf = _texture(u_brdfLUT, brdfSamplePoint).rg;\n\n    vec4 diffuseSample = _texture(u_DiffuseEnvSampler, n);\n\n#ifdef USE_TEX_LOD\n    vec4 specularSample = _textureLod(u_SpecularEnvSampler, reflection, lod);\n#else\n    vec4 specularSample = _texture(u_SpecularEnvSampler, reflection);\n#endif\n\n#ifdef USE_HDR\n    // Already linear.\n    vec3 diffuseLight = diffuseSample.rgb;\n    vec3 specularLight = specularSample.rgb;\n#else\n    vec3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb;\n    vec3 specularLight = SRGBtoLINEAR(specularSample).rgb;\n#endif\n\n    vec3 diffuse = diffuseLight * materialInfo.diffuseColor;\n    vec3 specular = specularLight * (materialInfo.specularColor * brdf.x + brdf.y);\n\n    return diffuse + specular;\n}\n#endif\n\n// Lambert lighting\n// see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\nvec3 diffuse(MaterialInfo materialInfo)\n{\n    return materialInfo.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    return materialInfo.reflectance0 + (materialInfo.reflectance90 - materialInfo.reflectance0) * pow(clamp(1.0 - angularInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// Smith Joint GGX\n// Note: Vis = G / (4 * NdotL * NdotV)\n// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\n// see Real-Time Rendering. Page 331 to 336.\n// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\nfloat visibilityOcclusion(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    float NdotL = angularInfo.NdotL;\n    float NdotV = angularInfo.NdotV;\n    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\n\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n\n    float GGX = GGXV + GGXL;\n    if (GGX > 0.0)\n    {\n        return 0.5 / GGX;\n    }\n    return 0.0;\n}\n\n// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\n    float f = (angularInfo.NdotH * alphaRoughnessSq - angularInfo.NdotH) * angularInfo.NdotH + 1.0;\n    return alphaRoughnessSq / (M_PI * f * f);\n}\n\nvec3 getPointShade(vec3 pointToLight, MaterialInfo materialInfo, vec3 normal, vec3 view)\n{\n    AngularInfo angularInfo = getAngularInfo(pointToLight, normal, view);\n\n    if (angularInfo.NdotL > 0.0 || angularInfo.NdotV > 0.0)\n    {\n        // Calculate the shading terms for the microfacet specular shading model\n        vec3 F = specularReflection(materialInfo, angularInfo);\n        float Vis = visibilityOcclusion(materialInfo, angularInfo);\n        float D = microfacetDistribution(materialInfo, angularInfo);\n\n        // Calculation of analytical lighting contribution\n        vec3 diffuseContrib = (1.0 - F) * diffuse(materialInfo);\n        vec3 specContrib = F * Vis * D;\n\n        // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n        return angularInfo.NdotL * (diffuseContrib + specContrib);\n    }\n\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(float range, float distance)\n{\n    if (range <= 0.0)\n    {\n        // negative range means unlimited\n        return 1.0;\n    }\n    return max(min(1.0 - pow(distance / range, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(vec3 pointToLight, vec3 spotDirection, float outerConeCos, float innerConeCos)\n{\n    float actualCos = dot(normalize(spotDirection), normalize(-pointToLight));\n    if (actualCos > outerConeCos)\n    {\n        if (actualCos < innerConeCos)\n        {\n            return smoothstep(outerConeCos, innerConeCos, actualCos);\n        }\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvec3 applyDirectionalLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)\n{\n    vec3 pointToLight = -light.direction;\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;\n    return light.intensity * light.color * shade;\n}\n\nvec3 applyPointLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view)\n{\n    vec3 pointToLight = light.position - v_Position;\n    float distance = length(pointToLight);\n    float attenuation = getRangeAttenuation(light.range, distance);\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view);\n    return attenuation * light.intensity * light.color * shade;\n}\n\nvec3 applySpotLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)\n{\n    vec3 pointToLight = light.position - v_Position;\n    float distance = length(pointToLight);\n    float rangeAttenuation = getRangeAttenuation(light.range, distance);\n    float spotAttenuation = getSpotAttenuation(pointToLight, light.direction, light.outerConeCos, light.innerConeCos);\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;\n    return rangeAttenuation * spotAttenuation * light.intensity * light.color * shade;\n}\n\n#ifdef WEBGL2\n    out vec4 FRAG_COLOR;\n#endif\n\nvoid main()\n{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = 0.0;\n    float metallic = 0.0;\n    vec4 baseColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 diffuseColor = vec3(0.0);\n    vec3 specularColor= vec3(0.0);\n    vec3 f0 = vec3(0.04);\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    vec4 sgSample = SRGBtoLINEAR(_texture(u_SpecularGlossinessSampler, getSpecularGlossinessUV()));\n    perceptualRoughness = (1.0 - sgSample.a * u_GlossinessFactor); // glossiness to roughness\n    f0 = sgSample.rgb * u_SpecularFactor; // specular\n#else\n    f0 = u_SpecularFactor;\n    perceptualRoughness = 1.0 - u_GlossinessFactor;\n#endif // ! HAS_SPECULAR_GLOSSINESS_MAP\n\n#ifdef HAS_DIFFUSE_MAP\n    baseColor = SRGBtoLINEAR(_texture(u_DiffuseSampler, getDiffuseUV())) * u_DiffuseFactor;\n#else\n    baseColor = u_DiffuseFactor;\n#endif // !HAS_DIFFUSE_MAP\n\n    baseColor *= getVertexColor();\n\n    // f0 = specular\n    specularColor = f0;\n    float oneMinusSpecularStrength = 1.0 - max(max(f0.r, f0.g), f0.b);\n    diffuseColor = baseColor.rgb * oneMinusSpecularStrength;\n\n#ifdef DEBUG_METALLIC\n    // do conversion between metallic M-R and S-G metallic\n    metallic = solveMetallic(baseColor.rgb, specularColor, oneMinusSpecularStrength);\n#endif // ! DEBUG_METALLIC\n\n#endif // ! MATERIAL_SPECULARGLOSSINESS\n\n#ifdef MATERIAL_METALLICROUGHNESS\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = _texture(u_MetallicRoughnessSampler, getMetallicRoughnessUV());\n    perceptualRoughness = mrSample.g * u_RoughnessFactor;\n    metallic = mrSample.b * u_MetallicFactor;\n#else\n    metallic = u_MetallicFactor;\n    perceptualRoughness = u_RoughnessFactor;\n#endif\n\n    vec4 baseColorFactor = u_BaseColorFactor;\n#ifdef USE_INSTANCING\n    baseColorFactor = v_BaseColorFactor;\n#endif\n\n    // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASE_COLOR_MAP\n    baseColor = SRGBtoLINEAR(_texture(u_BaseColorSampler, getBaseColorUV())) * baseColorFactor;\n#else\n    baseColor = baseColorFactor;\n#endif\n\n    baseColor *= getVertexColor();\n\n    diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);\n\n    specularColor = mix(f0, baseColor.rgb, metallic);\n\n#endif // ! MATERIAL_METALLICROUGHNESS\n\n#ifdef ALPHAMODE_MASK\n    if(baseColor.a < u_AlphaCutoff)\n    {\n        discard;\n    }\n    baseColor.a = 1.0;\n#endif\n\n#ifdef ALPHAMODE_OPAQUE\n    baseColor.a = 1.0;\n#endif\n\n#ifdef MATERIAL_UNLIT\n    FRAG_COLOR = vec4(LINEARtoSRGB(baseColor.rgb) * baseColor.a, baseColor.a);\n    return;\n#endif\n\n    perceptualRoughness = clamp(perceptualRoughness, 0.0, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to \"Real-Time-Rendering\" 4th editon on page 325.\n    vec3 specularEnvironmentR90 = vec3(clamp(reflectance * 50.0, 0.0, 1.0));\n\n    MaterialInfo materialInfo = MaterialInfo(\n        perceptualRoughness,\n        specularEnvironmentR0,\n        alphaRoughness,\n        diffuseColor,\n        specularEnvironmentR90,\n        specularColor\n    );\n\n    // LIGHTING\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 normal = getNormal();\n    vec3 view = normalize(u_Camera - v_Position);\n\n    float shadow = 1.0;\n    #ifdef USE_SHADOW_MAPPING\n        shadow = getShadowContribution();\n    #endif\n\n#ifdef USE_PUNCTUAL\n    for (int i = 0; i < LIGHT_COUNT; ++i)\n    {\n        float shadowContribution = shadow;\n        #ifdef USE_SHADOW_MAPPING\n        if (u_ShadowLightIndex != i) \n        {\n            shadowContribution = 1.0;\n        }\n        #endif\n        Light light = u_Lights[i];\n        if (light.type == LightType_Directional)\n        {\n            color += applyDirectionalLight(light, materialInfo, normal, view, shadowContribution);\n        }\n        else if (light.type == LightType_Point)\n        {\n            color += applyPointLight(light, materialInfo, normal, view);\n        }\n        else if (light.type == LightType_Spot)\n        {\n            color += applySpotLight(light, materialInfo, normal, view, shadowContribution);\n        }\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    color += getIBLContribution(materialInfo, normal, view);\n#endif\n\n    float ao = 1.0;\n    // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSION_MAP\n    ao = _texture(u_OcclusionSampler,  getOcclusionUV()).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n    vec3 emissive = vec3(0);\n#ifdef HAS_EMISSIVE_MAP\n    emissive = SRGBtoLINEAR(_texture(u_EmissiveSampler, getEmissiveUV())).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifndef DEBUG_OUTPUT // no debug\n\n   // regular shading\n    FRAG_COLOR = vec4(toneMap(color) * baseColor.a, baseColor.a);\n\n#else // debug output\n\n    #ifdef DEBUG_METALLIC\n        FRAG_COLOR.rgb = vec3(metallic);\n    #endif\n\n    #ifdef DEBUG_ROUGHNESS\n        FRAG_COLOR.rgb = vec3(perceptualRoughness);\n    #endif\n\n    #ifdef DEBUG_NORMAL\n        #ifdef HAS_NORMAL_MAP\n            FRAG_COLOR.rgb = _texture(u_NormalSampler, getNormalUV()).rgb;\n        #else\n            FRAG_COLOR.rgb = vec3(0.5, 0.5, 1.0);\n        #endif\n    #endif\n\n    #ifdef DEBUG_BASECOLOR\n        FRAG_COLOR.rgb = LINEARtoSRGB(baseColor.rgb);\n    #endif\n\n    #ifdef DEBUG_OCCLUSION\n        FRAG_COLOR.rgb = vec3(ao);\n    #endif\n\n    #ifdef DEBUG_EMISSIVE\n        FRAG_COLOR.rgb = LINEARtoSRGB(emissive);\n    #endif\n\n    #ifdef DEBUG_F0\n        FRAG_COLOR.rgb = vec3(f0);\n    #endif\n\n    #ifdef DEBUG_ALPHA\n        FRAG_COLOR.rgb = vec3(baseColor.a);\n    #endif\n\n    FRAG_COLOR.a = 1.0;\n\n#endif // !DEBUG_OUTPUT\n}\n"};

    var Shader$a = {"source":"#version VERSION\n\n#define FEATURES\n\nvec4 _texture(sampler2D sampler, vec2 coord)\n{\n#ifdef WEBGL2\n    return texture(sampler, coord);\n#else\n    return texture2D(sampler, coord);\n#endif\n}\n\nvec4 _texture(samplerCube sampler, vec3 coord)\n{\n#ifdef WEBGL2\n    return texture(sampler, coord);\n#else\n    return textureCube(sampler, coord);\n#endif\n}\n#ifdef HAS_TARGET_POSITION0\nVERT_IN vec3 a_Target_Position0;\n#endif\n\n#ifdef HAS_TARGET_POSITION1\nVERT_IN vec3 a_Target_Position1;\n#endif\n\n#ifdef HAS_TARGET_POSITION2\nVERT_IN vec3 a_Target_Position2;\n#endif\n\n#ifdef HAS_TARGET_POSITION3\nVERT_IN vec3 a_Target_Position3;\n#endif\n\n#ifdef HAS_TARGET_POSITION4\nVERT_IN vec3 a_Target_Position4;\n#endif\n\n#ifdef HAS_TARGET_POSITION5\nVERT_IN vec3 a_Target_Position5;\n#endif\n\n#ifdef HAS_TARGET_POSITION6\nVERT_IN vec3 a_Target_Position6;\n#endif\n\n#ifdef HAS_TARGET_POSITION7\nVERT_IN vec3 a_Target_Position7;\n#endif\n\n#ifdef HAS_TARGET_NORMAL0\nVERT_IN vec3 a_Target_Normal0;\n#endif\n\n#ifdef HAS_TARGET_NORMAL1\nVERT_IN vec3 a_Target_Normal1;\n#endif\n\n#ifdef HAS_TARGET_NORMAL2\nVERT_IN vec3 a_Target_Normal2;\n#endif\n\n#ifdef HAS_TARGET_NORMAL3\nVERT_IN vec3 a_Target_Normal3;\n#endif\n\n#ifdef HAS_TARGET_TANGENT0\nVERT_IN vec3 a_Target_Tangent0;\n#endif\n\n#ifdef HAS_TARGET_TANGENT1\nVERT_IN vec3 a_Target_Tangent1;\n#endif\n\n#ifdef HAS_TARGET_TANGENT2\nVERT_IN vec3 a_Target_Tangent2;\n#endif\n\n#ifdef HAS_TARGET_TANGENT3\nVERT_IN vec3 a_Target_Tangent3;\n#endif\n\n#ifdef USE_MORPHING\nuniform float u_morphWeights[WEIGHT_COUNT];\n#endif\n\n#ifdef HAS_JOINT_SET1\nVERT_IN vec4 a_Joint1;\n#endif\n\n#ifdef HAS_JOINT_SET2\nVERT_IN vec4 a_Joint2;\n#endif\n\n#ifdef HAS_WEIGHT_SET1\nVERT_IN vec4 a_Weight1;\n#endif\n\n#ifdef HAS_WEIGHT_SET2\nVERT_IN vec4 a_Weight2;\n#endif\n\n#ifdef USE_SKINNING\n#ifdef USE_SKINNING_TEXTURE\nuniform sampler2D u_jointMatrixSampler;\nuniform sampler2D u_jointNormalMatrixSampler;\n#else\nuniform mat4 u_jointMatrix[JOINT_COUNT];\nuniform mat4 u_jointNormalMatrix[JOINT_COUNT];\n#endif\n#endif\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.0)\n#define ROW1_U ((0.5 + 1.0) / 4.0)\n#define ROW2_U ((0.5 + 2.0) / 4.0)\n#define ROW3_U ((0.5 + 3.0) / 4.0)\n\n#ifdef USE_SKINNING\nmat4 getJointMatrix(float boneNdx) {\n    #ifdef USE_SKINNING_TEXTURE\n    float v = (boneNdx + 0.5) / float(JOINT_COUNT);\n    return mat4(\n        _texture(u_jointMatrixSampler, vec2(ROW0_U, v)),\n        _texture(u_jointMatrixSampler, vec2(ROW1_U, v)),\n        _texture(u_jointMatrixSampler, vec2(ROW2_U, v)),\n        _texture(u_jointMatrixSampler, vec2(ROW3_U, v))\n    );\n    #else\n    return u_jointMatrix[int(boneNdx)];\n    #endif\n}\n\nmat4 getJointNormalMatrix(float boneNdx) {\n    #ifdef USE_SKINNING_TEXTURE\n    float v = (boneNdx + 0.5) / float(JOINT_COUNT);\n    return mat4(\n        _texture(u_jointNormalMatrixSampler, vec2(ROW0_U, v)),\n        _texture(u_jointNormalMatrixSampler, vec2(ROW1_U, v)),\n        _texture(u_jointNormalMatrixSampler, vec2(ROW2_U, v)),\n        _texture(u_jointNormalMatrixSampler, vec2(ROW3_U, v))\n    );\n    #else\n    return u_jointNormalMatrix[int(boneNdx)];\n    #endif\n}\n\nmat4 getSkinningMatrix()\n{\n    mat4 skin = mat4(0);\n\n    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)\n    skin +=\n        a_Weight1.x * getJointMatrix(a_Joint1.x) +\n        a_Weight1.y * getJointMatrix(a_Joint1.y) +\n        a_Weight1.z * getJointMatrix(a_Joint1.z) +\n        a_Weight1.w * getJointMatrix(a_Joint1.w);\n    #endif\n\n    return skin;\n}\n\nmat4 getSkinningNormalMatrix()\n{\n    mat4 skin = mat4(0);\n\n    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)\n    skin +=\n        a_Weight1.x * getJointNormalMatrix(a_Joint1.x) +\n        a_Weight1.y * getJointNormalMatrix(a_Joint1.y) +\n        a_Weight1.z * getJointNormalMatrix(a_Joint1.z) +\n        a_Weight1.w * getJointNormalMatrix(a_Joint1.w);\n    #endif\n\n    return skin;\n}\n#endif // !USE_SKINNING\n\n#ifdef USE_MORPHING\nvec4 getTargetPosition()\n{\n    vec4 pos = vec4(0);\n\n#ifdef HAS_TARGET_POSITION0\n    pos.xyz += u_morphWeights[0] * a_Target_Position0;\n#endif\n\n#ifdef HAS_TARGET_POSITION1\n    pos.xyz += u_morphWeights[1] * a_Target_Position1;\n#endif\n\n#ifdef HAS_TARGET_POSITION2\n    pos.xyz += u_morphWeights[2] * a_Target_Position2;\n#endif\n\n#ifdef HAS_TARGET_POSITION3\n    pos.xyz += u_morphWeights[3] * a_Target_Position3;\n#endif\n\n#ifdef HAS_TARGET_POSITION4\n    pos.xyz += u_morphWeights[4] * a_Target_Position4;\n#endif\n\n    return pos;\n}\n\nvec4 getTargetNormal()\n{\n    vec4 normal = vec4(0);\n\n#ifdef HAS_TARGET_NORMAL0\n    normal.xyz += u_morphWeights[0] * a_Target_Normal0;\n#endif\n\n#ifdef HAS_TARGET_NORMAL1\n    normal.xyz += u_morphWeights[1] * a_Target_Normal1;\n#endif\n\n#ifdef HAS_TARGET_NORMAL2\n    normal.xyz += u_morphWeights[2] * a_Target_Normal2;\n#endif\n\n#ifdef HAS_TARGET_NORMAL3\n    normal.xyz += u_morphWeights[3] * a_Target_Normal3;\n#endif\n\n#ifdef HAS_TARGET_NORMAL4\n    normal.xyz += u_morphWeights[4] * a_Target_Normal4;\n#endif\n\n    return normal;\n}\n\nvec4 getTargetTangent()\n{\n    vec4 tangent = vec4(0);\n\n#ifdef HAS_TARGET_TANGENT0\n    tangent.xyz += u_morphWeights[0] * a_Target_Tangent0;\n#endif\n\n#ifdef HAS_TARGET_TANGENT1\n    tangent.xyz += u_morphWeights[1] * a_Target_Tangent1;\n#endif\n\n#ifdef HAS_TARGET_TANGENT2\n    tangent.xyz += u_morphWeights[2] * a_Target_Tangent2;\n#endif\n\n#ifdef HAS_TARGET_TANGENT3\n    tangent.xyz += u_morphWeights[3] * a_Target_Tangent3;\n#endif\n\n#ifdef HAS_TARGET_TANGENT4\n    tangent.xyz += u_morphWeights[4] * a_Target_Tangent4;\n#endif\n\n    return tangent;\n}\n\n#endif // !USE_MORPHING\n\n\nVERT_IN vec4 a_Position;\nVERT_OUT vec3 v_Position;\n\n#ifdef USE_INSTANCING\nVERT_IN vec4 a_ModelMatrix0;\nVERT_IN vec4 a_ModelMatrix1;\nVERT_IN vec4 a_ModelMatrix2;\nVERT_IN vec4 a_ModelMatrix3;\n#endif\n\n#ifdef USE_INSTANCING\nVERT_IN vec4 a_BaseColorFactor;\nVERT_OUT vec4 v_BaseColorFactor;\n#endif\n\n#ifdef USE_INSTANCING\nVERT_IN vec4 a_NormalMatrix0;\nVERT_IN vec4 a_NormalMatrix1;\nVERT_IN vec4 a_NormalMatrix2;\nVERT_IN vec4 a_NormalMatrix3;\n#endif\n\n#ifdef HAS_NORMALS\nVERT_IN vec4 a_Normal;\n#endif\n\n#ifdef HAS_TANGENTS\nVERT_IN vec4 a_Tangent;\n#endif\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nVERT_OUT mat3 v_TBN;\n#else\nVERT_OUT vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_UV_SET1\nVERT_IN vec2 a_UV1;\n#endif\n\n#ifdef HAS_UV_SET2\nVERT_IN vec2 a_UV2;\n#endif\n\nVERT_OUT vec2 v_UVCoord1;\nVERT_OUT vec2 v_UVCoord2;\n\n#ifdef HAS_VERTEX_COLOR_VEC3\nVERT_IN vec3 a_Color;\nVERT_OUT vec3 v_Color;\n#endif\n\n#ifdef HAS_VERTEX_COLOR_VEC4\nVERT_IN vec4 a_Color;\nVERT_OUT vec4 v_Color;\n#endif\n\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\n#ifdef USE_SHADOW_MAPPING\nuniform mat4 u_LightViewProjectionMatrix;\nVERT_OUT vec4 v_PositionLightSpace;\n#endif\n\nvec4 getPosition()\n{\n    vec4 pos = a_Position;\n\n#ifdef USE_MORPHING\n    pos += getTargetPosition();\n#endif\n\n#ifdef USE_SKINNING\n    pos = getSkinningMatrix() * pos;\n#endif\n\n    return pos;\n}\n\n#ifdef HAS_NORMALS\nvec4 getNormal()\n{\n    vec4 normal = a_Normal;\n\n#ifdef USE_MORPHING\n    normal += getTargetNormal();\n#endif\n\n#ifdef USE_SKINNING\n    normal = getSkinningNormalMatrix() * normal;\n#endif\n\n    return normalize(normal);\n}\n#endif\n\n#ifdef HAS_TANGENTS\nvec4 getTangent()\n{\n    vec4 tangent = a_Tangent;\n\n#ifdef USE_MORPHING\n    tangent += getTargetTangent();\n#endif\n\n#ifdef USE_SKINNING\n    tangent = getSkinningMatrix() * tangent;\n#endif\n\n    return normalize(tangent);\n}\n#endif\n\nvoid main()\n{\n    mat4 modelMatrix = u_ModelMatrix;\n    #ifdef USE_INSTANCING\n        modelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\n    #endif\n    vec4 pos = modelMatrix * getPosition();\n    v_Position = vec3(pos.xyz) / pos.w;\n\n    mat4 normalMatrix = u_NormalMatrix;\n    #ifdef USE_INSTANCING\n        normalMatrix = mat4(a_NormalMatrix0, a_NormalMatrix1, a_NormalMatrix2, a_NormalMatrix3);\n    #endif\n\n    #ifdef HAS_NORMALS\n    #ifdef HAS_TANGENTS\n    vec4 tangent = getTangent();\n    vec3 normalW = normalize(vec3(normalMatrix * vec4(getNormal().xyz, 0.0)));\n    vec3 tangentW = normalize(vec3(modelMatrix * vec4(tangent.xyz, 0.0)));\n    vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n    v_TBN = mat3(tangentW, bitangentW, normalW);\n    #else // !HAS_TANGENTS\n    v_Normal = normalize(vec3(normalMatrix * vec4(getNormal().xyz, 0.0)));\n    #endif\n    #endif // !HAS_NORMALS\n\n    v_UVCoord1 = vec2(0.0, 0.0);\n    v_UVCoord2 = vec2(0.0, 0.0);\n\n    #ifdef HAS_UV_SET1\n    v_UVCoord1 = a_UV1;\n    #endif\n\n    #ifdef HAS_UV_SET2\n    v_UVCoord2 = a_UV2;\n    #endif\n\n    #if defined(HAS_VERTEX_COLOR_VEC3) || defined(HAS_VERTEX_COLOR_VEC4)\n    v_Color = a_Color;\n    #endif\n\n    #ifdef USE_SHADOW_MAPPING\n    v_PositionLightSpace = u_LightViewProjectionMatrix * pos;\n    #endif\n\n    #ifdef USE_INSTANCING\n    v_BaseColorFactor = a_BaseColorFactor;\n    #endif\n\n    gl_Position = u_ViewProjectionMatrix * pos;\n}\n"};

    var StandardShader = /** @class */ (function (_super) {
        __extends(StandardShader, _super);
        function StandardShader() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._instancing = new StandardShaderInstancing();
            return _this;
        }
        StandardShader.build = function (renderer, features) {
            var program = PixiCore.Program.from(StandardShaderSource.build(Shader$a.source, features, renderer), StandardShaderSource.build(Shader$b.source, features, renderer));
            return new StandardShader(program);
        };
        Object.defineProperty(StandardShader.prototype, "name", {
            get: function () {
                return "standard-shader";
            },
            enumerable: false,
            configurable: true
        });
        StandardShader.prototype.createShaderGeometry = function (geometry, instanced) {
            var result = _super.prototype.createShaderGeometry.call(this, geometry, instanced);
            if (instanced) {
                this._instancing.addGeometryAttributes(result);
            }
            if (geometry.targets) {
                for (var i = 0; i < geometry.targets.length; i++) {
                    var positions = geometry.targets[i].positions;
                    if (positions) {
                        result.addAttribute("a_Target_Position" + i, new PixiCore.Buffer(positions.buffer), 3, false, positions.componentType, positions.stride);
                    }
                    var normals = geometry.targets[i].normals;
                    if (normals) {
                        result.addAttribute("a_Target_Normal" + i, new PixiCore.Buffer(normals.buffer), 3, false, normals.componentType, normals.stride);
                    }
                    var tangents = geometry.targets[i].tangents;
                    if (tangents) {
                        result.addAttribute("a_Target_Tangent" + i, new PixiCore.Buffer(tangents.buffer), 3, false, tangents.componentType, tangents.stride);
                    }
                }
            }
            if (geometry.uvs && geometry.uvs[1]) {
                result.addAttribute("a_UV2", new PixiCore.Buffer(geometry.uvs[1].buffer), 2, false, geometry.uvs[1].componentType, geometry.uvs[1].stride);
            }
            if (geometry.joints) {
                result.addAttribute("a_Joint1", new PixiCore.Buffer(geometry.joints.buffer), 4, false, geometry.joints.componentType, geometry.joints.stride);
            }
            if (geometry.weights) {
                result.addAttribute("a_Weight1", new PixiCore.Buffer(geometry.weights.buffer), 4, false, geometry.weights.componentType, geometry.weights.stride);
            }
            return result;
        };
        StandardShader.prototype.render = function (mesh, renderer, state, drawMode) {
            if (mesh.instances.length > 0) {
                var filteredInstances = mesh.instances.filter(function (instance) { return instance.worldVisible && instance.renderable; });
                if (filteredInstances.length === 0) {
                    //early exit - this avoids us drawing the last known instance in the instance buffer
                    return;
                }
                this._instancing.updateBuffers(filteredInstances);
            }
            _super.prototype.render.call(this, mesh, renderer, state, drawMode);
        };
        return StandardShader;
    }(MeshShader));

    exports.MaterialRenderSortType = void 0;
    (function (MaterialRenderSortType) {
        MaterialRenderSortType["opaque"] = "opaque";
        MaterialRenderSortType["transparent"] = "transparent";
    })(exports.MaterialRenderSortType || (exports.MaterialRenderSortType = {}));

    /**
     * Materials are used to render a mesh with a specific visual appearance.
     */
    var Material = /** @class */ (function () {
        function Material() {
            this._renderSortType = exports.MaterialRenderSortType.opaque;
            /** State used to render a mesh. */
            this.state = Object.assign(new PixiCore.State(), {
                culling: true, clockwiseFrontFace: false, depthTest: true
            });
            /** Draw mode used to render a mesh. */
            this.drawMode = constants.DRAW_MODES.TRIANGLES;
            /**
             * Sort type used to render a mesh. Transparent materials will be rendered
             * after opaque materials.
             */
            this.renderSortType = exports.MaterialRenderSortType.opaque;
        }
        Object.defineProperty(Material.prototype, "depthMask", {
            /**
             * Value indicating if writing into the depth buffer is enabled or disabled.
             * Depth mask feature is only available in PixiJS 6.0+ and won't have any
             * effects in previous versions.
             */
            get: function () {
                return this.state.depthMask;
            },
            set: function (value) {
                this.state.depthMask = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "doubleSided", {
            /**
             * Value indicating if the material is double sided. When set to true, the
             * culling state will be set to false.
             */
            get: function () {
                return !this.state.culling;
            },
            set: function (value) {
                this.state.culling = !value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "blendMode", {
            /** Blend mode used to render a mesh. */
            get: function () {
                return this.state.blendMode;
            },
            set: function (value) {
                this.state.blendMode = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Creates a shader used to render the specified mesh.
         * @param mesh The mesh to create the shader for.
         * @param renderer The renderer to use.
         */
        Material.prototype.createShader = function (mesh, renderer) {
            return undefined;
        };
        /**
         * Updates the uniforms for the specified shader.
         * @param mesh The mesh used for updating the uniforms.
         * @param shader The shader to update.
         */
        Material.prototype.updateUniforms = function (mesh, shader) { };
        /**
         * Destroys the material and it's used resources.
         */
        Material.prototype.destroy = function () { };
        Object.defineProperty(Material.prototype, "isInstancingSupported", {
            /**
             * Returns a value indicating if this material supports instancing.
             */
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Creates a new instanced version of this material.
         */
        Material.prototype.createInstance = function () {
            return undefined;
        };
        /**
         * Renders the specified mesh.
         * @param mesh The mesh to render.
         * @param renderer The renderer to use.
         */
        Material.prototype.render = function (mesh, renderer) {
            if (!this._shader) {
                this._shader = this.createShader(mesh, renderer);
                if (!this._shader) {
                    // The shader couldn't be created for some reason. Just ignore it and 
                    // try again at next render. The required assets may not have been loaded 
                    // yet, so maybe we are waiting for those.
                    return;
                }
            }
            if (this.updateUniforms) {
                this.updateUniforms(mesh, this._shader);
            }
            this._shader.render(mesh, renderer, this.state, this.drawMode);
        };
        /**
         * Creates a new material from the specified vertex/fragment source.
         * @param vertexSrc The vertex shader source.
         * @param fragmentSrc The fragment shader source.
         * @param updateUniforms The function which will be called for updating the
         * shader uniforms.
         */
        Material.from = function (vertexSrc, fragmentSrc, updateUniforms) {
            return Object.assign(new Material(), {
                updateUniforms: updateUniforms || (function () { }),
                _shader: new MeshShader(PixiCore.Program.from(vertexSrc, fragmentSrc)),
            });
        };
        return Material;
    }());

    /**
     * A lighting environment represents the different lighting conditions for a
     * specific object or an entire scene.
     */
    var LightingEnvironment = /** @class */ (function () {
        /**
         * Creates a new lighting environment using the specified renderer.
         * @param renderer The renderer to use.
         */
        function LightingEnvironment(renderer, imageBasedLighting) {
            var _this = this;
            this.renderer = renderer;
            /** The lights affecting this lighting environment. */
            this.lights = [];
            this.renderer.on("prerender", function () {
                var e_1, _a;
                try {
                    for (var _b = __values(_this.lights), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var light = _c.value;
                        // Make sure the transform has been updated in the case where the light
                        // is not part of the stage hierarchy.
                        if (!light.parent) {
                            light.transform.updateTransform();
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            });
            if (!LightingEnvironment.main) {
                LightingEnvironment.main = this;
            }
            this.imageBasedLighting = imageBasedLighting;
        }
        LightingEnvironment.prototype.destroy = function () {
        };
        Object.defineProperty(LightingEnvironment.prototype, "valid", {
            /** Value indicating if this object is valid to be used for rendering. */
            get: function () {
                return !this.imageBasedLighting || this.imageBasedLighting.valid;
            },
            enumerable: false,
            configurable: true
        });
        return LightingEnvironment;
    }());
    Compatibility.installRendererPlugin("lighting", LightingEnvironment);

    var StandardMaterialSkinUniforms = /** @class */ (function () {
        function StandardMaterialSkinUniforms() {
        }
        StandardMaterialSkinUniforms.prototype.enableJointMatrixTextures = function (jointsCount) {
            if (!this._jointMatrixTexture) {
                this._jointMatrixTexture = new StandardMaterialMatrixTexture(jointsCount);
            }
            if (!this._jointNormalTexture) {
                this._jointNormalTexture = new StandardMaterialMatrixTexture(jointsCount);
            }
        };
        StandardMaterialSkinUniforms.prototype.destroy = function () {
            var _a, _b;
            (_a = this._jointNormalTexture) === null || _a === void 0 ? void 0 : _a.destroy(true);
            (_b = this._jointMatrixTexture) === null || _b === void 0 ? void 0 : _b.destroy(true);
        };
        StandardMaterialSkinUniforms.prototype.update = function (mesh, shader) {
            if (!mesh.skin) {
                return;
            }
            if (this._jointMatrixTexture) {
                this._jointMatrixTexture.updateBuffer(mesh.skin.jointMatrices);
                shader.uniforms.u_jointMatrixSampler = this._jointMatrixTexture;
            }
            else {
                shader.uniforms.u_jointMatrix = mesh.skin.jointMatrices;
            }
            if (this._jointNormalTexture) {
                this._jointNormalTexture.updateBuffer(mesh.skin.jointNormalMatrices);
                shader.uniforms.u_jointNormalMatrixSampler = this._jointNormalTexture;
            }
            else {
                shader.uniforms.u_jointNormalMatrix = mesh.skin.jointNormalMatrices;
            }
        };
        return StandardMaterialSkinUniforms;
    }());

    /**
     * Represents a color containing RGBA components.
     */
    var Color = /** @class */ (function () {
        /**
         * Creates a new color with the specified components (in range 0-1).
         * @param r The R (red) component.
         * @param g The G (green) component.
         * @param b The B (blue) component.
         * @param a The A (alpha) component.
         */
        function Color(r, g, b, a) {
            if (r === void 0) { r = 0; }
            if (g === void 0) { g = 0; }
            if (b === void 0) { b = 0; }
            if (a === void 0) { a = 1; }
            this._array4 = new Float32Array([r, g, b, a]);
            this._array3 = this._array4.subarray(0, 3);
        }
        /**
         * Creates a new color with the specified components (in range 0-255).
         * @param r The R (red) component.
         * @param g The G (green) component.
         * @param b The B (blue) component.
         * @param a The A (alpha) component.
         */
        Color.fromBytes = function (r, g, b, a) {
            if (r === void 0) { r = 0; }
            if (g === void 0) { g = 0; }
            if (b === void 0) { b = 0; }
            if (a === void 0) { a = 255; }
            return new Color(r / 255, g / 255, b / 255, a / 255);
        };
        /**
         * Creates a new color from the specified hex value.
         * @param hex The hex value as a string or a number.
         */
        Color.fromHex = function (hex) {
            if (typeof hex === "string") {
                hex = parseInt(hex.replace(/[^0-9A-F]/gi, ""), 16);
            }
            return Color.fromBytes((hex >> 16) & 255, (hex >> 8) & 255, hex & 255);
        };
        Object.defineProperty(Color.prototype, "rgb", {
            /** The color as an typed array containing RGB. */
            get: function () {
                return this._array3;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "rgba", {
            /** The color as an typed array containing RGBA. */
            get: function () {
                return this._array4;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "r", {
            /** The R (red) component. */
            get: function () {
                return this._array4[0];
            },
            set: function (value) {
                this._array4[0] = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "g", {
            /** The G (green) component. */
            get: function () {
                return this._array4[1];
            },
            set: function (value) {
                this._array4[1] = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "b", {
            /** The B (blue) component. */
            get: function () {
                return this._array4[2];
            },
            set: function (value) {
                this._array4[2] = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "a", {
            /** The A (alpha) component. */
            get: function () {
                return this._array4[3];
            },
            set: function (value) {
                this._array4[3] = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Creates a new color from the specified source.
         * @param source The source to create the color from.
         */
        Color.from = function (source) {
            return new (Color.bind.apply(Color, __spreadArray([void 0], __read(source))))();
        };
        return Color;
    }());

    /** Material for instanced meshes which uses the standard material. */
    var InstancedStandardMaterial = /** @class */ (function () {
        /** Creates a new instanced standard material from the specified material. */
        function InstancedStandardMaterial(material) {
            this.baseColor = new (Color.bind.apply(Color, __spreadArray([void 0], __read(material.baseColor.rgba))))();
        }
        return InstancedStandardMaterial;
    }());

    /**
     * glTF defines materials using a common set of parameters that are based on
     * widely used material representations from Physically-Based Rendering (PBR).
     */
    var glTFMaterial = /** @class */ (function () {
        function glTFMaterial() {
            this.alphaCutoff = 0.5;
            this.alphaMode = "OPAQUE";
            this.doubleSided = false;
            this.roughness = 1;
            this.metallic = 1;
            this.emissiveFactor = [0, 0, 0];
            this.baseColor = [1, 1, 1, 1];
            this.unlit = false;
        }
        return glTFMaterial;
    }());

    var Mat3 = /** @class */ (function () {
        function Mat3() {
        }
        Mat3.multiply = function (a, b, out) {
            if (out === void 0) { out = new Float32Array(9); }
            return multiply$2(out, a, b);
        };
        return Mat3;
    }());

    /**
     * Transform used to offset, rotate and scale texture coordinates.
     */
    var TextureTransform = /** @class */ (function () {
        function TextureTransform() {
            var _this = this;
            this._rotation = 0;
            this._array = new Float32Array(9);
            this._dirty = true;
            this._translation = new Float32Array([
                1, 0, 0, 0, 1, 0, 0, 0, 1
            ]);
            this._scaling = new Float32Array([
                1, 0, 0, 0, 1, 0, 0, 0, 1
            ]);
            this._rotate = new Float32Array([
                Math.cos(0), -Math.sin(0), 0, Math.sin(0), Math.cos(0), 0, 0, 0, 1
            ]);
            /** The offset for the texture coordinates. */
            this.offset = new math.ObservablePoint(function () {
                _this._translation.set([
                    1, 0, 0, 0, 1, 0, _this.offset.x, _this.offset.y, 1
                ]);
                _this._dirty = true;
            }, undefined);
            /** The scale of the texture coordinates. */
            this.scale = new math.ObservablePoint(function () {
                _this._scaling.set([
                    _this.scale.x, 0, 0, 0, _this.scale.y, 0, 0, 0, 1
                ]);
                _this._dirty = true;
            }, undefined, 1, 1);
        }
        Object.defineProperty(TextureTransform.prototype, "rotation", {
            /** The rotation for the texture coordinates. */
            get: function () {
                return this._rotation;
            },
            set: function (value) {
                this._rotation = value;
                this._rotate.set([
                    Math.cos(value), -Math.sin(value), 0, Math.sin(value), Math.cos(value), 0, 0, 0, 1
                ]);
                this._dirty = true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TextureTransform.prototype, "array", {
            /** The matrix array. */
            get: function () {
                if (this._dirty) {
                    Mat3.multiply(Mat3.multiply(this._translation, this._rotate, this._array), this._scaling, this._array);
                    this._dirty = false;
                }
                return this._array;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Creates a transform from the specified texture frame. Can be used when
         * texture is in a spritesheet.
         * @param texture The texture to use.
         */
        TextureTransform.fromTexture = function (texture) {
            var transform = new TextureTransform();
            if (!texture.frame || texture.noFrame) {
                return transform;
            }
            var _a = texture.frame, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
            if (texture.rotate === 0) {
                transform.offset.set(x / texture.baseTexture.width, y / texture.baseTexture.height);
                transform.scale.set(width / texture.baseTexture.width, height / texture.baseTexture.height);
            }
            if (texture.rotate === 2) {
                x = texture.frame.x + texture.frame.width;
                transform.offset.set(x / texture.baseTexture.width, y / texture.baseTexture.height);
                transform.scale.set(height / texture.baseTexture.height, width / texture.baseTexture.width);
                transform.rotation = -90 * math.DEG_TO_RAD;
            }
            return transform;
        };
        return TextureTransform;
    }());

    /**
     * Represents a texture which can have a transform.
     */
    var StandardMaterialTexture = /** @class */ (function (_super) {
        __extends(StandardMaterialTexture, _super);
        /**
         * Creates a new texture from the specified base texture.
         * @param baseTexture The base texture.
         * @param uvSet The uv set to use (0 or 1).
         */
        function StandardMaterialTexture(baseTexture, uvSet) {
            var _this = _super.call(this, baseTexture) || this;
            _this.uvSet = uvSet;
            return _this;
        }
        return StandardMaterialTexture;
    }(PixiCore.Texture));

    /**
     * Represents a texture which holds specific data for a normal map.
     */
    var StandardMaterialNormalTexture = /** @class */ (function (_super) {
        __extends(StandardMaterialNormalTexture, _super);
        /**
         * Creates a new texture from the specified base texture.
         * @param baseTexture The base texture.
         * @param scale The scale of the normal.
         * @param uvSet The uv set to use (0 or 1).
         */
        function StandardMaterialNormalTexture(baseTexture, scale, uvSet) {
            var _this = _super.call(this, baseTexture, uvSet) || this;
            _this.scale = scale;
            _this.uvSet = uvSet;
            return _this;
        }
        return StandardMaterialNormalTexture;
    }(StandardMaterialTexture));

    /**
     * Represents a texture which holds specific data for a occlusion map.
     */
    var StandardMaterialOcclusionTexture = /** @class */ (function (_super) {
        __extends(StandardMaterialOcclusionTexture, _super);
        /**
         * Creates a new texture from the specified base texture.
         * @param baseTexture The base texture.
         * @param strength The strength of the occlusion.
         * @param uvSet The uv set to use (0 or 1).
         */
        function StandardMaterialOcclusionTexture(baseTexture, strength, uvSet) {
            var _this = _super.call(this, baseTexture, uvSet) || this;
            _this.strength = strength;
            _this.uvSet = uvSet;
            return _this;
        }
        return StandardMaterialOcclusionTexture;
    }(StandardMaterialTexture));

    var StandardMaterialFactory = /** @class */ (function () {
        function StandardMaterialFactory() {
        }
        StandardMaterialFactory.prototype.create = function (source) {
            var material = new StandardMaterial();
            if (!(source instanceof glTFMaterial)) {
                return material;
            }
            material.baseColor = Color.from(source.baseColor);
            if (source.baseColorTexture) {
                material.baseColorTexture = new StandardMaterialTexture(source.baseColorTexture.baseTexture, source.baseColorTexture.texCoord);
                material.baseColorTexture.transform =
                    this.createTextureTransform(source.baseColorTexture);
            }
            material.metallic = source.metallic;
            material.roughness = source.roughness;
            if (source.metallicRoughnessTexture) {
                material.metallicRoughnessTexture = new StandardMaterialTexture(source.metallicRoughnessTexture.baseTexture, source.metallicRoughnessTexture.texCoord);
                material.metallicRoughnessTexture.transform =
                    this.createTextureTransform(source.metallicRoughnessTexture);
            }
            material.emissive = Color.from(source.emissiveFactor);
            if (source.emissiveTexture) {
                material.emissiveTexture = new StandardMaterialTexture(source.emissiveTexture.baseTexture, source.emissiveTexture.texCoord);
                material.emissiveTexture.transform =
                    this.createTextureTransform(source.emissiveTexture);
            }
            switch (source.alphaMode) {
                case "BLEND": {
                    material.alphaMode = exports.StandardMaterialAlphaMode.blend;
                    material.renderSortType = exports.MaterialRenderSortType.transparent;
                    break;
                }
                case "MASK": {
                    material.alphaMode = exports.StandardMaterialAlphaMode.mask;
                    break;
                }
                case "OPAQUE": {
                    // Even when the material is "opaque", the default value is set to
                    // "blend". This is to make it easier to render transparent objects
                    // without having to change the alpha mode.
                    material.alphaMode = exports.StandardMaterialAlphaMode.blend;
                    break;
                }
            }
            material.unlit = source.unlit;
            material.doubleSided = source.doubleSided;
            material.alphaCutoff = source.alphaCutoff;
            if (source.normalTexture) {
                material.normalTexture = new StandardMaterialNormalTexture(source.normalTexture.baseTexture, source.normalTexture.scale, source.normalTexture.texCoord);
                material.normalTexture.transform =
                    this.createTextureTransform(source.normalTexture);
            }
            if (source.occlusionTexture) {
                material.occlusionTexture = new StandardMaterialOcclusionTexture(source.occlusionTexture.baseTexture, source.occlusionTexture.strength, source.occlusionTexture.texCoord);
                material.occlusionTexture.transform =
                    this.createTextureTransform(source.occlusionTexture);
            }
            return material;
        };
        StandardMaterialFactory.prototype.createTextureTransform = function (texture) {
            if (texture.transform) {
                var transform = new TextureTransform();
                if (texture.transform.offset) {
                    transform.offset.x = texture.transform.offset[0];
                    transform.offset.y = texture.transform.offset[1];
                }
                if (texture.transform.rotation !== undefined) {
                    transform.rotation = texture.transform.rotation;
                }
                if (texture.transform.scale) {
                    transform.scale.x = texture.transform.scale[0];
                    transform.scale.y = texture.transform.scale[1];
                }
                return transform;
            }
        };
        return StandardMaterialFactory;
    }());

    var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAADAFBMVEX/AACvAwC4BgC1BQD7AAD3AQDzAQD+AAD9AAD8AQDpAQC/CACxAwD5BgDACwCtAwDxAQC9CADDEQCrAwC7BwC4AQDfAQB+AADvAQD1AQD7AwB7AABrAADHAQDCDgDiAQCyBQCRAQD5AAC1AQDYAQDNAQCpAQCUAQCeAQB0AABhAAD3BwCnAQDCBwCMAACOAAD6BABvAADFAgDsAQD4AACIAADEDADKAQDnAQCfAQCoAwDuEADqFACAAACFAACKAADzCwCCAAC/AQCbAgDKDQDwDgC9AQDBAgCiAAC7AQCkAADlAQD0CACzAQDjGwBoAADEFgB4AAD2CADGEQDGDADQAQDbAQDGCADSAQDNCwDWAQDdAQDUAQBlAAB2AADJCADBGgCVAgDOEADtAQBxAADSDADBFgCZAADnGADXDADcIgDKEgDDAQBcAADQLQCkAwDSEADPCADfHgClAgDXBwDTCADkDACYAAC9IACxLgCiAwCZAgDIFgDINgDdDADxCgDuCACSAQDnEADqCgCPAQBYAAC+HADYJgDLMACWAADOFgDbEQCtMwDSGwCGAADLBgC4JwDbGADaDADBIACoVQDRIQCgAgCxTQDHGwDVKQC6IwDCPACRbADGIQDMGwBUAADgEQDgBwDXEgDkFQDkBgCHdgDnCQDSFQC1KgDWFwDgFwDgDACaRwDCJwCcAADLKAC4LwC2RwDELwCYZADLIACkPQDcBgC9KACFXgDrEAB/ZQCoOgDGKAC+LgDYHACpTwC6QwCWTQB5bQCiWwCcAgCfQgBxdACMVgCzNAB9fwCeYADXIQC4NwC+NgCxOgCHbQCRUQDDNwCrOQDRJwCnRQCYWQCuQQBnfQC+QACNZABziwBskAAY4QCXAgB4hQBghgBllwC1QACtSACfTgBfngCPXABYpQChSAC7PAB/dwCeVABTkQBKnABRrABBuwA4wwBcjgBKtAByfAAxywBApQA3sAAo1QBshgAK8QAY0QBXmgAkxgBPpAAqugBFrgA1uwB98tmWAAAOvklEQVR4nO3Ye1jW5RnA8d+Wtmmews2yJTlXrVWUmUNLt5xSVrpygqJZQShMwqWYOHSWhvMwkSESRRaej5hT8ZiJpCvDI5annGYecmpaOWdhHnff93O6n+f3exFc17yubTfG1V9+P8/9/F54X73Tp/fs+fqfX37xj8///um+3X/bu27GjDfeWLT+ry+//OqrC9/56PXXX3hh9HPPvTZq1LPP9u//2GO9e7du3bpVq1YPPtimTZuOHTvfAVO7dtOmN9xwQ40aNb6P8z01XqXm/4DTp09//b+9gT2n91zZDezZc6U3sOcKb+CbKw745hvo/7cALkcAgLNwA198fsUAZ8+epUfg8081YNF/EnD2/NmzX14UN3AZG+j8LQDOn7948YsLdAO7964jwHof4DUOeKuSgEoJCPDVhQvn5CPgXsEHLqD3twy4eP4rGAM4OqNMAEqqBGgaCKiM4KLsnzvz7wIucwUIOHXqFAD2nagS4EEGCHkHlSBcwPypc8fPnDmxu7xcAtZXFtAxEFClS7iA/ePHj585se+T8r0nsY+vQgQsrAqA/zC2VnApwgXKHz9z7MSJ8vKT66oM6GwDggQVE85h/tgx6H+iALvoVVgJQBsNqOAOLiUAwLHj1P+k/OTJo0fLynYtWrQdAQeCAI+FBFyu4MyZYzjQ37lTAbYDoAQ28M47RwAw2g94CwFD1UMQBHAFoQ0EOCH7a9dAf9eu7ds/gwUcsAGjLEArDehMAHEHFQpCIPadwDr2d0IfF4B9Adh/5MgmDdggANM4IPAOKhIEMPbp/tq1a9esWbFr1yEEHATA/v1HPpKArQLQXwBaM4C6g6oILM1umRf9MgUoEYAjHPCsAfCHwFqBJagMwSsvL9+p+2tWLN91CAEHAbBDAIoAsHXraxsUYFqGfQfOCmzBpQme6K8V+1+xAvqH8AYObyPAJgLMl4DC/oUIyNCAoXwFwYJLGby9J+HhXyvPv2L58kOHtsACDpZs2wGAjQgoQsDWDRtWwQYKC6dN660BQ4cGrUAIOKEihLdO9CmP/fcPbVl9EBagAEVFRfMBkEeAQgRMQwAKhqKAraBJU74DhxBK4a07KvKiv/z997cA4DABNm+0AatyJECuYJgEKEETJahWrUYIQ8DviaNH1xwVedO3ASsJkAeA/oV0BxkZGbiCYQgY2rGjuITqtWs3byIJ1aoZQqCBabwZKi/6CFgt+wgoFhvII0COWIEGGAEAqtdurgRNqlmEChFeWVkZy8u+BhQX0wbmWwApGNbKABre0bB69eYkAEITIbAMoRQIKMO6Of+bb7733ra3P9y8uXTjgmIQrFzpBwzPGP7WMLaChjDVDQG/BRkCJN4b8MtH1k1/yRIDmAeAxQDIQgAIJtMGADA8tEBMtWqhERri7cI5dEjkZf+9JW8DoLR0AQDm+QCTBQBGCOoRoaEhMINBhHJ4i/Bnn8xTXy6AAxYbQM5kAAy0BTBXw4Qg2Agfw4O3PyDYIvK6//aHY0s5YPHEvKw5c1YJwOSBAwcKAAmuB0A9LQgkuAhG8dZvhxF1kRcLGDsW+wuWLQNAAQDysrJAAIBMIcjImKkFQ68fWq/j1RaBDC4iEEKA1dtlXpyfFjB2EADGIaAAARMJMDUnM1OtYOZMtoJ6MA4hpMF2eJ/hrD64+k19fNEfO2jQbAUAwcSJCJgzNVMLZhoBGhwCM4RU0CDgIIy/X0p9CZgoATlCMHeuLbgepp5LEAaFCKXwXj5Ygj/7Dx+WeeiPpfMPmj2bALkCkJU1a9asOVMVgAvu9RG0QSK0ws/wSkpKDsu+yBNA9MdNWJaeC4D8fNjAmFlZCEDBi3O1gAj39uw5rKcmuAaFMAoOAcDhkm0wS7aZvOqPW5aePk8DxsAKJEAKpmsBEHoSga+BIwzDcjRv7h04cIDnqY8PIC1gQjpuIB8BYyyAEExHQc2ZNYfXvNclaIOFYAwlQcCBHdu2URx+/snzE2CCAOQCYIjcQD8QjM8cLwXTpxNhZs2aKDAEaTAIR8Eh3sIDO2g+xBlr+uNEHwDxCBgyhlbQDwTJ48cLwZQpStByuCHYBoYIYMB4C/djfbPKD1LHFxcAgHgBSEFAPwAkJyvBlCmS0KFlSyS4Bo2wFI7D2w+zGWdsqdtHwMj43PhO0EdAQgIA+iVrwZQpFqGmJAiDD+EyJEQD4HdPqcrLPgBGjoyPj+/UCQEpCQkkSHQE02k6KEKAwVK4DO/Ikf0bN5ZSvlTl9QNAfQB0QoAUJCrB0qVLzQ46dCACM0iEUVgMDQHARhwSLJhtHV8vQAJIkJjIBZJwUwiDQjCF65CABTSiLvoT0kdCHwBJkDeAxEQlGCAE0nCTFDCDi7AZyuFtwllAgtnjFjh57Cc5G0BDWlryABwh6IEAmg7GIBFKwRi2w/sA+8ViAzovnj8EJBEgOjoaAVHqDkCQNmDAeC3o0aBBkEEhtIIzeirAB5uKN8Gb3+JlOLpu+hKAhKjuOImpBEgbwJeAhgYNLINEaIVhcAcAioqpD4IJSEhPF4+f6gMgDPPRKVFRJEhNlQJJ6Np1aVcUEEEaNEIpDIM5UOLBR6+i4iK5gGWyrvpiA2FhtIGoaFcgAANuvrkrInr0sPbAEEEM5fBeQME8GpkXdXX+pKQwBaDpLgmpaS4Bpoe7CEuhGRzijSZA0Tx46wNf6bmqD6cfqfpCEBMVowipqZrw5JNCoAwMYRQWgzlaImD0ShzcQK6Yker1Z/oIiIkhQTYTkOFJmCeeGPDEzS7Cp3AcAuKNnj9aAApyhSCeJkn35QoiY3DioqLi4rKzu2cLQrfULt26pXUTBhhmsBUWw3J48Nl7PgDgnWeBvy/rYeFhkTAkoMmmIUOXLmDoRgaDcBWKYTsI4j1HggI58fG5/PyqHx4eKQWxcUEEMrgIo1AM7WAQbyv0F8+nem5BfH7g+RUgMiYWhgGyb7lFAAIQUsEY2mEgDQAAAvjotbgA3/zmF+R3gt9++vxJ4bB904+MlWMbYCyEUIRkMAhIALB1MU1BPgri8/F3j9p+nSTR9wli+UU4CEshGcphQ1Di4T+ACUE+Tic58vEPNxPpGgSiRYsW2dktblHTJZihHBqiJd7WPCGYKABKIG6/TlIditP3iIjICJjY2AgJaNSoURz810JNgEIytENDtMTLy8P+RBx895vP+2EyXocmIjxCT7NmzWLhT2xss0Y0LfwKy6Egfok3Ko+GBPDecwjrh1t9EKiJlQY9jVwGdwRCtMTbkLdB5qkP7770+cOsvEWQ06dPAIM7QkI0xduwAf/1JcsIojtFq3yS069zjRxot2/fnr6179PHZgQ6LIhFAQDk87LGjNEAGHMBTllPe3f6WJBG1rSowOKtWoWCiVn42S8lRfSjzQOg+9daQ4i2OMESzWlUEaWFAKzCKxCAISkKEM4X4NTlPKSmbVsfpY89AVtRGASskn3YgALwPo/+gM0j1z7ykG/asgm09HHuCAFz5mTNmiUBKSkuILgO/aCpqqZPMy8HAXMMgG2g6v2KOG2DOV5OjgCAIIEAQAiL9PV1+Lt8fhhiqgACQI4AzEpIUBuAXzl2P6BdUb/SJHB4hQYgriAK+5G8789fJeYnlZlLoDiANhAVHRPQ97Vxfl3ZqciFgBwCwOfOlAT4+BWjAeb4/vhVVzWmv7tx48Y8VUtO5WUEmDp1zqx++MlX98PVj5+gfGM1svadKkwtNmTwCguhP3Vqv34JQIhiC3D6dtzXrRtybEBd+aUHATkCADcAnz8V4Bp1Ab48a/NQ/VBzq/1Vt775ql+/LgIy3Q3wBZi8rNttq1T1qX8rADIlICGKAGwBvM/PbrXZX3e/nDsrnkfpjxxvWmFmjtpAlAbQr1+nz+tW3G0+b+bRS443bbLeALsBp6/zfOsmjak7Te/hwLlPfuEfNgTI1IAYC8D7Tp7i+rR9+wZkX1Fznzu34cj/B8BkAUhM6C5fhE6/sezrPB1dxfv27Tt48GAryiowf6lg2rVrpwGJGhBBAKtv57Eu44NpXnnlYRW+ze62k/PbkCMByQDorgF6AVaf8verel9ZV2dmXTf5ezEfq/kTHwFITsYFdKfXAFuA7rt5FtdtWeZRlntGzE/VvKTGBsQhIIIWENCnZ17nRR3K74q2KausSb7E5sdq/kjDAVEAiBU3IBeg+ip/P+bl4eno78KoY4u0DPMqy8m5W85dd92FgBcJQDcA/Yg61gJ438qr+h9UW6RNmVdVTs8DarwMAIxXgFi2AKtv52Ud4jAyTm23zLM6+cDP+ViAOPjszxbg9k2ezi7qIq7OrdIm7Eb/bOaXOA5APIJiAVZfHV/m6fCmzto6bYWtJs6v1HgZAzUgLk7dgLwA3rfydHiqO3GTtsJu9RdmADCXAKnyBtgC3D48eioPh6ezm7qImzYvO9nr+AQC1AU4fXr0VF5unuombtqs7O/+yIwNiIyANwJsAbIv13+buHuZ99V13LSdsMn+Rs3TEpAGAHoEQvX18Vle1dXRVdzfdsNPi/kZjA2I4AC8ANaX2w/KO3HetsumK6dXLw2AF4F4BCrq06On825dxe12ULmXmHtgHIBeAF2A24cXXnDe1EO07fI9em68UQFSu2drAFuA7os89WXeqeujO20rzcJqLIC5AbmA55+nPj++P8/PruPs3Fb6RjaP4xgAPoNqAbVUv29AXyyf8vrwvjo7tz/9uJqnnnrKG64B4gbEAswFqP4zKn+3nXfr+uSBbVamuf12CUjkAL2Avub+nzHHD8izuj65G/elxTgbEDeACxAPQIi+P8/q5ujB7dutEYC0tNTsuKAFsH6IvDy8r27HA9q/EyMBiRyAL4FL9HneHN49Oo8HtGFGjCBAMgPQDcAC6ALg5w/vh8zze684ztJiFKA7/RTAR4BugBaALwDTt4+v887hWd2N+9ojRkyaNIkAA+gZjIiQN0ALUBfg9HX+OjsfWPfHrTYNB4gbkAugC4D+x9QX128f38mHrPvik/gogH4EGtfSC4ALkH08v1y/yYu77+XmA+vBcZx/AeDdATn/vA1ZAAAAAElFTkSuQmCC";

    /**
     * Collection of components used for image-based lighting (IBL), a
     * rendering technique which involves capturing an omnidirectional representation
     * of real-world light information as an image.
     */
    var ImageBasedLighting = /** @class */ (function () {
        /**
         * Creates a new image-based lighting object.
         * @param diffuse Cubemap used for the diffuse component.
         * @param specular Cubemap used for the specular component.
         */
        function ImageBasedLighting(diffuse, specular) {
            this._diffuse = diffuse;
            this._specular = specular;
        }
        Object.defineProperty(ImageBasedLighting.prototype, "diffuse", {
            /** Cube texture used for the diffuse component. */
            get: function () {
                return this._diffuse;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageBasedLighting.prototype, "specular", {
            /** Cube mipmap texture used for the specular component. */
            get: function () {
                return this._specular;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageBasedLighting.prototype, "valid", {
            /**
             * Value indicating if this object is valid to be used for rendering.
             */
            get: function () {
                return this._diffuse.valid &&
                    this._specular.valid && (!this.lookupBrdf || this.lookupBrdf.valid);
            },
            enumerable: false,
            configurable: true
        });
        /** The default BRDF integration map lookup texture. */
        ImageBasedLighting.defaultLookupBrdf = PixiCore.Texture.from(img, {
            mipmap: constants.MIPMAP_MODES.OFF
        });
        return ImageBasedLighting;
    }());

    var shaders = {};
    var getLightingEnvironmentConfigId = function (env) {
        return env ? (env.lights.length + (env.imageBasedLighting ? 0.5 : 0)) : 0;
    };
    /**
     * The standard material is using Physically-Based Rendering (PBR) which makes
     * it suitable to represent a wide range of different surfaces. It's the default
     * material when loading models from file.
     */
    var StandardMaterial = /** @class */ (function (_super) {
        __extends(StandardMaterial, _super);
        function StandardMaterial() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._lightingEnvironmentConfigId = 0;
            _this._unlit = false;
            _this._alphaMode = exports.StandardMaterialAlphaMode.blend;
            _this._baseColorFactor = new Float32Array(4);
            _this._instancingEnabled = false;
            _this._skinUniforms = new StandardMaterialSkinUniforms();
            /** The roughness of the material. */
            _this.roughness = 1;
            /** The metalness of the material. */
            _this.metallic = 1;
            /** The base color of the material. */
            _this.baseColor = new Color(1, 1, 1, 1);
            /** The cutoff threshold when alpha mode is set to "mask". */
            _this.alphaCutoff = 0.5;
            /** The emissive color of the material. */
            _this.emissive = new Color(0, 0, 0);
            /** The exposure (brightness) of the material. */
            _this.exposure = 1;
            return _this;
        }
        Object.defineProperty(StandardMaterial.prototype, "baseColorTexture", {
            /** The base color texture. */
            get: function () {
                return this._baseColorTexture;
            },
            set: function (value) {
                if (value !== this._baseColorTexture) {
                    this.invalidateShader();
                    if (!(value === null || value === void 0 ? void 0 : value.transform) && (value === null || value === void 0 ? void 0 : value.frame) && !(value === null || value === void 0 ? void 0 : value.noFrame)) {
                        value.transform = TextureTransform.fromTexture(value);
                    }
                    this._baseColorTexture = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StandardMaterial.prototype, "metallicRoughnessTexture", {
            /** The metallic-roughness texture. */
            get: function () {
                return this._metallicRoughnessTexture;
            },
            set: function (value) {
                if (value !== this._metallicRoughnessTexture) {
                    this.invalidateShader();
                    if (!(value === null || value === void 0 ? void 0 : value.transform) && (value === null || value === void 0 ? void 0 : value.frame) && !(value === null || value === void 0 ? void 0 : value.noFrame)) {
                        value.transform = TextureTransform.fromTexture(value);
                    }
                    this._metallicRoughnessTexture = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StandardMaterial.prototype, "normalTexture", {
            /** The normal map texture. */
            get: function () {
                return this._normalTexture;
            },
            set: function (value) {
                if (value !== this._normalTexture) {
                    this.invalidateShader();
                    if (!(value === null || value === void 0 ? void 0 : value.transform) && (value === null || value === void 0 ? void 0 : value.frame) && !(value === null || value === void 0 ? void 0 : value.noFrame)) {
                        value.transform = TextureTransform.fromTexture(value);
                    }
                    this._normalTexture = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StandardMaterial.prototype, "occlusionTexture", {
            /** The occlusion map texture. */
            get: function () {
                return this._occlusionTexture;
            },
            set: function (value) {
                if (value !== this._occlusionTexture) {
                    this.invalidateShader();
                    if (!(value === null || value === void 0 ? void 0 : value.transform) && (value === null || value === void 0 ? void 0 : value.frame) && !(value === null || value === void 0 ? void 0 : value.noFrame)) {
                        value.transform = TextureTransform.fromTexture(value);
                    }
                    this._occlusionTexture = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StandardMaterial.prototype, "emissiveTexture", {
            /** The emissive map texture. */
            get: function () {
                return this._emissiveTexture;
            },
            set: function (value) {
                if (value !== this._emissiveTexture) {
                    this.invalidateShader();
                    if (!(value === null || value === void 0 ? void 0 : value.transform) && (value === null || value === void 0 ? void 0 : value.frame) && !(value === null || value === void 0 ? void 0 : value.noFrame)) {
                        value.transform = TextureTransform.fromTexture(value);
                    }
                    this._emissiveTexture = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StandardMaterial.prototype, "alphaMode", {
            /** The alpha rendering mode of the material. */
            get: function () {
                return this._alphaMode;
            },
            set: function (value) {
                if (this._alphaMode !== value) {
                    this._alphaMode = value;
                    this.invalidateShader();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StandardMaterial.prototype, "shadowCastingLight", {
            /** The shadow casting light of the material. */
            get: function () {
                return this._shadowCastingLight;
            },
            set: function (value) {
                if (value !== this._shadowCastingLight) {
                    this.invalidateShader();
                    this._shadowCastingLight = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StandardMaterial.prototype, "debugMode", {
            /** The debug rendering mode of the material. */
            get: function () {
                return this._debugMode;
            },
            set: function (value) {
                if (this._debugMode !== value) {
                    this.invalidateShader();
                    this._debugMode = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StandardMaterial.prototype, "lightingEnvironment", {
            /**
             * Lighting environment used when rendering a mesh. If this value is not set,
             * the main lighting environment will be used by default.
             */
            get: function () {
                return this._lightingEnvironment;
            },
            set: function (value) {
                if (value !== this._lightingEnvironment) {
                    this.invalidateShader();
                    this._lightingEnvironmentConfigId = getLightingEnvironmentConfigId(value);
                    this._lightingEnvironment = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StandardMaterial.prototype, "unlit", {
            /**
             * Value indicating if the material is unlit. If this value if set to true,
             * all lighting is disabled and only the base color will be used.
             */
            get: function () {
                return this._unlit;
            },
            set: function (value) {
                if (this._unlit !== value) {
                    this._unlit = value;
                    this.invalidateShader();
                }
            },
            enumerable: false,
            configurable: true
        });
        StandardMaterial.prototype.destroy = function () {
            var _a, _b, _c, _d, _e;
            (_a = this._baseColorTexture) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this._normalTexture) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this._emissiveTexture) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this._occlusionTexture) === null || _d === void 0 ? void 0 : _d.destroy();
            (_e = this._metallicRoughnessTexture) === null || _e === void 0 ? void 0 : _e.destroy();
            this._skinUniforms.destroy();
        };
        /**
         * Invalidates the shader so it can be rebuilt with the current features.
         */
        StandardMaterial.prototype.invalidateShader = function () {
            this._shader = undefined;
        };
        /**
         * Creates a new standard material from the specified source.
         * @param source Source from which the material is created.
         */
        StandardMaterial.create = function (source) {
            return new StandardMaterialFactory().create(source);
        };
        StandardMaterial.prototype.render = function (mesh, renderer) {
            if (!this._instancingEnabled && mesh.instances.length > 0) {
                // Invalidate shader when instancing was enabled.
                this.invalidateShader();
                this._instancingEnabled = true;
            }
            if (this._instancingEnabled && mesh.instances.length === 0) {
                // Invalidate shader when instancing was disabled.
                this.invalidateShader();
                this._instancingEnabled = false;
            }
            var lighting = this.lightingEnvironment || LightingEnvironment.main;
            var configId = getLightingEnvironmentConfigId(lighting);
            if (configId !== this._lightingEnvironmentConfigId) {
                // Invalidate shader when the lighting config has changed.
                this.invalidateShader();
                this._lightingEnvironmentConfigId = configId;
            }
            _super.prototype.render.call(this, mesh, renderer);
        };
        Object.defineProperty(StandardMaterial.prototype, "isInstancingSupported", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        StandardMaterial.prototype.createInstance = function () {
            return new InstancedStandardMaterial(this);
        };
        StandardMaterial.prototype.createShader = function (mesh, renderer) {
            var e_1, _a;
            if (renderer.context.webGLVersion === 1) {
                var extensions = ["EXT_shader_texture_lod", "OES_standard_derivatives"];
                try {
                    for (var extensions_1 = __values(extensions), extensions_1_1 = extensions_1.next(); !extensions_1_1.done; extensions_1_1 = extensions_1.next()) {
                        var ext = extensions_1_1.value;
                        if (!renderer.gl.getExtension(ext)) {
                            // Log warning?
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (extensions_1_1 && !extensions_1_1.done && (_a = extensions_1.return)) _a.call(extensions_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            var lightingEnvironment = this.lightingEnvironment || LightingEnvironment.main;
            var features = StandardMaterialFeatureSet.build(renderer, mesh, mesh.geometry, this, lightingEnvironment);
            if (!features) {
                // The shader features couldn't be built, some resources may still be 
                // loading. Don't worry, we will retry creating shader at next render.
                return undefined;
            }
            if (mesh.skin && StandardMaterialFeatureSet.hasSkinningTextureFeature(features)) {
                this._skinUniforms.enableJointMatrixTextures(mesh.skin.joints.length);
            }
            var checksum = features.join(",");
            if (!shaders[checksum]) {
                shaders[checksum] = StandardShader.build(renderer, features);
            }
            return shaders[checksum];
        };
        StandardMaterial.prototype.updateUniforms = function (mesh, shader) {
            var _a, _b, _c, _d, _e;
            for (var i = 0; i < 3; i++) {
                this._baseColorFactor[i] = this.baseColor.rgba[i];
            }
            this._baseColorFactor[3] = this.baseColor.a * mesh.worldAlpha;
            var camera = this.camera || Camera.main;
            if (mesh.skin) {
                this._skinUniforms.update(mesh, shader);
            }
            shader.uniforms.u_Camera = camera.worldTransform.position;
            shader.uniforms.u_ViewProjectionMatrix = camera.viewProjection;
            shader.uniforms.u_Exposure = this.exposure;
            shader.uniforms.u_MetallicFactor = this.metallic;
            shader.uniforms.u_RoughnessFactor = this.roughness;
            shader.uniforms.u_BaseColorFactor = this._baseColorFactor;
            shader.uniforms.u_ModelMatrix = mesh.worldTransform.array;
            shader.uniforms.u_NormalMatrix = mesh.transform.normalTransform.array;
            if (this._alphaMode === exports.StandardMaterialAlphaMode.mask) {
                shader.uniforms.u_AlphaCutoff = this.alphaCutoff;
            }
            if (mesh.targetWeights) {
                shader.uniforms.u_morphWeights = mesh.targetWeights;
            }
            if ((_a = this.baseColorTexture) === null || _a === void 0 ? void 0 : _a.valid) {
                shader.uniforms.u_BaseColorSampler = this.baseColorTexture;
                shader.uniforms.u_BaseColorUVSet = this.baseColorTexture.uvSet || 0;
                if (this.baseColorTexture.transform) {
                    shader.uniforms.u_BaseColorUVTransform = this.baseColorTexture.transform.array;
                }
            }
            var lightingEnvironment = this.lightingEnvironment || LightingEnvironment.main;
            for (var i = 0; i < lightingEnvironment.lights.length; i++) {
                var light = lightingEnvironment.lights[i];
                var type = 0;
                switch (light.type) {
                    case exports.LightType.point:
                        type = 1;
                        break;
                    case exports.LightType.directional:
                        type = 0;
                        break;
                    case exports.LightType.spot:
                        type = 2;
                        break;
                }
                shader.uniforms["u_Lights[" + i + "].type"] = type;
                shader.uniforms["u_Lights[" + i + "].position"] = light.worldTransform.position;
                shader.uniforms["u_Lights[" + i + "].direction"] = light.worldTransform.forward;
                shader.uniforms["u_Lights[" + i + "].range"] = light.range;
                shader.uniforms["u_Lights[" + i + "].color"] = light.color.rgb;
                shader.uniforms["u_Lights[" + i + "].intensity"] = light.intensity;
                shader.uniforms["u_Lights[" + i + "].innerConeCos"] = Math.cos(light.innerConeAngle * math.DEG_TO_RAD);
                shader.uniforms["u_Lights[" + i + "].outerConeCos"] = Math.cos(light.outerConeAngle * math.DEG_TO_RAD);
            }
            if (this._shadowCastingLight) {
                shader.uniforms.u_ShadowSampler = this._shadowCastingLight.shadowTexture;
                shader.uniforms.u_LightViewProjectionMatrix = this._shadowCastingLight.lightViewProjection;
                shader.uniforms.u_ShadowLightIndex = lightingEnvironment.lights.indexOf(this._shadowCastingLight.light);
            }
            var imageBasedLighting = lightingEnvironment.imageBasedLighting;
            if (imageBasedLighting === null || imageBasedLighting === void 0 ? void 0 : imageBasedLighting.valid) {
                shader.uniforms.u_DiffuseEnvSampler = imageBasedLighting.diffuse;
                shader.uniforms.u_SpecularEnvSampler = imageBasedLighting.specular;
                shader.uniforms.u_brdfLUT = imageBasedLighting.lookupBrdf || ImageBasedLighting.defaultLookupBrdf;
                shader.uniforms.u_MipCount = imageBasedLighting.specular.levels - 1;
            }
            if ((_b = this.emissiveTexture) === null || _b === void 0 ? void 0 : _b.valid) {
                shader.uniforms.u_EmissiveSampler = this.emissiveTexture;
                shader.uniforms.u_EmissiveUVSet = this.emissiveTexture.uvSet || 0;
                shader.uniforms.u_EmissiveFactor = this.emissive.rgb;
                if (this.emissiveTexture.transform) {
                    shader.uniforms.u_EmissiveUVTransform = this.emissiveTexture.transform.array;
                }
            }
            if ((_c = this.normalTexture) === null || _c === void 0 ? void 0 : _c.valid) {
                shader.uniforms.u_NormalSampler = this.normalTexture;
                shader.uniforms.u_NormalScale = this.normalTexture.scale || 1;
                shader.uniforms.u_NormalUVSet = this.normalTexture.uvSet || 0;
                if (this.normalTexture.transform) {
                    shader.uniforms.u_NormalUVTransform = this.normalTexture.transform.array;
                }
            }
            if ((_d = this.metallicRoughnessTexture) === null || _d === void 0 ? void 0 : _d.valid) {
                shader.uniforms.u_MetallicRoughnessSampler = this.metallicRoughnessTexture;
                shader.uniforms.u_MetallicRoughnessUVSet = this.metallicRoughnessTexture.uvSet || 0;
                if (this.metallicRoughnessTexture.transform) {
                    shader.uniforms.u_MetallicRoughnessUVTransform = this.metallicRoughnessTexture.transform.array;
                }
            }
            if ((_e = this.occlusionTexture) === null || _e === void 0 ? void 0 : _e.valid) {
                shader.uniforms.u_OcclusionSampler = this.occlusionTexture;
                shader.uniforms.u_OcclusionStrength = this.occlusionTexture.strength || 1;
                shader.uniforms.u_OcclusionUVSet = this.occlusionTexture.uvSet || 0;
                if (this.occlusionTexture.transform) {
                    shader.uniforms.u_OcclusionUVTransform = this.occlusionTexture.transform.array;
                }
            }
        };
        return StandardMaterial;
    }(Material));

    /**
     * Axis-aligned bounding box.
     */
    var AABB = /** @class */ (function () {
        function AABB() {
            var _this = this;
            this._onChanged = function () {
                _this._center.set((_this._min.x + _this._max.x) / 2, (_this._min.y + _this._max.y) / 2, (_this._min.z + _this._max.z) / 2);
                _this._extents.set(Math.abs(_this._max.x - _this._center.x), Math.abs(_this._max.y - _this._center.y), Math.abs(_this._max.z - _this._center.z));
                _this._size.set(_this._extents.x * 2, _this._extents.y * 2, _this._extents.z * 2);
            };
            this._min = new ObservablePoint3D(this._onChanged, this);
            this._max = new ObservablePoint3D(this._onChanged, this);
            this._center = new ObservablePoint3D(function () { }, this);
            this._size = new ObservablePoint3D(function () { }, this);
            this._extents = new ObservablePoint3D(function () { }, this);
        }
        Object.defineProperty(AABB.prototype, "min", {
            /** The minimal point of the bounding box. */
            get: function () {
                return this._min;
            },
            set: function (value) {
                this._min.copyFrom(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "max", {
            /** The maximal point of the bounding box. */
            get: function () {
                return this._max;
            },
            set: function (value) {
                this._max.copyFrom(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "center", {
            /** The center of the bounding box. */
            get: function () {
                return this._center;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "size", {
            /** The size of the bounding box. */
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "extents", {
            /** The extents of the bounding box. */
            get: function () {
                return this._extents;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Creates a new bounding box from the specified source.
         * @param source The source to create the bounding box from.
         */
        AABB.from = function (source) {
            var aabb = new AABB();
            aabb.min.setFrom(source.min);
            aabb.max.setFrom(source.max);
            return aabb;
        };
        /**
         * Grows the bounding box to include the point.
         * @param point The point to include.
         */
        AABB.prototype.encapsulate = function (point) {
            this._min.x = Math.min(this._min.x, point.x);
            this._min.y = Math.min(this._min.y, point.y);
            this._min.z = Math.min(this._min.z, point.z);
            this._max.x = Math.max(this._max.x, point.x);
            this._max.y = Math.max(this._max.y, point.y);
            this._max.z = Math.max(this._max.z, point.z);
        };
        return AABB;
    }());

    var SphereGeometry;
    (function (SphereGeometry) {
        function create(options) {
            if (options === void 0) { options = {}; }
            var _a = options.radius, radius = _a === void 0 ? 1 : _a, _b = options.segments, segments = _b === void 0 ? 32 : _b, _c = options.rings, rings = _c === void 0 ? 16 : _c;
            // Based on https://github.com/mrdoob/three.js/blob/master/src/geometries/SphereGeometry.js
            var grid = [];
            var indices = [];
            var positions = [];
            var uvs = [];
            var normals = [];
            var index = 0;
            for (var iy = 0; iy <= rings; iy++) {
                var vertices = [];
                var v = iy / rings;
                var uOffset = 0;
                if (iy == 0) {
                    uOffset = 0.5 / segments;
                }
                else if (iy == rings) {
                    uOffset = -0.5 / segments;
                }
                for (var ix = 0; ix <= segments; ix++) {
                    var u = ix / segments;
                    var x = -radius * Math.cos(u * Math.PI * 2) *
                        Math.sin(v * Math.PI);
                    var y = radius * Math.cos(v * Math.PI);
                    var z = radius * Math.sin(u * Math.PI * 2) *
                        Math.sin(v * Math.PI);
                    var pos = Vec3.fromValues(x, y, z);
                    positions.push(x, y, z);
                    normals.push.apply(normals, __spreadArray([], __read(Vec3.normalize(pos))));
                    uvs.push(u + uOffset, 1 - v);
                    vertices.push(index++);
                }
                grid.push(vertices);
            }
            for (var iy = 0; iy < rings; iy++) {
                for (var ix = 0; ix < segments; ix++) {
                    var a = grid[iy][ix + 1];
                    var b = grid[iy][ix];
                    var c = grid[iy + 1][ix];
                    var d = grid[iy + 1][ix + 1];
                    if (iy !== 0) {
                        indices.push(a, b, d);
                    }
                    if (iy !== rings - 1) {
                        indices.push(b, c, d);
                    }
                }
            }
            return Object.assign(new MeshGeometry3D(), {
                normals: {
                    buffer: new Float32Array(normals)
                },
                uvs: [{
                        buffer: new Float32Array(uvs)
                    }],
                indices: {
                    buffer: new Uint16Array(indices)
                },
                positions: {
                    buffer: new Float32Array(positions)
                }
            });
        }
        SphereGeometry.create = create;
    })(SphereGeometry || (SphereGeometry = {}));

    /**
     * Represents a mesh which contains geometry and has a material.
     */
    var Mesh3D = /** @class */ (function (_super) {
        __extends(Mesh3D, _super);
        /**
         * Creates a new mesh with the specified geometry and material.
         * @param geometry The geometry for the mesh.
         * @param material The material for the mesh. If the material is empty the mesh won't be rendered.
         */
        function Mesh3D(geometry, material) {
            var _this = _super.call(this) || this;
            _this.geometry = geometry;
            _this.material = material;
            /** The name of the plugin used for rendering the mesh. */
            _this.pluginName = "pipeline";
            /** The enabled render passes for this mesh. */
            _this.enabledRenderPasses = { "material": {} };
            /** Used for sorting the mesh before render. */
            _this.renderSortOrder = 0;
            _this._instances = [];
            if (!geometry) {
                throw new Error("PIXI3D: Geometry is required when creating a mesh.");
            }
            return _this;
        }
        Object.defineProperty(Mesh3D.prototype, "instances", {
            /** An array of instances created from this mesh. */
            get: function () {
                return this._instances;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Creates a new instance of this mesh.
         */
        Mesh3D.prototype.createInstance = function () {
            var _a;
            if (this.material && !this.material.isInstancingSupported) {
                throw new Error("PIXI3D: Can't create instance of mesh, material does not support instancing.");
            }
            return this._instances[this._instances.push(new InstancedMesh3D(this, (_a = this.material) === null || _a === void 0 ? void 0 : _a.createInstance())) - 1];
        };
        /**
         * Removes an instance from this mesh.
         * @param instance The instance to remove.
         */
        Mesh3D.prototype.removeInstance = function (instance) {
            var index = this._instances.indexOf(instance);
            if (index >= 0) {
                this._instances.splice(index, 1);
            }
        };
        /**
         * Enables the render pass with the specified name.
         * @param name The name of the render pass to enable.
         */
        Mesh3D.prototype.enableRenderPass = function (name, options) {
            if (!this.enabledRenderPasses[name]) {
                this.enabledRenderPasses[name] = options || {};
            }
        };
        /**
         * Disables the render pass with the specified name.
         * @param name The name of the render pass to disable.
         * @param options The options for the render pass.
         */
        Mesh3D.prototype.disableRenderPass = function (name) {
            if (this.enabledRenderPasses[name]) {
                delete this.enabledRenderPasses[name];
            }
        };
        /**
         * Returns a value indicating if the specified render pass is enabled.
         * @param name The name of the render pass to check.
         */
        Mesh3D.prototype.isRenderPassEnabled = function (name) {
            return !!this.enabledRenderPasses[name];
        };
        /**
         * Destroys the mesh and it's used resources.
         */
        Mesh3D.prototype.destroy = function (options) {
            if (options === true || (options && options.geometry)) {
                this.geometry.destroy();
            }
            if (options === true || (options && options.material)) {
                if (this.material) {
                    this.material.destroy();
                }
            }
            _super.prototype.destroy.call(this, options);
        };
        Mesh3D.prototype._render = function (renderer) {
            renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
            if (this.skin) {
                this.skin.calculateJointMatrices();
            }
            renderer.plugins[this.pluginName].render(this);
        };
        /**
         * Calculates and returns a axis-aligned bounding box of the mesh in world space.
         */
        Mesh3D.prototype.getBoundingBox = function () {
            var _a, _b;
            if (!((_a = this.geometry.positions) === null || _a === void 0 ? void 0 : _a.min)) {
                return undefined;
            }
            if (!((_b = this.geometry.positions) === null || _b === void 0 ? void 0 : _b.max)) {
                return undefined;
            }
            var min = Vec3.transformMat4(this.geometry.positions.min, this.worldTransform.array);
            var max = Vec3.transformMat4(this.geometry.positions.max, this.worldTransform.array);
            for (var i = 0; i < 3; i++) {
                var temp = min[i];
                min[i] = Math.min(min[i], max[i]);
                max[i] = Math.max(temp, max[i]);
            }
            return AABB.from({ min: min, max: max });
        };
        /**
         * Creates a new quad (flat square) mesh with the specified material.
         * @param material The material to use.
         */
        Mesh3D.createQuad = function (material) {
            if (material === void 0) { material = new StandardMaterial(); }
            return new Mesh3D(QuadGeometry.create(), material);
        };
        /**
         * Creates a new cube (six faces) mesh with the specified material.
         * @param material The material to use.
         */
        Mesh3D.createCube = function (material) {
            if (material === void 0) { material = new StandardMaterial(); }
            return new Mesh3D(CubeGeometry.create(), material);
        };
        /**
         * Creates a new plane (flat square) mesh with the specified material.
         * @param material The material to use.
         */
        Mesh3D.createPlane = function (material) {
            if (material === void 0) { material = new StandardMaterial(); }
            return new Mesh3D(PlaneGeometry.create(), material);
        };
        /**
         * Creates a new uv sphere mesh with the specified material.
         * @param material The material to use.
         * @param options The options used when creating the geometry.
         */
        Mesh3D.createSphere = function (material, options) {
            if (material === void 0) { material = new StandardMaterial(); }
            return new Mesh3D(SphereGeometry.create(options), material);
        };
        return Mesh3D;
    }(Container3D));

    /**
     * Represents an animation.
     */
    var Animation = /** @class */ (function (_super) {
        __extends(Animation, _super);
        /**
         * Creates a new animation with the specified name.
         * @param name Name for the animation.
         */
        function Animation(name) {
            var _this = _super.call(this) || this;
            _this.name = name;
            /** The speed that the animation will play at. */
            _this.speed = 1;
            /** A value indicating if the animation is looping. */
            _this.loop = false;
            return _this;
        }
        /**
         * Starts playing the animation using the specified ticker.
         * @param ticker The ticker to use for updating the animation. If a ticker
         * is not given, the shared ticker will be used.
         */
        Animation.prototype.play = function (ticker$1) {
            var _this = this;
            if (ticker$1 === void 0) { ticker$1 = ticker.Ticker.shared; }
            this.position = 0;
            if (!this._ticker) {
                this._update = function () {
                    _this.update(ticker$1.deltaMS / 1000 * _this.speed);
                };
                this._ticker = ticker$1.add(this._update);
            }
        };
        /**
         * Stops playing the animation.
         */
        Animation.prototype.stop = function () {
            if (this._ticker && this._update) {
                this._ticker.remove(this._update);
                this._ticker = this._update = undefined;
            }
        };
        /**
         * Updates the animation by the specified delta time.
         * @param delta The time in seconds since last frame.
         */
        Animation.prototype.update = function (delta) {
            this.position += delta;
            if (this.position < this.duration) {
                return;
            }
            if (this.loop) {
                if (this.position > this.duration) {
                    this.position = this.position % this.duration;
                }
            }
            else {
                this.position = this.duration;
                this.stop();
            }
            this.emit("complete");
        };
        return Animation;
    }(utils.EventEmitter));

    /**
     * Represents an animation loaded from a glTF model.
     */
    var glTFAnimation = /** @class */ (function (_super) {
        __extends(glTFAnimation, _super);
        /**
         * Creates a new glTF animation.
         * @param channels The channels used by this animation.
         * @param name The name for the animation.
         */
        function glTFAnimation(channels, name) {
            var e_1, _a;
            var _this = _super.call(this, name) || this;
            _this._duration = 0;
            _this._position = 0;
            _this._channels = [];
            try {
                for (var channels_1 = __values(channels), channels_1_1 = channels_1.next(); !channels_1_1.done; channels_1_1 = channels_1.next()) {
                    var channel = channels_1_1.value;
                    _this._duration = Math.max(_this._duration, channel.duration);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (channels_1_1 && !channels_1_1.done && (_a = channels_1.return)) _a.call(channels_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            _this._channels = channels;
            return _this;
        }
        Object.defineProperty(glTFAnimation.prototype, "duration", {
            /** The duration (in seconds) of this animation. */
            get: function () {
                return this._duration;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(glTFAnimation.prototype, "position", {
            /** The current position (in seconds) of this animation. */
            get: function () {
                return this._position;
            },
            set: function (value) {
                var e_2, _a;
                this._position = value;
                try {
                    for (var _b = __values(this._channels), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var channel = _c.value;
                        channel.position = this._position;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            },
            enumerable: false,
            configurable: true
        });
        return glTFAnimation;
    }(Animation));

    /**
     * Represents data for a specific geometry attribute.
     */
    var glTFAttribute = /** @class */ (function () {
        function glTFAttribute(buffer, componentType, stride, min, max) {
            if (stride === void 0) { stride = 0; }
            this.buffer = buffer;
            this.componentType = componentType;
            this.stride = stride;
            this.min = min;
            this.max = max;
        }
        glTFAttribute.from = function (componentType, buffer, offset, size, stride, min, max) {
            switch (componentType) {
                case 5125: return new glTFAttribute(new Uint32Array(buffer, offset, size), componentType, stride, min, max);
                case 5126: return new glTFAttribute(new Float32Array(buffer, offset, size), componentType, stride, min, max);
                case 5120: return new glTFAttribute(new Int8Array(buffer, offset, size), componentType, stride, min, max);
                case 5121: return new glTFAttribute(new Uint8Array(buffer, offset, size), componentType, stride, min, max);
                case 5122: return new glTFAttribute(new Int16Array(buffer, offset, size), componentType, stride, min, max);
                case 5123: return new glTFAttribute(new Uint16Array(buffer, offset, size), componentType, stride, min, max);
                default: {
                    throw new Error("PIXI3D: Unknown component type \"" + componentType + "\".");
                }
            }
        };
        return glTFAttribute;
    }());

    /**
     * Represents a skin used for vertex skinning.
     */
    var Skin = /** @class */ (function () {
        /**
         * Creates a new skin.
         * @param parent The parent container node for the skin.
         * @param joints The array of joints included in the skin.
         */
        function Skin(parent, joints) {
            this.parent = parent;
            this.joints = joints;
            this._jointMatrices = [];
            this._jointNormalMatrices = [];
            this._transformIds = [];
            /** The joint normal matrices which has been calculated. */
            this.jointNormalMatrices = new Float32Array(this.joints.length * 16);
            /** The joint matrices which has been calculated. */
            this.jointMatrices = new Float32Array(this.joints.length * 16);
            for (var i = 0; i < joints.length; i++) {
                this._transformIds.push(-1);
                this._jointMatrices.push(new Float32Array(this.jointMatrices.buffer, 16 * 4 * i, 16));
                this._jointNormalMatrices.push(new Float32Array(this.jointNormalMatrices.buffer, 16 * 4 * i, 16));
            }
        }
        /**
         * Calculates the joint matrices.
         */
        Skin.prototype.calculateJointMatrices = function () {
            for (var i = 0; i < this.joints.length; i++) {
                if (this.joints[i].transform._worldID === this._transformIds[i]) {
                    // The joint transform hasn't changed, no need to calculate.
                    continue;
                }
                this._transformIds[i] = this.joints[i].transform._worldID;
                Mat4.multiply(this.joints[i].worldTransform.array, this.joints[i].inverseBindMatrix, this._jointMatrices[i]);
                Mat4.multiply(this.parent.transform.inverseWorldTransform.array, this._jointMatrices[i], this._jointMatrices[i]);
                Mat4.invert(this._jointMatrices[i], this._jointNormalMatrices[i]);
                Mat4.transpose(this._jointNormalMatrices[i], this._jointNormalMatrices[i]);
            }
        };
        return Skin;
    }());

    /**
     * Represents a joint used for vertex skinning.
     */
    var Joint = /** @class */ (function (_super) {
        __extends(Joint, _super);
        /**
         * Creates a new joint.
         * @param inverseBindMatrix The inverse of the global transform matrix.
         */
        function Joint(inverseBindMatrix) {
            var _this = _super.call(this) || this;
            _this.inverseBindMatrix = inverseBindMatrix;
            return _this;
        }
        return Joint;
    }(Container3D));

    var glTFLinear = /** @class */ (function () {
        function glTFLinear(_output, _stride) {
            this._output = _output;
            this._stride = _stride;
            this._data = new Float32Array(_stride);
        }
        glTFLinear.prototype.interpolate = function (frame, position) {
            var pos1 = (frame + 0) * this._stride;
            var pos2 = (frame + 1) * this._stride;
            for (var i = 0; i < this._stride; i++) {
                if (this._output.length > pos2) {
                    this._data[i] = (1 - position) * this._output[pos1 + i] + position * this._output[pos2 + i];
                }
                else {
                    this._data[i] = this._output[pos1 + i];
                }
            }
            return this._data;
        };
        return glTFLinear;
    }());

    var glTFCubicSpline = /** @class */ (function () {
        function glTFCubicSpline(_input, _output, _stride) {
            this._input = _input;
            this._output = _output;
            this._stride = _stride;
            this._data = new Float32Array(_stride);
        }
        glTFCubicSpline.prototype.interpolate = function (frame, position) {
            var diff = this._input[frame + 1] - this._input[frame];
            var pos1 = (frame + 0) * this._stride * 3;
            var pos2 = (frame + 1) * this._stride * 3;
            for (var i = 0; i < this._stride; i++) {
                this._data[i] = glTFCubicSpline.calculate(position, this._output[pos1 + i + 1 * this._stride], this._output[pos2 + i + 1 * this._stride], diff * this._output[pos2 + i], diff * this._output[pos1 + i + 2 * this._stride]);
            }
            return this._data;
        };
        glTFCubicSpline.calculate = function (t, p0, p1, m0, m1) {
            return ((2 * (Math.pow(t, 3)) - 3 * (Math.pow(t, 2)) + 1) * p0) + (((Math.pow(t, 3)) - 2 * (Math.pow(t, 2)) + t) * m0) + ((-2 * (Math.pow(t, 3)) + 3 * (Math.pow(t, 2))) * p1) + (((Math.pow(t, 3)) - (Math.pow(t, 2))) * m1);
        };
        return glTFCubicSpline;
    }());

    var glTFStep = /** @class */ (function () {
        function glTFStep(_output, _stride) {
            this._output = _output;
            this._stride = _stride;
            this._data = new Float32Array(_stride);
        }
        glTFStep.prototype.interpolate = function (frame) {
            for (var i = 0; i < this._stride; i++) {
                this._data[i] = this._output[frame * this._stride + i];
            }
            return this._data;
        };
        return glTFStep;
    }());

    var glTFInterpolationFactory = /** @class */ (function () {
        function glTFInterpolationFactory() {
        }
        glTFInterpolationFactory.create = function (type, input, output, stride) {
            switch (type) {
                case "LINEAR": {
                    return new glTFLinear(output, stride);
                }
                case "CUBICSPLINE": {
                    return new glTFCubicSpline(input, output, stride);
                }
                case "STEP": {
                    return new glTFStep(output, stride);
                }
            }
            throw new Error("PIXI3D: Unknown interpolation type \"" + type + "\"");
        };
        return glTFInterpolationFactory;
    }());

    /**
     * Represents an glTF animation channel which targets a specific node.
     */
    var glTFChannel = /** @class */ (function () {
        /**
         * Creates a new channel with the specified input and interpolation.
         * @param input An array of inputs representing linear time in seconds.
         * @param interpolation The interpolation method to use.
         */
        function glTFChannel(input, interpolation) {
            this._position = 0;
            this._frame = 0;
            this._input = input;
            this._interpolation = interpolation;
        }
        Object.defineProperty(glTFChannel.prototype, "position", {
            /** The position (in seconds) for this channel. */
            get: function () {
                return this._position;
            },
            set: function (value) {
                this.setPosition(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(glTFChannel.prototype, "duration", {
            /** The duration (in seconds) for this channel. */
            get: function () {
                return this._input[this._input.length - 1];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(glTFChannel.prototype, "frame", {
            /** The current frame for this channel. */
            get: function () {
                return this._frame;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(glTFChannel.prototype, "length", {
            /** The number of frames for this channel. */
            get: function () {
                return this._input.length;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Sets the position and updates the current frame and animation.
         * @param position The position to set for this channel.
         */
        glTFChannel.prototype.setPosition = function (position) {
            this._position = position;
            this._frame = this.calculateFrame(this._position);
            this.updateTarget(this._interpolation.interpolate(this._frame, this.calculateFramePosition(this._frame, this._position)));
        };
        /**
         * Updates the channel with the specified delta time in seconds.
         * @param delta The time (in seconds) since last frame.
         */
        glTFChannel.prototype.update = function (delta) {
            this.position += delta;
        };
        /**
         * Calculates the position within the specified frame.
         * @param frame The frame to calculate the position in.
         * @param position The position of this channel.
         */
        glTFChannel.prototype.calculateFramePosition = function (frame, position) {
            if (frame === this._input.length - 1) {
                return 1;
            }
            return (position - this._input[frame]) / (this._input[frame + 1] - this._input[frame]);
        };
        /**
         * Calculates the current frame for the specified position.
         * @param position The position of this channel.
         */
        glTFChannel.prototype.calculateFrame = function (position) {
            if (position < this._input[0]) {
                return 0;
            }
            for (var i = 0; i < this._input.length - 1; i++) {
                if (position >= this._input[i] && position < this._input[i + 1]) {
                    return i;
                }
            }
            return this._input.length - 1;
        };
        return glTFChannel;
    }());

    var glTFRotation = /** @class */ (function (_super) {
        __extends(glTFRotation, _super);
        function glTFRotation(transform, input, interpolation) {
            var _this = _super.call(this, input, interpolation) || this;
            _this._transform = transform;
            return _this;
        }
        glTFRotation.prototype.updateTarget = function (data) {
            this._transform.rotationQuaternion.set(data[0], data[1], data[2], data[3]);
        };
        return glTFRotation;
    }(glTFChannel));

    var glTFScale = /** @class */ (function (_super) {
        __extends(glTFScale, _super);
        function glTFScale(transform, input, interpolation) {
            var _this = _super.call(this, input, interpolation) || this;
            _this._transform = transform;
            return _this;
        }
        glTFScale.prototype.updateTarget = function (data) {
            this._transform.scale.set(data[0], data[1], data[2]);
        };
        return glTFScale;
    }(glTFChannel));

    var glTFSphericalLinear = /** @class */ (function () {
        function glTFSphericalLinear(_output) {
            this._output = _output;
            this._data = new Float32Array(4);
        }
        glTFSphericalLinear.prototype.interpolate = function (frame, position) {
            var pos1 = (frame + 0) * 4;
            var pos2 = (frame + 1) * 4;
            var a = Quat.set(this._output[pos1], this._output[pos1 + 1], this._output[pos1 + 2], this._output[pos1 + 3], new Float32Array(4));
            if (this._output.length <= pos2) {
                return Quat.normalize(a, this._data);
            }
            var b = Quat.set(this._output[pos2], this._output[pos2 + 1], this._output[pos2 + 2], this._output[pos2 + 3], new Float32Array(4));
            return Quat.normalize(Quat.slerp(a, b, position, this._data), this._data);
        };
        return glTFSphericalLinear;
    }());

    var glTFTranslation = /** @class */ (function (_super) {
        __extends(glTFTranslation, _super);
        function glTFTranslation(transform, input, interpolation) {
            var _this = _super.call(this, input, interpolation) || this;
            _this._transform = transform;
            return _this;
        }
        glTFTranslation.prototype.updateTarget = function (data) {
            this._transform.position.set(data[0], data[1], data[2]);
        };
        return glTFTranslation;
    }(glTFChannel));

    var glTFWeights = /** @class */ (function (_super) {
        __extends(glTFWeights, _super);
        function glTFWeights(weights, input, interpolation) {
            var _this = _super.call(this, input, interpolation) || this;
            _this._weights = weights;
            return _this;
        }
        glTFWeights.prototype.updateTarget = function (data) {
            for (var i = 0; i < data.length; i++) {
                this._weights[i] = data[i];
            }
        };
        return glTFWeights;
    }(glTFChannel));

    var glTFChannelFactory = /** @class */ (function () {
        function glTFChannelFactory() {
        }
        glTFChannelFactory.create = function (input, output, interpolation, path, target) {
            if (path === "translation") {
                return new glTFTranslation(target.transform, input, glTFInterpolationFactory.create(interpolation, input, output, 3));
            }
            if (path === "scale") {
                return new glTFScale(target.transform, input, glTFInterpolationFactory.create(interpolation, input, output, 3));
            }
            if (path === "rotation") {
                if (interpolation === "LINEAR") {
                    return new glTFRotation(target.transform, input, new glTFSphericalLinear(output));
                }
                return new glTFRotation(target.transform, input, glTFInterpolationFactory.create(interpolation, input, output, 4));
            }
            if (path === "weights") {
                var weights = target.children[0].targetWeights;
                if (!weights) {
                    return undefined;
                }
                return new glTFWeights(weights, input, glTFInterpolationFactory.create(interpolation, input, output, weights.length));
            }
            throw new Error("PIXI3D: Unknown channel path \"" + path + "\"");
        };
        return glTFChannelFactory;
    }());

    var _a;
    /**
     * Parses glTF assets and creates models and meshes.
     */
    var glTFParser = /** @class */ (function () {
        /**
         * Creates a new parser using the specified asset.
         * @param asset The asset to parse.
         * @param materialFactory The material factory to use.
         */
        function glTFParser(asset, materialFactory) {
            var _a;
            this._textures = [];
            this._asset = asset;
            this._materialFactory = materialFactory || new StandardMaterialFactory();
            this._descriptor = this._asset.descriptor;
            for (var i = 0; i < ((_a = this._descriptor.textures) === null || _a === void 0 ? void 0 : _a.length); i++) {
                this._textures.push(this.parseTexture(i));
            }
        }
        /**
         * Creates a model from the specified asset.
         * @param asset The asset to create the model from.
         * @param materialFactory The material factory to use.
         */
        glTFParser.createModel = function (asset, materialFactory) {
            return new glTFParser(asset, materialFactory).parseModel();
        };
        /**
         * Creates a mesh from the specified asset.
         * @param asset The asset to create the mesh from.
         * @param materialFactory The material factory to use.
         * @param mesh The mesh index in the JSON descriptor.
         */
        glTFParser.createMesh = function (asset, materialFactory, mesh) {
            if (mesh === void 0) { mesh = 0; }
            return new glTFParser(asset, materialFactory).parseMesh(mesh);
        };
        /**
         * Creates a new buffer view from the specified accessor.
         * @param accessor The accessor object or index.
         */
        glTFParser.prototype.parseBuffer = function (accessor) {
            if (accessor === undefined) {
                return undefined;
            }
            if (typeof accessor === "number") {
                accessor = this._asset.descriptor.accessors[accessor];
            }
            var bufferView = this._descriptor.bufferViews[accessor.bufferView || 0];
            var offset = accessor.byteOffset || 0;
            if (bufferView.byteOffset !== undefined) {
                offset += bufferView.byteOffset;
            }
            var size = accessor.count * componentCount[accessor.type];
            if (bufferView.byteStride !== undefined && bufferView.byteStride !== 0) {
                size = bufferView.byteStride / componentSize[accessor.componentType] * (accessor.count - 1) + componentCount[accessor.type];
            }
            var buffer = this._asset.buffers[bufferView.buffer];
            return glTFAttribute.from(accessor.componentType, buffer, offset, size, bufferView.byteStride, accessor.min, accessor.max);
        };
        /**
         * Creates an animation from the specified animation.
         * @param animation The source animation object or index.
         * @param nodes The array of nodes which are potential targets for the animation.
         */
        glTFParser.prototype.parseAnimation = function (animation, nodes) {
            var e_1, _a;
            if (typeof animation === "number") {
                animation = this._asset.descriptor.animations[animation];
            }
            var channels = [];
            try {
                for (var _b = __values(animation.channels), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var channel = _c.value;
                    var sampler = animation.samplers[channel.sampler];
                    var input = this.parseBuffer(sampler.input);
                    if (input === undefined) {
                        continue;
                    }
                    var output = this.parseBuffer(sampler.output);
                    if (output === undefined) {
                        continue;
                    }
                    var animationChannel = glTFChannelFactory.create(input.buffer, output.buffer, sampler.interpolation || "LINEAR", channel.target.path, nodes[channel.target.node]);
                    if (animationChannel) {
                        channels.push(animationChannel);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return new glTFAnimation(channels, animation.name);
        };
        /**
         * Creates a material from the specified source.
         * @param material The source material object or index.
         */
        glTFParser.prototype.parseMaterial = function (material) {
            if (typeof material === "number") {
                material = this._asset.descriptor.materials[material];
            }
            var result = new glTFMaterial();
            if (!material) {
                return this._materialFactory.create(result);
            }
            if (material.occlusionTexture !== undefined) {
                result.occlusionTexture = this._textures[material.occlusionTexture.index].clone();
                result.occlusionTexture.strength = material.occlusionTexture.strength;
                result.occlusionTexture.texCoord = material.occlusionTexture.texCoord;
                if (material.occlusionTexture.extensions && material.occlusionTexture.extensions.KHR_texture_transform) {
                    result.occlusionTexture.transform = material.occlusionTexture.extensions.KHR_texture_transform;
                    if (material.occlusionTexture.extensions.KHR_texture_transform.texCoord !== undefined) {
                        result.occlusionTexture.texCoord = material.occlusionTexture.extensions.KHR_texture_transform.texCoord;
                    }
                }
            }
            if (material.normalTexture !== undefined) {
                result.normalTexture = this._textures[material.normalTexture.index].clone();
                result.normalTexture.scale = material.normalTexture.scale || 1;
                result.normalTexture.texCoord = material.normalTexture.texCoord;
                if (material.normalTexture.extensions && material.normalTexture.extensions.KHR_texture_transform) {
                    result.normalTexture.transform = material.normalTexture.extensions.KHR_texture_transform;
                    if (material.normalTexture.extensions.KHR_texture_transform.texCoord !== undefined) {
                        result.normalTexture.texCoord = material.normalTexture.extensions.KHR_texture_transform.texCoord;
                    }
                }
            }
            if (material.emissiveTexture !== undefined) {
                result.emissiveTexture = this._textures[material.emissiveTexture.index].clone();
                result.emissiveTexture.texCoord = material.emissiveTexture.texCoord;
                if (material.emissiveTexture.extensions && material.emissiveTexture.extensions.KHR_texture_transform) {
                    result.emissiveTexture.transform = material.emissiveTexture.extensions.KHR_texture_transform;
                    if (material.emissiveTexture.extensions.KHR_texture_transform.texCoord !== undefined) {
                        result.emissiveTexture.texCoord = material.emissiveTexture.extensions.KHR_texture_transform.texCoord;
                    }
                }
            }
            if (material.doubleSided !== undefined) {
                result.doubleSided = material.doubleSided;
            }
            if (material.emissiveFactor) {
                result.emissiveFactor = material.emissiveFactor;
            }
            if (material.alphaMode) {
                result.alphaMode = material.alphaMode;
            }
            if (material.alphaCutoff !== undefined) {
                result.alphaCutoff = material.alphaCutoff;
            }
            var pbr = material.pbrMetallicRoughness;
            if ((pbr === null || pbr === void 0 ? void 0 : pbr.metallicRoughnessTexture) !== undefined) {
                result.metallicRoughnessTexture = this._textures[pbr.metallicRoughnessTexture.index].clone();
                result.metallicRoughnessTexture.texCoord = pbr.metallicRoughnessTexture.texCoord;
                if (pbr.metallicRoughnessTexture.extensions && pbr.metallicRoughnessTexture.extensions.KHR_texture_transform) {
                    result.metallicRoughnessTexture.transform = pbr.metallicRoughnessTexture.extensions.KHR_texture_transform;
                    if (pbr.metallicRoughnessTexture.extensions.KHR_texture_transform.texCoord !== undefined) {
                        result.metallicRoughnessTexture.texCoord = pbr.metallicRoughnessTexture.extensions.KHR_texture_transform.texCoord;
                    }
                }
            }
            if (pbr === null || pbr === void 0 ? void 0 : pbr.baseColorFactor) {
                result.baseColor = pbr.baseColorFactor;
            }
            if ((pbr === null || pbr === void 0 ? void 0 : pbr.baseColorTexture) !== undefined) {
                result.baseColorTexture = this._textures[pbr.baseColorTexture.index].clone();
                result.baseColorTexture.texCoord = pbr.baseColorTexture.texCoord;
                if (pbr.baseColorTexture.extensions && pbr.baseColorTexture.extensions.KHR_texture_transform) {
                    result.baseColorTexture.transform = pbr.baseColorTexture.extensions.KHR_texture_transform;
                    if (pbr.baseColorTexture.extensions.KHR_texture_transform.texCoord !== undefined) {
                        result.baseColorTexture.texCoord = pbr.baseColorTexture.extensions.KHR_texture_transform.texCoord;
                    }
                }
            }
            if ((pbr === null || pbr === void 0 ? void 0 : pbr.metallicFactor) !== undefined) {
                result.metallic = pbr.metallicFactor;
            }
            if ((pbr === null || pbr === void 0 ? void 0 : pbr.roughnessFactor) !== undefined) {
                result.roughness = pbr.roughnessFactor;
            }
            if (material.extensions) {
                result.unlit = material.extensions["KHR_materials_unlit"] !== undefined;
            }
            return this._materialFactory.create(result);
        };
        /**
         * Returns the texture used by the specified object.
         * @param source The source object or index.
         */
        glTFParser.prototype.parseTexture = function (index) {
            var texture = this._descriptor.textures[index];
            var image = this._asset.images[texture.source];
            var result = new PixiCore.Texture(new PixiCore.BaseTexture(image.baseTexture.resource, {
                wrapMode: constants.WRAP_MODES.REPEAT,
                // Went back and forth about NO_PREMULTIPLIED_ALPHA. The default in
                // PixiJS is to have premultiplied alpha textures, but this may not work
                // so well when rendering objects as opaque (which have alpha equal to 0).
                // In that case it's impossible to retrieve the original RGB values, 
                // because they are all zero when using premultiplied alpha. Both the glTF
                // Sample Viewer and Babylon.js uses NO_PREMULTIPLIED_ALPHA so decided to
                // do the same.
                alphaMode: constants.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA
            }));
            if (this._descriptor.samplers && texture.sampler !== undefined) {
                var sampler = this._descriptor.samplers[texture.sampler];
                switch (sampler.wrapS) {
                    case 10497:
                        result.baseTexture.wrapMode = constants.WRAP_MODES.REPEAT;
                        break;
                    case 33648:
                        result.baseTexture.wrapMode = constants.WRAP_MODES.MIRRORED_REPEAT;
                        break;
                    case 33071:
                        result.baseTexture.wrapMode = constants.WRAP_MODES.CLAMP;
                        break;
                }
            }
            return result;
        };
        /**
         * Creates an array of meshes from the specified mesh.
         * @param mesh The source mesh object or index.
         * @returns An array which contain arrays of meshes. This is because of the
         * structure used in glTF, where each mesh contain a number of primitives.
         * Read more about this in discussion at https://github.com/KhronosGroup/glTF/issues/821
         */
        glTFParser.prototype.parseMesh = function (mesh) {
            var _this = this;
            if (typeof mesh === "number") {
                mesh = this._asset.descriptor.meshes[mesh];
            }
            var weights = mesh.weights || [];
            return mesh.primitives.map(function (primitive) {
                return Object.assign(_this.parsePrimitive(primitive), {
                    name: mesh.name,
                    targetWeights: weights
                });
            });
        };
        /**
         * Creates a skin from the specified source.
         * @param skin The source skin object or index.
         * @param target The target container for the skin.
         * @param nodes The array of nodes which are potential targets for the animation.
         */
        glTFParser.prototype.parseSkin = function (skin, target, nodes) {
            if (typeof skin === "number") {
                skin = this._asset.descriptor.skins[skin];
            }
            return new Skin(target, skin.joints.map(function (joint) { return nodes[joint]; }));
        };
        /**
         * Creates a mesh from the specified primitive.
         * @param primitive The source primitive object.
         */
        glTFParser.prototype.parsePrimitive = function (primitive) {
            var attributes = primitive.attributes, targets = primitive.targets;
            var geometry = Object.assign(new MeshGeometry3D(), {
                indices: this.parseBuffer(primitive.indices),
                positions: this.parseBuffer(attributes["POSITION"]),
                normals: this.parseBuffer(attributes["NORMAL"]),
                tangents: this.parseBuffer(attributes["TANGENT"]),
                joints: this.parseBuffer(attributes["JOINTS_0"]),
                weights: this.parseBuffer(attributes["WEIGHTS_0"]),
                colors: this.parseBuffer(attributes["COLOR_0"])
            });
            for (var i = 0; true; i++) {
                var buffer = this.parseBuffer(attributes["TEXCOORD_" + i]);
                if (buffer === undefined) {
                    break;
                }
                geometry.uvs = geometry.uvs || [];
                geometry.uvs.push(buffer);
            }
            if (targets) {
                for (var i = 0; i < targets.length; i++) {
                    geometry.targets = geometry.targets || [];
                    geometry.targets.push({
                        positions: this.parseBuffer(targets[i]["POSITION"]),
                        normals: this.parseBuffer(targets[i]["NORMAL"]),
                        tangents: this.parseBuffer(targets[i]["TANGENT"])
                    });
                }
            }
            var material;
            if (primitive.material !== undefined) {
                material = this.parseMaterial(this._asset.descriptor.materials[primitive.material]);
            }
            else {
                material = this.parseMaterial();
            }
            return new Mesh3D(geometry, material);
        };
        /**
         * Creates a container or joint from the specified node index.
         * @param node The index of the node.
         */
        glTFParser.prototype.parseNode = function (index) {
            var e_2, _a;
            var node = this._asset.descriptor.nodes[index];
            var joint;
            try {
                for (var _b = __values(this._asset.descriptor.skins || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var skin = _c.value;
                    var i = skin.joints.indexOf(index);
                    if (i >= 0) {
                        // This node is a joint
                        var inverseBindMatrices = this.parseBuffer(skin.inverseBindMatrices);
                        var inverseBindMatrix = inverseBindMatrices === null || inverseBindMatrices === void 0 ? void 0 : inverseBindMatrices.buffer.slice(i * 16, i * 16 + 16);
                        joint = Object.assign(new Joint(inverseBindMatrix), {
                            name: node.name
                        });
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var container = joint || Object.assign(new Container3D(), {
                name: node.name
            });
            if (node.translation) {
                container.position.set(node.translation[0], node.translation[1], node.translation[2]);
            }
            if (node.rotation) {
                container.rotationQuaternion.set(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3]);
            }
            if (node.scale) {
                container.scale.set(node.scale[0], node.scale[1], node.scale[2]);
            }
            if (node.matrix) {
                container.transform.setFromMatrix(new Matrix4(node.matrix));
            }
            return container;
        };
        glTFParser.prototype.parseModel = function () {
            var e_3, _a, e_4, _b;
            var _this = this;
            var nodes = this._descriptor.nodes.map(function (n, i) {
                return _this.parseNode(i);
            });
            var scene = this._descriptor.scenes[this._asset.descriptor.scene || 0];
            var model = new Model();
            var createHierarchy = function (parent, node) {
                var e_5, _a, e_6, _b;
                var mesh = _this._asset.descriptor.nodes[node].mesh;
                var skin;
                if (_this._asset.descriptor.nodes[node].skin !== undefined) {
                    skin = _this.parseSkin(_this._asset.descriptor.nodes[node].skin, nodes[node], nodes);
                }
                if (mesh !== undefined) {
                    try {
                        for (var _c = __values(_this.parseMesh(mesh)), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var primitive = _d.value;
                            model.meshes.push(nodes[node].addChild(primitive));
                            model.meshes[model.meshes.length - 1].skin = skin;
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                }
                parent.addChild(nodes[node]);
                if (!_this._asset.descriptor.nodes[node].children) {
                    return;
                }
                try {
                    for (var _e = __values(_this._asset.descriptor.nodes[node].children), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var child = _f.value;
                        createHierarchy(nodes[node], child);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            };
            try {
                for (var _c = __values(scene.nodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var node = _d.value;
                    createHierarchy(model, node);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (this._asset.descriptor.animations) {
                try {
                    for (var _e = __values(this._asset.descriptor.animations), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var animation = _f.value;
                        model.animations.push(this.parseAnimation(animation, nodes));
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
            return model;
        };
        return glTFParser;
    }());
    var componentCount = {
        SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16
    };
    var componentSize = (_a = {},
        _a[5120] = 1,
        _a[5121] = 1,
        _a[5122] = 2,
        _a[5123] = 2,
        _a[5125] = 4,
        _a[5126] = 4,
        _a);

    function clone(node, parent, meshes) {
        var e_1, _a;
        try {
            for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                if (child instanceof Mesh3D) {
                    var mesh = child.createInstance();
                    mesh.name = child.name;
                    meshes.push(parent.addChild(mesh));
                }
                else if (child instanceof Container3D) {
                    var copy = parent.addChild(new Container3D());
                    copy.name = node.name;
                    copy.position = child.position;
                    copy.scale = child.scale;
                    copy.rotationQuaternion = child.rotationQuaternion;
                    clone(child, copy, meshes);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    /**
     * Represents an instance of a model.
     */
    var InstancedModel = /** @class */ (function (_super) {
        __extends(InstancedModel, _super);
        /**
         * Creates a new model instance from the specified model.
         * @param model The model to create instance from.
         */
        function InstancedModel(model) {
            var _this = _super.call(this) || this;
            /** The meshes included in the model. */
            _this.meshes = [];
            clone(model, _this, _this.meshes);
            return _this;
        }
        return InstancedModel;
    }(Container3D));

    /**
     * Represents a model which has been loaded from a file. Contains a hierarchy of meshes and animations.
     */
    var Model = /** @class */ (function (_super) {
        __extends(Model, _super);
        function Model() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /** The animations included in the model. */
            _this.animations = [];
            /**
             * The meshes included in the model. Note that this array and the actual
             * childen are not automatically synchronized after the model has been loaded.
             */
            _this.meshes = [];
            return _this;
        }
        /**
         * Creates a new model from a source.
         * @param source The source to create the model from.
         * @param materialFactory The factory to use for creating materials.
         */
        Model.from = function (source, materialFactory) {
            return glTFParser.createModel(source, materialFactory);
        };
        /**
         * Creates a new instance of this model.
         */
        Model.prototype.createInstance = function () {
            return new InstancedModel(this);
        };
        /**
         * Calculates and returns a axis-aligned bounding box of the model in world
         * space. The bounding box will encapsulate the meshes included in the model.
         */
        Model.prototype.getBoundingBox = function () {
            this.updateTransform();
            var aabb = new AABB();
            var mesh = this.meshes[0].getBoundingBox();
            if (mesh) {
                aabb.min = mesh.min;
                aabb.max = mesh.max;
            }
            for (var i = 1; i < this.meshes.length; i++) {
                var mesh_1 = this.meshes[i].getBoundingBox();
                if (mesh_1) {
                    aabb.encapsulate(mesh_1.min);
                    aabb.encapsulate(mesh_1.max);
                }
            }
            return aabb;
        };
        return Model;
    }(Container3D));

    var Light = /** @class */ (function (_super) {
        __extends(Light, _super);
        function Light() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /** The type of the light. */
            _this.type = exports.LightType.point;
            /** The color of the light. */
            _this.color = new Color(1, 1, 1);
            /** The range of the light. */
            _this.range = 10;
            /** The intensity of the light. */
            _this.intensity = 10;
            /** The inner cone angle specified in degrees. */
            _this.innerConeAngle = 0;
            /** The outer cone angle specified in degrees. */
            _this.outerConeAngle = 45;
            return _this;
        }
        return Light;
    }(Container3D));

    /**
     * Pass used for rendering materials.
     */
    var MaterialRenderPass = /** @class */ (function () {
        /**
         * Creates a new material render pass.
         * @param renderer The renderer to use.
         * @param name The name of the render pass.
         */
        function MaterialRenderPass(renderer, name) {
            this.renderer = renderer;
            this.name = name;
            /** The color (r,g,b,a) used for clearing the render texture. If this value is empty, the render texture will not be cleared. */
            this.clearColor = new Color(0, 0, 0, 0);
        }
        Object.defineProperty(MaterialRenderPass.prototype, "renderTexture", {
            /** The texture used when rendering to a texture. */
            get: function () {
                return this._renderTexture;
            },
            set: function (value) {
                this._renderTexture = value;
            },
            enumerable: false,
            configurable: true
        });
        MaterialRenderPass.prototype.clear = function () {
            if (this._renderTexture && this.clearColor) {
                var current = this.renderer.renderTexture.current;
                this.renderer.renderTexture.bind(this._renderTexture);
                this.renderer.renderTexture.clear(Array.from(this.clearColor.rgba));
                this.renderer.renderTexture.bind(current || undefined);
            }
        };
        MaterialRenderPass.prototype.render = function (meshes) {
            var e_1, _a;
            var current = this.renderer.renderTexture.current;
            if (this._renderTexture) {
                this.renderer.renderTexture.bind(this._renderTexture);
            }
            try {
                for (var meshes_1 = __values(meshes), meshes_1_1 = meshes_1.next(); !meshes_1_1.done; meshes_1_1 = meshes_1.next()) {
                    var mesh = meshes_1_1.value;
                    if (mesh.material) {
                        mesh.material.render(mesh, this.renderer);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (meshes_1_1 && !meshes_1_1.done && (_a = meshes_1.return)) _a.call(meshes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (this._renderTexture) {
                this.renderer.renderTexture.bind(current || undefined);
            }
        };
        return MaterialRenderPass;
    }());

    var Shader$9 = {"source":"#version 100\n\nattribute vec3 a_Position;\nattribute vec2 a_UV1;\n\nvarying vec2 v_UV1;\n\nvoid main() {\n  v_UV1 = a_UV1;\n  gl_Position = vec4(a_Position, 1.0);\n}"};

    var Shader$8 = {"source":"#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvarying vec2 v_UV1;\n\nuniform vec2 u_BlurScale;\nuniform sampler2D u_FilterSampler;\n\nvoid main() {\n  vec4 color = vec4(0.0);\n\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-3.0) * u_BlurScale.xy)) * (1.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-2.0) * u_BlurScale.xy)) * (6.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-1.0) * u_BlurScale.xy)) * (15.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+0.0) * u_BlurScale.xy)) * (20.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+1.0) * u_BlurScale.xy)) * (15.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+2.0) * u_BlurScale.xy)) * (6.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+3.0) * u_BlurScale.xy)) * (1.0/64.0);\n\n  gl_FragColor = color;\n}"};

    var ShadowFilter = /** @class */ (function () {
        function ShadowFilter(renderer) {
            this.renderer = renderer;
            this._mesh = Mesh3D.createQuad();
            this._gaussianBlurShader = new MeshShader(PixiCore.Program.from(Shader$9.source, Shader$8.source));
        }
        ShadowFilter.prototype.applyGaussianBlur = function (light) {
            this.applyBlurScale(light.shadowTexture, light.filterTexture, new Float32Array([0, light.softness / light.shadowTexture.height]));
            this.applyBlurScale(light.filterTexture, light.shadowTexture, new Float32Array([light.softness / light.shadowTexture.width, 0]));
        };
        ShadowFilter.prototype.applyBlurScale = function (input, output, scale) {
            this.renderer.renderTexture.bind(output);
            this.renderer.renderTexture.clear();
            this._gaussianBlurShader.uniforms.u_FilterSampler = input;
            this._gaussianBlurShader.uniforms.u_BlurScale = scale;
            this._gaussianBlurShader.render(this._mesh, this.renderer);
            this.renderer.renderTexture.bind(undefined);
        };
        return ShadowFilter;
    }());

    var Shader$7 = {"source":"#version 100\n\n#define FEATURES\n\nattribute vec3 a_Position;\n\n#ifdef USE_SKINNING\nattribute vec4 a_Joint1;\nattribute vec4 a_Weight1;\n#endif\n\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\n\n#ifdef USE_SKINNING\n  #ifdef USE_SKINNING_TEXTURE\n    uniform sampler2D u_jointMatrixSampler;\n  #else\n    uniform mat4 u_jointMatrix[MAX_JOINT_COUNT];\n  #endif\n#endif\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.0)\n#define ROW1_U ((0.5 + 1.0) / 4.0)\n#define ROW2_U ((0.5 + 2.0) / 4.0)\n#define ROW3_U ((0.5 + 3.0) / 4.0)\n\n#ifdef USE_SKINNING\nmat4 getJointMatrix(float boneNdx) {\n    #ifdef USE_SKINNING_TEXTURE\n    float v = (boneNdx + 0.5) / float(MAX_JOINT_COUNT);\n    return mat4(\n        texture2D(u_jointMatrixSampler, vec2(ROW0_U, v)),\n        texture2D(u_jointMatrixSampler, vec2(ROW1_U, v)),\n        texture2D(u_jointMatrixSampler, vec2(ROW2_U, v)),\n        texture2D(u_jointMatrixSampler, vec2(ROW3_U, v))\n    );\n    #else\n    return u_jointMatrix[int(boneNdx)];\n    #endif\n}\n\nmat4 getSkinningMatrix()\n{\n    mat4 skin = mat4(0);\n    skin +=\n        a_Weight1.x * getJointMatrix(a_Joint1.x) +\n        a_Weight1.y * getJointMatrix(a_Joint1.y) +\n        a_Weight1.z * getJointMatrix(a_Joint1.z) +\n        a_Weight1.w * getJointMatrix(a_Joint1.w);\n    return skin;\n}\n#endif\n\nvoid main() {\n  vec4 pos = vec4(a_Position, 1.0);\n  #ifdef USE_SKINNING\n    pos = getSkinningMatrix() * pos;\n  #endif\n  gl_Position = u_ViewProjectionMatrix * u_ModelMatrix * pos;\n}"};

    var Shader$6 = {"source":"#version 100\n\n#extension GL_OES_standard_derivatives : enable\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvoid main() {\n  float depth = gl_FragCoord.z;\n  float dx = 0.0;\n  float dy = 0.0;\n\n  #ifdef GL_OES_standard_derivatives\n    dx = dFdx(depth);\n    dy = dFdy(depth);\n  #endif\n\n  float moment2 = depth * depth + 0.25 * (dx * dx + dy * dy);\n  gl_FragColor = vec4(1.0 - depth, 1.0 - moment2, 0.0, 0.0);\n}"};

    var ShadowShader = /** @class */ (function (_super) {
        __extends(ShadowShader, _super);
        function ShadowShader(renderer, features) {
            if (features === void 0) { features = []; }
            return _super.call(this, PixiCore.Program.from(StandardShaderSource.build(Shader$7.source, features, renderer), StandardShaderSource.build(Shader$6.source, features, renderer))) || this;
        }
        Object.defineProperty(ShadowShader.prototype, "maxSupportedJoints", {
            get: function () {
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        ShadowShader.prototype.createShaderGeometry = function (geometry) {
            var result = new PixiCore.Geometry();
            if (geometry.indices) {
                if (geometry.indices.buffer.BYTES_PER_ELEMENT === 1) {
                    // PIXI seems to have problems with Uint8Array, let's convert to UNSIGNED_SHORT.
                    result.addIndex(new PixiCore.Buffer(new Uint16Array(geometry.indices.buffer)));
                }
                else {
                    result.addIndex(new PixiCore.Buffer(geometry.indices.buffer));
                }
            }
            if (geometry.positions) {
                result.addAttribute("a_Position", new PixiCore.Buffer(geometry.positions.buffer), 3, false, geometry.positions.componentType, geometry.positions.stride);
            }
            return result;
        };
        Object.defineProperty(ShadowShader.prototype, "name", {
            get: function () {
                return "shadow-shader";
            },
            enumerable: false,
            configurable: true
        });
        ShadowShader.prototype.updateUniforms = function (mesh, shadowCastingLight) {
            this.uniforms.u_ModelMatrix = mesh.worldTransform.array;
            this.uniforms.u_ViewProjectionMatrix = shadowCastingLight.lightViewProjection;
        };
        return ShadowShader;
    }(MeshShader));

    var SkinningShader = /** @class */ (function (_super) {
        __extends(SkinningShader, _super);
        function SkinningShader(renderer) {
            var _this = this;
            // When setting the MAX_JOINT_COUNT, it needs to be subtracted by 1 for
            // some reason. Otherwise it will exceeed maximum vertex uniforms.
            var maxJointCount = SkinningShader.getMaxJointCount(renderer) - 1;
            _this = _super.call(this, renderer, ["USE_SKINNING 1", "MAX_JOINT_COUNT " + maxJointCount]) || this;
            _this._maxSupportedJoints = maxJointCount;
            return _this;
        }
        Object.defineProperty(SkinningShader.prototype, "maxSupportedJoints", {
            get: function () {
                return this._maxSupportedJoints;
            },
            enumerable: false,
            configurable: true
        });
        SkinningShader.getMaxJointCount = function (renderer) {
            var uniformsRequiredForOtherFeatures = 8;
            var availableVertexUniforms = Capabilities.getMaxVertexUniformVectors(renderer) - uniformsRequiredForOtherFeatures;
            var uniformsRequiredPerJoint = 4;
            return Math.floor(availableVertexUniforms / uniformsRequiredPerJoint);
        };
        SkinningShader.prototype.createShaderGeometry = function (geometry) {
            var result = _super.prototype.createShaderGeometry.call(this, geometry);
            if (geometry.joints) {
                result.addAttribute("a_Joint1", new PixiCore.Buffer(geometry.joints.buffer), 4, false, geometry.joints.componentType, geometry.joints.stride);
            }
            if (geometry.weights) {
                result.addAttribute("a_Weight1", new PixiCore.Buffer(geometry.weights.buffer), 4, false, geometry.weights.componentType, geometry.weights.stride);
            }
            return result;
        };
        Object.defineProperty(SkinningShader.prototype, "name", {
            get: function () {
                return "skinned-shadow-shader";
            },
            enumerable: false,
            configurable: true
        });
        SkinningShader.prototype.updateUniforms = function (mesh, shadowCastingLight) {
            _super.prototype.updateUniforms.call(this, mesh, shadowCastingLight);
            if (!mesh.skin) {
                return;
            }
            this.uniforms.u_jointMatrix = mesh.skin.jointMatrices;
        };
        return SkinningShader;
    }(ShadowShader));

    var MAX_SUPPORTED_JOINTS = 256;
    var TextureShader = /** @class */ (function (_super) {
        __extends(TextureShader, _super);
        function TextureShader(renderer) {
            var _this = _super.call(this, renderer, [
                "USE_SKINNING 1", "USE_SKINNING_TEXTURE 1", "MAX_JOINT_COUNT " + MAX_SUPPORTED_JOINTS
            ]) || this;
            _this._jointMatrixTexture =
                new StandardMaterialMatrixTexture(MAX_SUPPORTED_JOINTS);
            return _this;
        }
        TextureShader.isSupported = function (renderer) {
            return StandardMaterialMatrixTexture.isSupported(renderer);
        };
        Object.defineProperty(TextureShader.prototype, "maxSupportedJoints", {
            get: function () {
                return MAX_SUPPORTED_JOINTS;
            },
            enumerable: false,
            configurable: true
        });
        TextureShader.prototype.createShaderGeometry = function (geometry) {
            var result = _super.prototype.createShaderGeometry.call(this, geometry);
            if (geometry.joints) {
                result.addAttribute("a_Joint1", new PixiCore.Buffer(geometry.joints.buffer), 4, false, geometry.joints.componentType, geometry.joints.stride);
            }
            if (geometry.weights) {
                result.addAttribute("a_Weight1", new PixiCore.Buffer(geometry.weights.buffer), 4, false, geometry.weights.componentType, geometry.weights.stride);
            }
            return result;
        };
        Object.defineProperty(TextureShader.prototype, "name", {
            get: function () {
                return "skinned-shadow-shader";
            },
            enumerable: false,
            configurable: true
        });
        TextureShader.prototype.updateUniforms = function (mesh, shadowCastingLight) {
            _super.prototype.updateUniforms.call(this, mesh, shadowCastingLight);
            if (!mesh.skin) {
                return;
            }
            this._jointMatrixTexture.updateBuffer(mesh.skin.jointMatrices);
            this.uniforms.u_jointMatrixSampler = this._jointMatrixTexture;
        };
        return TextureShader;
    }(ShadowShader));

    var ShadowRenderer = /** @class */ (function () {
        function ShadowRenderer(renderer) {
            this.renderer = renderer;
            this._state = Object.assign(new PixiCore.State(), {
                depthTest: true, clockwiseFrontFace: false, culling: true, blendMode: constants.BLEND_MODES.NONE
            });
            this._shadowShader = new ShadowShader(this.renderer);
        }
        ShadowRenderer.prototype.getSkinningShader = function () {
            if (this._textureShader || this._skinningShader) {
                return this._textureShader || this._skinningShader;
            }
            if (TextureShader.isSupported(this.renderer)) {
                this._textureShader = new TextureShader(this.renderer);
            }
            else {
                exports.Debug.warn(Message.meshVertexSkinningFloatingPointTexturesNotSupported);
                this._skinningShader = new SkinningShader(this.renderer);
            }
            return this._textureShader || this._skinningShader;
        };
        ShadowRenderer.prototype.render = function (mesh, shadowCastingLight) {
            var shader = this._shadowShader;
            if (mesh.skin) {
                var skinningShader = this.getSkinningShader();
                if (skinningShader && mesh.skin.joints.length > skinningShader.maxSupportedJoints) {
                    exports.Debug.error(Message.meshVertexSkinningNumberOfJointsNotSupported, {
                        joints: mesh.skin.joints.length,
                        maxJoints: skinningShader.maxSupportedJoints
                    });
                }
                else {
                    shader = skinningShader;
                }
            }
            if (shader) {
                shader.updateUniforms(mesh, shadowCastingLight);
                shader.render(mesh, this.renderer, this._state);
            }
        };
        return ShadowRenderer;
    }());

    /**
     * Pass used for rendering shadows.
     */
    var ShadowRenderPass = /** @class */ (function () {
        /**
         * Creates a new shadow render pass using the specified renderer.
         * @param renderer The renderer to use.
         * @param name The name for the render pass.
         */
        function ShadowRenderPass(renderer, name) {
            if (name === void 0) { name = "shadow"; }
            this.renderer = renderer;
            this.name = name;
            this._lights = [];
            this._filter = new ShadowFilter(renderer);
            this._shadow = new ShadowRenderer(renderer);
        }
        /**
         * Adds a shadow casting light.
         * @param shadowCastingLight The light to add.
         */
        ShadowRenderPass.prototype.addShadowCastingLight = function (shadowCastingLight) {
            if (this._lights.indexOf(shadowCastingLight) < 0) {
                this._lights.push(shadowCastingLight);
            }
        };
        /**
         * Removes a shadow casting light.
         * @param shadowCastingLight The light to remove.
         */
        ShadowRenderPass.prototype.removeShadowCastingLight = function (shadowCastingLight) {
            var index = this._lights.indexOf(shadowCastingLight);
            if (index >= 0) {
                this._lights.splice(index, 1);
            }
        };
        ShadowRenderPass.prototype.clear = function () {
            var e_1, _a;
            try {
                for (var _b = __values(this._lights), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var shadowCastingLight = _c.value;
                    shadowCastingLight.clear();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        ShadowRenderPass.prototype.render = function (meshes) {
            var e_2, _a, e_3, _b;
            if (meshes.length === 0 || this._lights.length === 0) {
                return;
            }
            var current = this.renderer.renderTexture.current;
            try {
                for (var _c = __values(this._lights), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var shadowCastingLight = _d.value;
                    this.renderer.renderTexture.bind(shadowCastingLight.shadowTexture);
                    shadowCastingLight.updateLightViewProjection();
                    try {
                        for (var meshes_1 = (e_3 = void 0, __values(meshes)), meshes_1_1 = meshes_1.next(); !meshes_1_1.done; meshes_1_1 = meshes_1.next()) {
                            var mesh = meshes_1_1.value;
                            this._shadow.render(mesh, shadowCastingLight);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (meshes_1_1 && !meshes_1_1.done && (_b = meshes_1.return)) _b.call(meshes_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    if (shadowCastingLight.softness > 0) {
                        this._filter.applyGaussianBlur(shadowCastingLight);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.renderer.renderTexture.bind(current || undefined);
        };
        return ShadowRenderPass;
    }());

    /**
     * Represents a sprite which can have post processing effects. Can be used for
     * rendering 3D objects as 2D sprites.
     */
    var PostProcessingSprite = /** @class */ (function (_super) {
        __extends(PostProcessingSprite, _super);
        /**
         * Creates a new post processing sprite using the specified options.
         * @param renderer The renderer to use.
         * @param options The options for the render texture. If both width and height
         * has not been set, it will automatically be resized to the renderer size.
         */
        function PostProcessingSprite(renderer, options) {
            var _this = _super.call(this) || this;
            _this.renderer = renderer;
            _this._tickerRender = function () { };
            var _a = options || {}, _b = _a.width, width = _b === void 0 ? 512 : _b, _c = _a.height, height = _c === void 0 ? 512 : _c, objectToRender = _a.objectToRender, _d = _a.resolution, resolution = _d === void 0 ? 1 : _d;
            _this._renderTexture = PixiCore.RenderTexture.create({ width: width, height: height, resolution: resolution });
            /* When rendering to a texture, it's flipped vertically for some reason.
            This will flip it back to it's expected orientation. */
            _this._renderTexture.rotate = 8;
            _this._renderTexture.baseTexture.framebuffer.addDepthTexture();
            _this._texture = _this._renderTexture;
            if (!options || !options.width || !options.height) {
                renderer.on("prerender", function () {
                    _this._renderTexture.resize(renderer.screen.width, renderer.screen.height);
                });
            }
            if (objectToRender) {
                _this._tickerRender = function () {
                    if (!renderer.gl) {
                        // The renderer was probably destroyed.
                        ticker.Ticker.shared.remove(_this._tickerRender);
                        return;
                    }
                    if (_this.worldVisible && _this.worldAlpha > 0 && _this.renderable) {
                        objectToRender && _this.renderObject(objectToRender);
                    }
                };
                ticker.Ticker.shared.add(_this._tickerRender);
            }
            return _this;
        }
        Object.defineProperty(PostProcessingSprite.prototype, "renderTexture", {
            /** The render texture. */
            get: function () {
                return this._renderTexture;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PostProcessingSprite.prototype, "depthTexture", {
            /** The depth texture. */
            get: function () {
                if (this._renderTexture) {
                    return this._renderTexture.baseTexture.framebuffer.depthTexture;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Sets the resolution of the render texture.
         * @param resolution The resolution to set.
         */
        PostProcessingSprite.prototype.setResolution = function (resolution) {
            this._renderTexture.setResolution(resolution);
            this._renderTexture.resize(this._renderTexture.width, this._renderTexture.height, true);
        };
        PostProcessingSprite.prototype.destroy = function (options) {
            ticker.Ticker.shared.remove(this._tickerRender);
            _super.prototype.destroy.call(this, options);
        };
        /**
         * Updates the sprite's texture by rendering the specified object to it.
         * @param object The object to render.
         */
        PostProcessingSprite.prototype.renderObject = function (object) {
            Compatibility.render(this.renderer, object, this.renderTexture);
        };
        return PostProcessingSprite;
    }(sprite.Sprite));

    var SpriteBatchGeometry = /** @class */ (function (_super) {
        __extends(SpriteBatchGeometry, _super);
        function SpriteBatchGeometry() {
            var _this = _super.call(this) || this;
            _this.addAttribute("aMatrix0", _this._buffer, 4, false, constants.TYPES.FLOAT);
            _this.addAttribute("aMatrix1", _this._buffer, 4, false, constants.TYPES.FLOAT);
            _this.addAttribute("aMatrix2", _this._buffer, 4, false, constants.TYPES.FLOAT);
            _this.addAttribute("aMatrix3", _this._buffer, 4, false, constants.TYPES.FLOAT);
            return _this;
        }
        return SpriteBatchGeometry;
    }(PixiCore.BatchGeometry));

    var Shader$5 = {"source":"precision highp float;\n\nattribute vec2 aVertexPosition;\n\nattribute vec4 aMatrix0;\nattribute vec4 aMatrix1;\nattribute vec4 aMatrix2;\nattribute vec4 aMatrix3;\n\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void) {\n  mat4 modelMatrix = mat4(aMatrix0, aMatrix1, aMatrix2, aMatrix3);\n\n  gl_Position = modelMatrix * vec4(aVertexPosition.xy, 0.0, 1.0);\n\n  vTextureCoord = vec2(aTextureCoord.x, aTextureCoord.y);\n  vTextureId = aTextureId;\n  vColor = aColor * tint;\n}"};

    var Shader$4 = {"source":"varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = vColor * vec4(color.rgb, color.a);\n}"};

    var SpriteBatchRenderer = /** @class */ (function (_super) {
        __extends(SpriteBatchRenderer, _super);
        function SpriteBatchRenderer(renderer) {
            var _this = _super.call(this, renderer) || this;
            _this.shaderGenerator = new PixiCore.BatchShaderGenerator(Shader$5.source, Shader$4.source);
            _this.geometryClass = SpriteBatchGeometry;
            // The vertex size when rendering 2D sprites is 6. Here, 16 is being added 
            // to hold the model matrix.
            _this.vertexSize = 6 + 16;
            Object.assign(_this.state, {
                culling: false, clockwiseFrontFace: false, depthTest: true
            });
            return _this;
        }
        SpriteBatchRenderer.prototype.packInterleavedGeometry = function (element, attributeBuffer, indexBuffer, aIndex, iIndex) {
            var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
            var packedVertices = aIndex / this.vertexSize;
            var uvs = element.uvs;
            var indicies = element.indices;
            var vertexData = element.vertexData;
            var textureId = element._texture.baseTexture._batchLocation;
            var alpha = Math.min(element.worldAlpha, 1.0);
            var argb = (alpha < 1.0
                && element._texture.baseTexture.alphaMode)
                ? utils.premultiplyTint(element._tintRGB, alpha)
                : element._tintRGB + (alpha * 255 << 24);
            for (var i = 0; i < vertexData.length; i += 2) {
                float32View[aIndex++] = vertexData[i];
                float32View[aIndex++] = vertexData[i + 1];
                float32View[aIndex++] = uvs[i];
                float32View[aIndex++] = uvs[i + 1];
                uint32View[aIndex++] = argb;
                float32View[aIndex++] = textureId;
                for (var j = 0; j < 16; j++) {
                    // @ts-ignore
                    float32View[aIndex++] = element.modelViewProjection[j];
                }
            }
            for (var i = 0; i < indicies.length; i++) {
                indexBuffer[iIndex++] = packedVertices + indicies[i];
            }
        };
        return SpriteBatchRenderer;
    }(PixiCore.AbstractBatchRenderer));
    Compatibility.installRendererPlugin("sprite3d", SpriteBatchRenderer);

    /**
     * The standard pipeline renders meshes using the set render passes. It's
     * created and used by default.
     */
    var StandardPipeline = /** @class */ (function (_super) {
        __extends(StandardPipeline, _super);
        /**
         * Creates a new standard pipeline using the specified renderer.
         * @param renderer The renderer to use.
         */
        function StandardPipeline(renderer) {
            var _this = _super.call(this, renderer) || this;
            _this.renderer = renderer;
            _this._meshes = [];
            _this._sprites = [];
            /** The pass used for rendering materials. */
            _this.materialPass = new MaterialRenderPass(_this.renderer, "material");
            /** The pass used for rendering shadows. */
            _this.shadowPass = new ShadowRenderPass(_this.renderer, "shadow");
            /** The array of render passes. Each mesh will be rendered with these passes (if it has been enabled on that mesh). */
            _this.renderPasses = [
                _this.shadowPass, _this.materialPass,
            ];
            renderer.on("prerender", function () {
                var e_1, _a;
                try {
                    for (var _b = __values(_this.renderPasses), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var pass = _c.value;
                        if (pass.clear) {
                            pass.clear();
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            });
            _this._spriteRenderer = new SpriteBatchRenderer(renderer);
            return _this;
        }
        /**
         * Creates a new post processing sprite and sets the material pass to render
         * to it's texture.
         * @param options The options when creating the sprite.
         */
        StandardPipeline.prototype.createPostProcessingSprite = function (options) {
            var sprite = new PostProcessingSprite(this.renderer, options);
            this.materialPass.renderTexture = sprite.renderTexture;
            return sprite;
        };
        /**
         * Adds an object to be rendered.
         * @param object The object to render.
         */
        StandardPipeline.prototype.render = function (object) {
            if (object.isSprite) {
                this._sprites.push(object);
            }
            else {
                this._meshes.push(object);
            }
        };
        /**
         * Renders the added meshes using the specified render passes.
         */
        StandardPipeline.prototype.flush = function () {
            var e_2, _a, e_3, _b;
            this.sort();
            var _loop_1 = function (pass) {
                pass.render(this_1._meshes.filter(function (mesh) { return mesh.isRenderPassEnabled(pass.name); }));
            };
            var this_1 = this;
            try {
                for (var _c = __values(this.renderPasses), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var pass = _d.value;
                    _loop_1(pass);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this._meshes = [];
            if (this._sprites.length > 0) {
                this._spriteRenderer.start();
                try {
                    for (var _e = __values(this._sprites), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var sprite = _f.value;
                        // @ts-ignore
                        this._spriteRenderer.render(sprite);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                this._spriteRenderer.stop();
                this._sprites = [];
            }
        };
        /**
         * Sorts the meshes by rendering order.
         */
        StandardPipeline.prototype.sort = function () {
            this._meshes.sort(function (a, b) {
                if (!a.material || !b.material) {
                    return 0;
                }
                if (a.material.renderSortType !== b.material.renderSortType) {
                    return a.material.renderSortType === exports.MaterialRenderSortType.transparent ? 1 : -1;
                }
                if (a.renderSortOrder === b.renderSortOrder) {
                    return 0;
                }
                return a.renderSortOrder < b.renderSortOrder ? -1 : 1;
            });
            this._sprites.sort(function (a, b) {
                if (a.zIndex !== b.zIndex) {
                    return a.zIndex - b.zIndex;
                }
                return b.distanceFromCamera - a.distanceFromCamera;
            });
        };
        /**
         * Enables shadows for the specified object. Adds the shadow render pass to
         * the specified object and enables the standard material to use the casting
         * light.
         * @param object The mesh or model to enable shadows for.
         * @param light The shadow casting light to associate with the
         * object when using the standard material.
         */
        StandardPipeline.prototype.enableShadows = function (object, light) {
            var e_4, _a;
            var meshes = object instanceof Model ? object.meshes : [object];
            try {
                for (var meshes_1 = __values(meshes), meshes_1_1 = meshes_1.next(); !meshes_1_1.done; meshes_1_1 = meshes_1.next()) {
                    var mesh = meshes_1_1.value;
                    if (light && mesh.material instanceof StandardMaterial) {
                        mesh.material.shadowCastingLight = light;
                    }
                    mesh.enableRenderPass(this.shadowPass.name);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (meshes_1_1 && !meshes_1_1.done && (_a = meshes_1.return)) _a.call(meshes_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            if (light) {
                this.shadowPass.addShadowCastingLight(light);
            }
        };
        /**
         * Disables shadows for the specified object.
         * @param object The mesh or model to disable shadows for.
         */
        StandardPipeline.prototype.disableShadows = function (object) {
            var e_5, _a;
            var meshes = object instanceof Model ? object.meshes : [object];
            try {
                for (var meshes_2 = __values(meshes), meshes_2_1 = meshes_2.next(); !meshes_2_1.done; meshes_2_1 = meshes_2.next()) {
                    var mesh = meshes_2_1.value;
                    if (mesh.material instanceof StandardMaterial) {
                        mesh.material.shadowCastingLight = undefined;
                    }
                    mesh.disableRenderPass(this.shadowPass.name);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (meshes_2_1 && !meshes_2_1.done && (_a = meshes_2.return)) _a.call(meshes_2);
                }
                finally { if (e_5) throw e_5.error; }
            }
        };
        return StandardPipeline;
    }(PixiCore.ObjectRenderer));
    Compatibility.installRendererPlugin("pipeline", StandardPipeline);

    var ArrayResource = CompatibilityAccess.get(PixiCore__namespace, "ArrayResource") ||
        //@ts-ignore 
        CompatibilityAccess.get(PixiCore__namespace, "resources").ArrayResource;

    var BaseImageResource = CompatibilityAccess.get(PixiCore__namespace, "BaseImageResource") ||
        //@ts-ignore 
        CompatibilityAccess.get(PixiCore__namespace, "resources").BaseImageResource;

    var MipmapResource = /** @class */ (function (_super) {
        __extends(MipmapResource, _super);
        function MipmapResource(source, target) {
            var _this = _super.call(this, source) || this;
            _this.target = target;
            return _this;
        }
        MipmapResource.prototype.upload = function (renderer, baseTexture) {
            renderer.gl.pixelStorei(renderer.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);
            for (var i = 0; i < this.items.length; i++) {
                var resource = this.items[i].resource;
                if (resource instanceof BufferResource) {
                    renderer.gl.texImage2D(this.target, i, baseTexture.format, resource.width, resource.height, 0, baseTexture.format, baseTexture.type, resource.data);
                }
                if (resource instanceof BaseImageResource) {
                    renderer.gl.texImage2D(this.target, i, baseTexture.format, baseTexture.format, baseTexture.type, resource.source);
                }
            }
            return true;
        };
        return MipmapResource;
    }(ArrayResource));

    var CubeResource = CompatibilityAccess.get(PixiCore__namespace, "CubeResource") ||
        //@ts-ignore 
        CompatibilityAccess.get(PixiCore__namespace, "resources").CubeResource;

    var CubemapResource = /** @class */ (function (_super) {
        __extends(CubemapResource, _super);
        function CubemapResource(source, levels) {
            if (levels === void 0) { levels = 1; }
            var _this = _super.call(this, source) || this;
            _this.levels = levels;
            return _this;
        }
        CubemapResource.prototype.style = function (renderer) {
            var gl = renderer.gl;
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            if (this.levels > 1) {
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            }
            else {
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }
            return true;
        };
        return CubemapResource;
    }(CubeResource));

    /**
     * Cubemap which supports multiple user specified mipmaps.
     */
    var Cubemap = /** @class */ (function (_super) {
        __extends(Cubemap, _super);
        function Cubemap() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(Cubemap, "faces", {
            /** Returns an array of faces. */
            get: function () {
                return ["posx", "negx", "posy", "negy", "posz", "negz"];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Cubemap.prototype, "levels", {
            /** Returns the number of mipmap levels. */
            get: function () {
                return this.resource.levels;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Creates a new cubemap from the specified faces.
         * @param faces The faces to create the cubemap from.
         */
        Cubemap.fromFaces = function (faces) {
            var array = Array.isArray(faces) ? faces : [faces];
            var resources = Cubemap.faces.map(function (face, index) {
                return new MipmapResource(array.map(function (f) { return f[face]; }), constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index);
            });
            return new Cubemap(new CubemapResource(resources, array.length));
        };
        /**
         * Creates a new cubemap from the specified colors.
         * @param posx The color for positive x.
         * @param negx The color for negative x.
         * @param posy The color for positive y.
         * @param negy The color for negative y.
         * @param posz The color for positive z.
         * @param negz The color for negative z.
         */
        Cubemap.fromColors = function (posx, negx, posy, negy, posz, negz) {
            if (negx === void 0) { negx = posx; }
            if (posy === void 0) { posy = posx; }
            if (negy === void 0) { negy = posx; }
            if (posz === void 0) { posz = posx; }
            if (negz === void 0) { negz = posx; }
            var resources = [];
            var colors = [posx, negx, posy, negy, posz, negz];
            for (var i = 0; i < colors.length; i++) {
                var resource = new BufferResource(new Uint8Array(colors[i].rgba.map(function (c) { return c * 255; })), { width: 1, height: 1 });
                var texture = new PixiCore.Texture(new PixiCore.BaseTexture(resource, {
                    type: constants.TYPES.UNSIGNED_BYTE,
                    format: constants.FORMATS.RGB,
                    alphaMode: constants.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
                }));
                resources.push(new MipmapResource([texture], constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i));
            }
            return new Cubemap(new CubemapResource(resources, 1));
        };
        return Cubemap;
    }(PixiCore.BaseTexture));

    var CubemapLoader = {
        use: function (resource, next) {
            if (resource.extension !== "cubemap") {
                return next();
            }
            var loader = this;
            var mipmaps = resource.data.map(function (mipmap) {
                return Cubemap.faces.map(function (face) {
                    return resource.url.substring(0, resource.url.lastIndexOf("/") + 1) + mipmap.replace("{{face}}", face);
                });
            });
            // The list of urls (faces and mipmaps) which needs to be loaded before the 
            // cubemap should be created.
            var urls = mipmaps.reduce(function (acc, val) { return acc.concat(val); }, []);
            loader.add(urls.filter(function (url) { return !loader.resources[url]; }).map(function (url) {
                return { parentResource: resource, url: url };
            }));
            var completed = 0;
            // Listen for resources being loaded.
            var binding = loader.onLoad.add(function (loader, res) {
                if (urls.includes(res.url)) {
                    if (++completed === urls.length) {
                        // All resources used by cubemap has been loaded.
                        var textures = mipmaps.map(function (face) {
                            return {
                                posx: PixiCore.Texture.from(face[0]),
                                negx: PixiCore.Texture.from(face[1]),
                                posy: PixiCore.Texture.from(face[2]),
                                negy: PixiCore.Texture.from(face[3]),
                                posz: PixiCore.Texture.from(face[4]),
                                negz: PixiCore.Texture.from(face[5]),
                            };
                        });
                        resource.cubemap = Cubemap.fromFaces(textures);
                        binding.detach();
                        next();
                    }
                }
            });
        },
        add: function () {
            loaders.LoaderResource.setExtensionXhrType("cubemap", loaders.LoaderResource.XHR_RESPONSE_TYPE.JSON);
        }
    };
    Compatibility.installLoaderPlugin("cubemap", CubemapLoader);

    var EXTENSIONS = ["glsl", "vert", "frag"];
    var ShaderSourceLoader = {
        use: function (resource, next) {
            next();
        },
        add: function () {
            var e_1, _a;
            try {
                for (var EXTENSIONS_1 = __values(EXTENSIONS), EXTENSIONS_1_1 = EXTENSIONS_1.next(); !EXTENSIONS_1_1.done; EXTENSIONS_1_1 = EXTENSIONS_1.next()) {
                    var ext = EXTENSIONS_1_1.value;
                    loaders.LoaderResource.setExtensionXhrType(ext, loaders.LoaderResource.XHR_RESPONSE_TYPE.TEXT);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (EXTENSIONS_1_1 && !EXTENSIONS_1_1.done && (_a = EXTENSIONS_1.return)) _a.call(EXTENSIONS_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    };
    Compatibility.installLoaderPlugin("shader", ShaderSourceLoader);

    var Shader$3 = {"source":"attribute vec3 a_Position;\n\nvarying vec3 v_Position;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\nvoid main() {\n  v_Position = a_Position.xyz;\n\n  // Converting the view to 3x3 matrix and then back to 4x4 matrix \n  // removes the translation. We do this because we want the skybox to \n  // be centered around the camera.\n  gl_Position = u_Projection * mat4(mat3(u_View)) * u_ModelMatrix * vec4(a_Position, 1.0);\n}"};

    var Shader$2 = {"source":"varying vec3 v_Position;\n\nuniform samplerCube u_EnvironmentSampler;\n\nvoid main() {\n  gl_FragColor = vec4(textureCube(u_EnvironmentSampler, v_Position).rgb, 1.0);\n}"};

    var SkyboxMaterial = /** @class */ (function (_super) {
        __extends(SkyboxMaterial, _super);
        function SkyboxMaterial(cubemap) {
            var _this = _super.call(this) || this;
            _this._cubemap = cubemap;
            _this.state = Object.assign(new PixiCore.State(), {
                culling: true, clockwiseFrontFace: true, depthTest: true, depthMask: false
            });
            return _this;
        }
        Object.defineProperty(SkyboxMaterial.prototype, "cubemap", {
            get: function () {
                return this._cubemap;
            },
            set: function (value) {
                if (value !== this._cubemap) {
                    if (!this._cubemap.valid) {
                        // Remove the shader so it can be rebuilt with the current features. 
                        // It may happen that we set a texture which is not yet valid, in that 
                        // case we don't want to render the skybox until it has become valid.
                        this._shader = undefined;
                    }
                    this._cubemap = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        SkyboxMaterial.prototype.updateUniforms = function (mesh, shader) {
            var camera = this.camera || Camera.main;
            shader.uniforms.u_ModelMatrix = mesh.worldTransform.array;
            shader.uniforms.u_View = camera.view;
            shader.uniforms.u_Projection = camera.projection;
            shader.uniforms.u_EnvironmentSampler = this.cubemap;
        };
        SkyboxMaterial.prototype.render = function (mesh, renderer) {
            // Disable writing to the depth buffer. This is because we want all other 
            // objects to be in-front of the skybox.
            renderer.gl.depthMask(false);
            _super.prototype.render.call(this, mesh, renderer);
            renderer.gl.depthMask(true);
        };
        SkyboxMaterial.prototype.createShader = function () {
            if (this.cubemap.valid) {
                return new MeshShader(PixiCore.Program.from(Shader$3.source, Shader$2.source));
            }
        };
        return SkyboxMaterial;
    }(Material));

    /**
     * A skybox is a method of creating backgrounds in a 3D scene. It consists of
     * a cubemap texture which has six sides. Note that the skybox should be rendered
     * before all other objects in the scene.
     */
    var Skybox = /** @class */ (function (_super) {
        __extends(Skybox, _super);
        /**
         * Creates a new skybox using the specified cubemap.
         * @param cubemap Cubemap to use for rendering.
         */
        function Skybox(cubemap) {
            var _this = _super.call(this) || this;
            _this._mesh = _this.addChild(Mesh3D.createCube(new SkyboxMaterial(cubemap)));
            _this._mesh.renderSortOrder = -1;
            return _this;
        }
        Object.defineProperty(Skybox.prototype, "camera", {
            /**
             * Camera used when rendering. If this value is not set, the main camera will
             * be used by default.
             */
            get: function () {
                return this._mesh.material.camera;
            },
            set: function (value) {
                this._mesh.material.camera = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Skybox.prototype, "cubemap", {
            /**
             * The cubemap texture used when rendering.
             */
            get: function () {
                return this._mesh.material.cubemap;
            },
            set: function (value) {
                this._mesh.material.cubemap = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Creates a new skybox from the specified source.
         * @param source The source to create the skybox from.
         */
        Skybox.from = function (source) {
            return new Skybox(Cubemap.fromFaces(source));
        };
        return Skybox;
    }(Container3D));

    var Shader$1 = {"source":"#version 100\n\nattribute vec3 a_Position;\n\nuniform mat4 u_ModelViewProjection;\n\nvoid main() {\n  gl_Position = u_ModelViewProjection * vec4(a_Position, 1.0);\n}"};

    var Shader = {"source":"#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform vec3 u_Id;\n\nvoid main() {\n  gl_FragColor = vec4(u_Id / 255.0, 1.0);\n}"};

    var PickingMap = /** @class */ (function () {
        function PickingMap(_renderer, size) {
            this._renderer = _renderer;
            this._update = 0;
            this._matrix = new Float32Array(16);
            this._pixels = new Uint8Array(size * size * 4);
            this._output = PixiCore.RenderTexture.create({ width: size, height: size, resolution: 1 });
            this._shader = new MeshShader(PixiCore.Program.from(Shader$1.source, Shader.source));
            this._output.framebuffer.addDepthTexture();
        }
        PickingMap.prototype.destroy = function () {
            this._output.destroy(true);
            this._shader.destroy();
        };
        PickingMap.prototype.resizeToAspect = function () {
            var aspect = this._renderer.width / this._renderer.height;
            var aspectWidth = Math.floor(this._output.height * aspect);
            if (this._output.width !== aspectWidth) {
                this._pixels = new Uint8Array(aspectWidth * this._output.height * 4);
                this._output.resize(aspectWidth, this._output.height);
            }
        };
        PickingMap.prototype.containsId = function (x, y, id) {
            var _a = this._renderer.screen, width = _a.width, height = _a.height;
            x = Math.floor(x / width * this._output.width);
            y = Math.floor((height - y) / height * this._output.height);
            for (var i = 0; i < 3; i++) {
                if (id[i] !== this._pixels[(y * this._output.width + x) * 4 + i]) {
                    return false;
                }
            }
            return true;
        };
        PickingMap.prototype.update = function (hitAreas) {
            var e_1, _a;
            this._renderer.renderTexture.bind(this._output);
            if (this._update++ % 2 === 0) {
                // For performance reasons, the update method alternates between rendering 
                // the meshes and reading the pixels from the rendered texture.
                this._renderer.renderTexture.clear();
                try {
                    for (var hitAreas_1 = __values(hitAreas), hitAreas_1_1 = hitAreas_1.next(); !hitAreas_1_1.done; hitAreas_1_1 = hitAreas_1.next()) {
                        var hitArea = hitAreas_1_1.value;
                        this.renderHitArea(hitArea);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (hitAreas_1_1 && !hitAreas_1_1.done && (_a = hitAreas_1.return)) _a.call(hitAreas_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                var gl = this._renderer.gl;
                gl.readPixels(0, 0, this._output.width, this._output.height, gl.RGBA, gl.UNSIGNED_BYTE, this._pixels);
            }
            this._renderer.renderTexture.bind(undefined);
        };
        PickingMap.prototype.renderHitArea = function (hitArea) {
            var e_2, _a;
            var uniforms = this._shader.uniforms;
            var meshes = hitArea.object instanceof Mesh3D ? [hitArea.object] : hitArea.object.meshes;
            var camera = hitArea.camera || Camera.main;
            try {
                for (var meshes_1 = __values(meshes), meshes_1_1 = meshes_1.next(); !meshes_1_1.done; meshes_1_1 = meshes_1.next()) {
                    var mesh = meshes_1_1.value;
                    uniforms.u_Id = hitArea.id;
                    uniforms.u_ModelViewProjection = Mat4.multiply(camera.viewProjection, mesh.transform.worldTransform.array, this._matrix);
                    this._shader.render(mesh, this._renderer);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (meshes_1_1 && !meshes_1_1.done && (_a = meshes_1.return)) _a.call(meshes_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        return PickingMap;
    }());

    /**
     * Manages the picking hit areas by keeping track on which hit areas needs to
     * be checked for interaction. Renders the hit area meshes to a texture which
     * is then used to map a mesh to a x/y coordinate. The picking manager is
     * registered as a renderer plugin.
     */
    var PickingInteraction = /** @class */ (function () {
        /**
         * Creates a new picking manager using the specified renderer.
         * @param renderer The renderer to use.
         */
        function PickingInteraction(renderer) {
            this.renderer = renderer;
            this._hitAreas = [];
            this._map = new PickingMap(this.renderer, 128);
            ticker.Ticker.shared.add(this._update, this, ticker.UPDATE_PRIORITY.LOW);
            if (!PickingInteraction.main) {
                PickingInteraction.main = this;
            }
        }
        PickingInteraction.prototype._update = function () {
            if (!this.renderer.plugins) {
                return;
            }
            // Because of how PixiJS interaction works and the design of the picking,
            // the "hitTest" function needs to be called. Otherwise, in some 
            // circumstances; the picking is affected by in which order the interaction 
            // object was added to the heirarchy.
            this.renderer.plugins.interaction.hitTest(new math.Point(0, 0));
            if (this._hitAreas.length > 0) {
                this._map.resizeToAspect();
                this._map.update(this._hitAreas);
                this._hitAreas = [];
            }
        };
        PickingInteraction.prototype.destroy = function () {
            if (this === PickingInteraction.main) {
                // @ts-ignore It's ok, main picking interaction was destroyed.
                PickingInteraction.main = undefined;
            }
            ticker.Ticker.shared.remove(this._update, this);
        };
        /**
         * Hit tests a area using the specified x/y coordinates.
         * @param x The x coordinate.
         * @param y The y coordinate.
         * @param hitArea The hit area to test.
         */
        PickingInteraction.prototype.containsHitArea = function (x, y, hitArea) {
            if (this._hitAreas.indexOf(hitArea) < 0) {
                this._hitAreas.push(hitArea);
            }
            return this._map.containsId(x, y, hitArea.id);
        };
        return PickingInteraction;
    }());
    Compatibility.installRendererPlugin("picking", PickingInteraction);

    var PickingId;
    (function (PickingId) {
        var id = 0;
        function next() {
            id++;
            return new Uint8Array([
                (id >> 16) & 255, (id >> 8) & 255, id & 255
            ]);
        }
        PickingId.next = next;
    })(PickingId || (PickingId = {}));

    /**
     * Hit area which uses the shape of an object to determine interaction.
     */
    var PickingHitArea = /** @class */ (function () {
        /**
         * Creates a new hitarea using the specified object.
         * @param renderer Not used, accepts any value. Only here for compatibility reasons.
         * @param object The model or mesh to use as the shape for hit testing.
         * @param camera The camera to use when rendering the object picking shape.
         * If not set, the main camera will be used as default.
         */
        function PickingHitArea(renderer, object, camera) {
            this.object = object;
            this.camera = camera;
            /** The id which maps to the object. */
            this.id = PickingId.next();
        }
        PickingHitArea.prototype.contains = function (x, y) {
            return PickingInteraction.main.containsHitArea(x, y, this);
        };
        /**
         * Creates a new hitarea using the specified object.
         * @param object The model or mesh to use as the shape for hit testing.
         */
        PickingHitArea.fromObject = function (object) {
            return new PickingHitArea(undefined, object);
        };
        return PickingHitArea;
    }());

    exports.ShadowQuality = void 0;
    (function (ShadowQuality) {
        /**
         * Low quality (8-bit) shadows.
         */
        ShadowQuality["low"] = "low";
        /**
         * Medium quality (16-bit) shadows.
         */
        ShadowQuality["medium"] = "medium";
        /**
         * High quality (32-bit) shadows.
         */
        ShadowQuality["high"] = "high";
    })(exports.ShadowQuality || (exports.ShadowQuality = {}));

    var ShadowTexture;
    (function (ShadowTexture) {
        function create(renderer, size, quality) {
            var type = getSupportedType(renderer, quality);
            return PixiCore.RenderTexture.create({
                width: size, height: size, type: type, scaleMode: getSupportedScaleMode(renderer)
            });
        }
        ShadowTexture.create = create;
        function getSupportedScaleMode(renderer) {
            if (Capabilities.supportsFloatLinear(renderer)) {
                return constants.SCALE_MODES.LINEAR;
            }
            return constants.SCALE_MODES.NEAREST;
        }
        function getSupportedType(renderer, quality) {
            if (quality === exports.ShadowQuality.high) {
                if (Capabilities.isFloatFramebufferSupported(renderer)) {
                    return constants.TYPES.FLOAT;
                }
                if (Capabilities.isHalfFloatFramebufferSupported(renderer)) {
                    return constants.TYPES.HALF_FLOAT;
                }
            }
            if (quality === exports.ShadowQuality.medium && Capabilities.isHalfFloatFramebufferSupported(renderer)) {
                return constants.TYPES.HALF_FLOAT;
            }
            return constants.TYPES.UNSIGNED_BYTE;
        }
    })(ShadowTexture || (ShadowTexture = {}));

    var ShadowMath;
    (function (ShadowMath) {
        var _lightProjection = new Float32Array(16);
        var _lightView = new Float32Array(16);
        var _conjugateRotation = new Float32Array(4);
        var _lightSpacePosition = new Float32Array(3);
        var _lightSpaceForward = new Float32Array(3);
        var _cameraTarget = new Float32Array(3);
        var _cameraForward = new Float32Array(3);
        function calculateDirectionalLightViewProjection(shadowCastingLight) {
            if (shadowCastingLight.light.type !== exports.LightType.directional) {
                return;
            }
            var halfShadowArea = shadowCastingLight.shadowArea / 2;
            var worldTexelSize = (halfShadowArea * 2) / shadowCastingLight.shadowArea;
            var lightProjection = Mat4.ortho(-halfShadowArea, halfShadowArea, -halfShadowArea, halfShadowArea, -halfShadowArea, halfShadowArea, _lightProjection);
            var light = shadowCastingLight.light;
            var camera = shadowCastingLight.camera || Camera.main;
            if (camera && shadowCastingLight.followCamera) {
                Vec3.scale(camera.worldTransform.forward, halfShadowArea, _cameraForward);
                Vec3.add(camera.worldTransform.position, _cameraForward, _cameraTarget);
                Vec3.transformQuat(_cameraTarget, Quat.conjugate(shadowCastingLight.light.worldTransform.rotation, _conjugateRotation), _lightSpacePosition);
                _lightSpacePosition[0] = worldTexelSize *
                    Math.floor(_lightSpacePosition[0] / worldTexelSize);
                _lightSpacePosition[1] = worldTexelSize *
                    Math.floor(_lightSpacePosition[1] / worldTexelSize);
                Vec3.transformQuat(_lightSpacePosition, light.worldTransform.rotation, _lightSpacePosition);
                Vec3.add(_lightSpacePosition, light.worldTransform.forward, _lightSpaceForward);
                Mat4.lookAt(_lightSpacePosition, _lightSpaceForward, light.worldTransform.up, _lightView);
                Mat4.multiply(lightProjection, _lightView, shadowCastingLight.lightViewProjection);
            }
            else {
                Vec3.add(light.worldTransform.position, shadowCastingLight.light.worldTransform.forward, _cameraTarget);
                Mat4.lookAt(light.worldTransform.position, _cameraTarget, light.worldTransform.up, _lightView);
                Mat4.multiply(lightProjection, _lightView, shadowCastingLight.lightViewProjection);
            }
        }
        ShadowMath.calculateDirectionalLightViewProjection = calculateDirectionalLightViewProjection;
        function calculateSpotLightViewProjection(shadowCastingLight) {
            if (shadowCastingLight.light.type !== exports.LightType.spot) {
                return;
            }
            var light = shadowCastingLight.light;
            Mat4.perspective(light.outerConeAngle * math.DEG_TO_RAD * 2, 1, 2, light.range, _lightProjection);
            Vec3.add(light.worldTransform.position, light.worldTransform.forward, _cameraTarget);
            Mat4.lookAt(light.worldTransform.position, _cameraTarget, light.worldTransform.up, _lightView);
            Mat4.multiply(_lightProjection, _lightView, shadowCastingLight.lightViewProjection);
        }
        ShadowMath.calculateSpotLightViewProjection = calculateSpotLightViewProjection;
    })(ShadowMath || (ShadowMath = {}));

    /**
     * Contains the required components used for rendering a shadow casted by a light.
     */
    var ShadowCastingLight = /** @class */ (function () {
        /**
         * Creates a new shadow casting light used for rendering a shadow texture.
         * @param renderer The renderer to use.
         * @param light The light which is casting the shadow.
         * @param options The options to use when creating the shadow texture.
         */
        function ShadowCastingLight(renderer, light, options) {
            this.renderer = renderer;
            this.light = light;
            this._lightViewProjection = new Float32Array(16);
            /** The softness of the edges for the shadow. */
            this.softness = 0;
            /**
             * The area in units of the shadow when using directional lights. Reducing
             * the area will improve the quality of the shadow.
             */
            this.shadowArea = 50;
            /**
             * Value indicating if the shadow should follow the specified camera. If the
             * camera is not set, the main camera will be used as default. Only available
             * when using directional lights.
             */
            this.followCamera = true;
            if (light.type === exports.LightType.point) {
                throw new Error("PIXI3D: Only directional and spot lights are supported as shadow casters.");
            }
            var _a = options || {}, _b = _a.shadowTextureSize, shadowTextureSize = _b === void 0 ? 1024 : _b, _c = _a.quality, quality = _c === void 0 ? exports.ShadowQuality.medium : _c;
            this._shadowTexture = ShadowTexture.create(renderer, shadowTextureSize, quality);
            this._shadowTexture.baseTexture.framebuffer.addDepthTexture();
            this._filterTexture = ShadowTexture.create(renderer, shadowTextureSize, quality);
        }
        Object.defineProperty(ShadowCastingLight.prototype, "lightViewProjection", {
            /** The light view projection matrix. */
            get: function () {
                return this._lightViewProjection;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ShadowCastingLight.prototype, "shadowTexture", {
            /**
             * The rendered shadow texture.
             */
            get: function () {
                return this._shadowTexture;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ShadowCastingLight.prototype, "filterTexture", {
            /**
             * The rendered filter texture.
             */
            get: function () {
                return this._filterTexture;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Destroys the shadow casting light and it's used resources.
         */
        ShadowCastingLight.prototype.destroy = function () {
            this._shadowTexture.destroy(true);
            this._filterTexture.destroy(true);
        };
        /**
         * Clears the rendered shadow texture.
         */
        ShadowCastingLight.prototype.clear = function () {
            this.renderer.renderTexture.bind(this._shadowTexture);
            this.renderer.renderTexture.clear([0, 0, 0, 0], this.renderer.gl.COLOR_BUFFER_BIT | this.renderer.gl.DEPTH_BUFFER_BIT);
            this.renderer.renderTexture.bind(undefined);
        };
        /**
         * Updates the light view projection matrix.
         */
        ShadowCastingLight.prototype.updateLightViewProjection = function () {
            if (this.light.type === exports.LightType.directional) {
                ShadowMath.calculateDirectionalLightViewProjection(this);
            }
            else if (this.light.type === exports.LightType.spot) {
                ShadowMath.calculateSpotLightViewProjection(this);
            }
        };
        /**
         * Returns a value indicating if medium quality (16-bit precision) shadows is
         * supported by current platform.
         * @param renderer The renderer to use.
         */
        ShadowCastingLight.isMediumQualitySupported = function (renderer) {
            return Capabilities.isHalfFloatFramebufferSupported(renderer);
        };
        /**
         * Returns a value indicating if high quality (32-bit precision) shadows is
         * supported by current platform.
         * @param renderer The renderer to use.
         */
        ShadowCastingLight.isHighQualitySupported = function (renderer) {
            return Capabilities.isFloatFramebufferSupported(renderer);
        };
        return ShadowCastingLight;
    }());

    function approximately(a, b) {
        return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
    }
    var EPSILON = 0.000001;
    var Plane = /** @class */ (function () {
        function Plane(normal, distance) {
            this.distance = distance;
            this._normal = new Float32Array(3);
            Vec3.normalize(normal, this._normal);
        }
        Object.defineProperty(Plane.prototype, "normal", {
            get: function () {
                return this._normal;
            },
            enumerable: false,
            configurable: true
        });
        Plane.prototype.rayCast = function (ray) {
            var vdot = Vec3.dot(ray.direction, this.normal);
            if (approximately(vdot, 0)) {
                return 0;
            }
            var ndot = -Vec3.dot(ray.origin, this.normal) - this.distance;
            return ndot / vdot;
        };
        return Plane;
    }());

    /**
     * Represents different billboard types.
     */
    exports.SpriteBillboardType = void 0;
    (function (SpriteBillboardType) {
        /**
         * Sprite will be rotated towards the viewer on both the x-plane and y-plane.
         */
        SpriteBillboardType["spherical"] = "spherical";
        /**
         * Sprite will be rotated towards the viewer on the y-plane.
         */
        SpriteBillboardType["cylindrical"] = "cylindrical";
    })(exports.SpriteBillboardType || (exports.SpriteBillboardType = {}));

    var ProjectionSprite = /** @class */ (function (_super) {
        __extends(ProjectionSprite, _super);
        function ProjectionSprite(texture) {
            var _this = _super.call(this, texture) || this;
            _this._pixelsPerUnit = 100;
            _this.distanceFromCamera = 0;
            _this.modelViewProjection = new Float32Array(16);
            _this.pluginName = "pipeline";
            return _this;
        }
        Object.defineProperty(ProjectionSprite.prototype, "pixelsPerUnit", {
            get: function () {
                return this._pixelsPerUnit;
            },
            set: function (value) {
                if (value !== this._pixelsPerUnit) {
                    // @ts-ignore
                    this._transformID = -1;
                    this._pixelsPerUnit = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        ProjectionSprite.prototype.calculateVertices = function () {
            var texture = this._texture;
            // @ts-ignore
            if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
                return;
            }
            if (this._textureID !== texture._updateID) {
                this.uvs = this._texture._uvs.uvsFloat32;
            }
            // @ts-ignore
            this._transformID = this.transform._worldID;
            this._textureID = texture._updateID;
            var wt = this.transform.worldTransform;
            var orig = texture.orig;
            var anchor = this._anchor;
            var w1 = texture.trim ? texture.trim.x - (anchor._x * orig.width) : -anchor._x * orig.width;
            var w0 = texture.trim ? w1 + texture.trim.width : w1 + orig.width;
            var h1 = texture.trim ? texture.trim.y - (anchor._y * orig.height) : -anchor._y * orig.height;
            var h0 = texture.trim ? h1 + texture.trim.height : h1 + orig.height;
            this.vertexData[0] = ((wt.a * w1) + (wt.c * -h1)) / this._pixelsPerUnit;
            this.vertexData[1] = ((wt.d * -h1) + (wt.b * w1)) / this._pixelsPerUnit;
            this.vertexData[2] = ((wt.a * w0) + (wt.c * -h1)) / this._pixelsPerUnit;
            this.vertexData[3] = ((wt.d * -h1) + (wt.b * w0)) / this._pixelsPerUnit;
            this.vertexData[4] = ((wt.a * w0) + (wt.c * -h0)) / this._pixelsPerUnit;
            this.vertexData[5] = ((wt.d * -h0) + (wt.b * w0)) / this._pixelsPerUnit;
            this.vertexData[6] = ((wt.a * w1) + (wt.c * -h0)) / this._pixelsPerUnit;
            this.vertexData[7] = ((wt.d * -h0) + (wt.b * w1)) / this._pixelsPerUnit;
            if (this.roundPixels) {
                var resolution = settings.settings.RESOLUTION;
                for (var i = 0; i < this.vertexData.length; ++i) {
                    this.vertexData[i] = Math.round((this.vertexData[i] * resolution | 0) / resolution);
                }
            }
        };
        return ProjectionSprite;
    }(sprite.Sprite));

    var vec3 = new Float32Array(3);
    /**
     * Represents a sprite in 3D space.
     */
    var Sprite3D = /** @class */ (function (_super) {
        __extends(Sprite3D, _super);
        /**
         * Creates a new sprite using the specified texture.
         * @param texture The texture to use.
         */
        function Sprite3D(texture) {
            var _this = _super.call(this) || this;
            _this._modelView = new Float32Array(16);
            _this._sprite = new ProjectionSprite(texture);
            _this._sprite.anchor.set(0.5);
            return _this;
        }
        Object.defineProperty(Sprite3D.prototype, "billboardType", {
            /**
             * The billboard type to use when rendering the sprite. Used for making the
             * sprite always face the viewer.
             */
            get: function () {
                return this._billboardType;
            },
            set: function (value) {
                if (value !== this._billboardType) {
                    this._billboardType = value;
                    this._cameraTransformId = undefined;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Sprite3D.prototype, "pixelsPerUnit", {
            /** Defines the size of the sprite relative to a unit in world space. */
            get: function () {
                return this._sprite.pixelsPerUnit;
            },
            set: function (value) {
                this._sprite.pixelsPerUnit = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Sprite3D.prototype, "tint", {
            /**
             * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF
             * will remove any tint effect.
             */
            get: function () {
                return this._sprite.tint;
            },
            set: function (value) {
                this._sprite.tint = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Destroys this sprite and optionally its texture and children.
         */
        Sprite3D.prototype.destroy = function (options) {
            _super.prototype.destroy.call(this, options);
            this._sprite.destroy(options);
        };
        /**
         * Renders the sprite.
         * @param renderer The renderer to use.
         */
        Sprite3D.prototype._render = function (renderer) {
            var camera = this.camera || Camera.main;
            var update = camera.transformId !== this._cameraTransformId ||
                this._parentID !== this.transform._worldID;
            if (update) {
                var scaling = this.worldTransform.scaling;
                Mat4.multiply(camera.view, this.worldTransform.array, this._modelView);
                switch (this._billboardType) {
                    case exports.SpriteBillboardType.spherical: {
                        this._modelView[0] = scaling[0];
                        this._modelView[1] = 0;
                        this._modelView[2] = 0;
                        this._modelView[3] = 0;
                        this._modelView[4] = 0;
                        this._modelView[5] = scaling[1];
                        this._modelView[6] = 0;
                        this._modelView[7] = 0;
                        break;
                    }
                    case exports.SpriteBillboardType.cylindrical: {
                        this._modelView[0] = scaling[0];
                        this._modelView[1] = 0;
                        this._modelView[2] = 0;
                        this._modelView[3] = 0;
                        this._modelView[8] = 0;
                        this._modelView[9] = 0;
                        this._modelView[10] = 1;
                        this._modelView[11] = 0;
                        break;
                    }
                }
                Mat4.multiply(camera.projection, this._modelView, this._sprite.modelViewProjection);
                this._parentID = this.transform._worldID;
                this._cameraTransformId = camera.transformId;
                var dir = Vec3.subtract(camera.worldTransform.position, this.worldTransform.position, vec3);
                var projection = Vec3.scale(camera.worldTransform.forward, Vec3.dot(dir, camera.worldTransform.forward), vec3);
                this._sprite.distanceFromCamera = Vec3.squaredMagnitude(projection);
            }
            this._sprite.worldAlpha = this.worldAlpha;
            this._sprite.render(renderer);
        };
        Object.defineProperty(Sprite3D.prototype, "anchor", {
            /**
             * The anchor sets the origin point of the sprite.
             */
            get: function () {
                return this._sprite.anchor;
            },
            set: function (value) {
                this._sprite.anchor = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Sprite3D.prototype, "texture", {
            /** The texture used when rendering the sprite. */
            get: function () {
                return this._sprite.texture;
            },
            set: function (value) {
                this._sprite.texture = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Sprite3D.prototype, "blendMode", {
            /** The blend used when rendering the sprite. */
            get: function () {
                return this._sprite.blendMode;
            },
            set: function (value) {
                this._sprite.blendMode = value;
            },
            enumerable: false,
            configurable: true
        });
        return Sprite3D;
    }(Container3D));

    exports.AABB = AABB;
    exports.Animation = Animation;
    exports.Camera = Camera;
    exports.CameraOrbitControl = CameraOrbitControl;
    exports.Color = Color;
    exports.Container3D = Container3D;
    exports.Cubemap = Cubemap;
    exports.CubemapLoader = CubemapLoader;
    exports.CubemapResource = CubemapResource;
    exports.ImageBasedLighting = ImageBasedLighting;
    exports.InstancedModel = InstancedModel;
    exports.InstancedStandardMaterial = InstancedStandardMaterial;
    exports.Joint = Joint;
    exports.Light = Light;
    exports.LightingEnvironment = LightingEnvironment;
    exports.Mat4 = Mat4;
    exports.Material = Material;
    exports.MaterialRenderPass = MaterialRenderPass;
    exports.Matrix4 = Matrix4;
    exports.Mesh3D = Mesh3D;
    exports.MeshGeometry3D = MeshGeometry3D;
    exports.MeshShader = MeshShader;
    exports.Model = Model;
    exports.ObservablePoint3D = ObservablePoint3D;
    exports.ObservableQuaternion = ObservableQuaternion;
    exports.PickingHitArea = PickingHitArea;
    exports.PickingInteraction = PickingInteraction;
    exports.Plane = Plane;
    exports.PostProcessingSprite = PostProcessingSprite;
    exports.Quat = Quat;
    exports.Ray = Ray;
    exports.ShaderSourceLoader = ShaderSourceLoader;
    exports.ShadowCastingLight = ShadowCastingLight;
    exports.ShadowRenderPass = ShadowRenderPass;
    exports.Skin = Skin;
    exports.Skybox = Skybox;
    exports.Sprite3D = Sprite3D;
    exports.SpriteBatchRenderer = SpriteBatchRenderer;
    exports.StandardMaterial = StandardMaterial;
    exports.StandardMaterialNormalTexture = StandardMaterialNormalTexture;
    exports.StandardMaterialOcclusionTexture = StandardMaterialOcclusionTexture;
    exports.StandardMaterialTexture = StandardMaterialTexture;
    exports.StandardPipeline = StandardPipeline;
    exports.TextureTransform = TextureTransform;
    exports.Transform3D = Transform3D;
    exports.Vec3 = Vec3;
    exports.glTFAsset = glTFAsset;
    exports.glTFBinaryLoader = glTFBinaryLoader;
    exports.glTFLoader = glTFLoader;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=pixi3d.js.map
